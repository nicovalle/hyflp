1
00:00:14,550 --> 00:00:15,790
Quisiera darles la bienvenida

2
00:00:15,790 --> 00:00:17,270
a este curso de ciencias del computador.

3
00:00:28,370 --> 00:00:29,990
En realidad, esta es una manera 
terrible de empezar

4
00:00:29,990 --> 00:00:32,740
Ciencias del computador
es un nombre terrible para este negocio.

5
00:00:32,740 --> 00:00:35,572
En primer lugar,
no es una ciencia.

6
00:00:35,572 --> 00:00:40,300
Podría ser ingeniería o podría ser arte,

7
00:00:40,300 --> 00:00:43,470
pero veremos que la así llamada 
ciencia del computador

8
00:00:43,470 --> 00:00:45,350
tiene mucho en común con la magia,
y eso lo veremos

9
00:00:45,350 --> 00:00:47,210
en este curso.

10
00:00:47,210 --> 00:00:48,040
Así que no es una ciencia.

11
00:00:48,040 --> 00:00:53,340
Tampoco es acerca de computadoras.

12
00:00:53,340 --> 00:00:57,140
Y no es acerca de computadoras 
en el mismo sentido que la física

13
00:00:57,140 --> 00:01:02,920
no es acerca de aceleradores de partículas,
y la biología

14
00:01:02,920 --> 00:01:06,350
no es acerca de microscopios y cápsulas de Petri.

15
00:01:06,350 --> 00:01:10,400
Y no acerca de computadores,
de la misma manera que

16
00:01:10,400 --> 00:01:16,480
la geometría no es acerca 
de usar elementos de inspección.

17
00:01:16,480 --> 00:01:20,320
De hecho, hay mucho en común 
con las ciencias de la computación

18
00:01:20,320 --> 00:01:21,240
y la geometría.

19
00:01:21,240 --> 00:01:23,830
La geometría, en principio, es otra área

20
00:01:23,830 --> 00:01:25,680
con un nombre malísimo.

21
00:01:25,680 --> 00:01:28,130
El nombre proviene de Gaia, 
que significa la Tierra, y metron,

22
00:01:28,130 --> 00:01:29,770
que significa medir.

23
00:01:29,770 --> 00:01:31,350
Geometría originalmente
significaba la medición

24
00:01:31,350 --> 00:01:34,260
de la Tierra o la inspección.

25
00:01:34,260 --> 00:01:37,260
Y la razón de eso es que,
hace miles de años,

26
00:01:37,260 --> 00:01:40,930
los sacerdotes egipcios desarrollaron
los rudimentos de

27
00:01:40,930 --> 00:01:45,320
la geometría para poder determinar 
como restaurar los

28
00:01:45,320 --> 00:01:47,430
límites de los campos que eran destruídos
en la inundaciones

29
00:01:47,430 --> 00:01:49,390
anuales del Nilo.

30
00:01:49,390 --> 00:01:52,360
Y para los egipcios que hacían eso,
la geometría era de hecho

31
00:01:52,360 --> 00:01:55,600
el uso de instrumentos de inspección.

32
00:01:55,600 --> 00:01:57,850
Ahora bien, la razón por la que pensamos 
que las ciencias del computador son acerca

33
00:01:57,850 --> 00:02:01,770
de computadoras es la misma razón
por la que los egipcios

34
00:02:01,770 --> 00:02:04,520
pensaban que la geometría era 
acerca de instrumentos de inspección.

35
00:02:04,520 --> 00:02:07,340
Y es que, cuando un campo recién
está comenzando

36
00:02:07,340 --> 00:02:11,790
y no es realmente comprendido muy bien,
es muy fácil

37
00:02:11,790 --> 00:02:15,280
confundir la esencia de los que se hace
con las herramientas

38
00:02:15,280 --> 00:02:17,590
que se utilizan.

39
00:02:17,590 --> 00:02:20,960
En efecto, en alguna escala absoluta,
probablemente sabemos

40
00:02:20,960 --> 00:02:25,100
menos sobre la esencia 
de las ciencias del computador

41
00:02:25,100 --> 00:02:26,955
que los antiguos egipcios 
acerca de la geometría.

42
00:02:29,970 --> 00:02:32,570
Bueno, ¿ qué quiero decir con esencia
de las ciencias del computador?

43
00:02:32,570 --> 00:02:34,300
¿Qué quiero decir con la esencia
de la geometría?

44
00:02:34,300 --> 00:02:36,380
Verán, es cierto que esos egipcios
salían y usaban

45
00:02:36,380 --> 00:02:40,190
instrumentos de inspección, pero
cuando cuando los miramos

46
00:02:40,190 --> 00:02:42,240
un par de miles de años después,
decimos que lo que

47
00:02:42,240 --> 00:02:45,910
estaban haciendo, lo realmente importante
que estaban haciendo, era

48
00:02:45,910 --> 00:02:52,510
empezar a formalizar las nociones del 
espacio y del tiempo, a comenzar

49
00:02:52,510 --> 00:02:57,490
a hablar acerca de verdades matemáticas
formalmente.

50
00:02:57,490 --> 00:02:59,420
Eso llevó al método axiomático.

51
00:02:59,420 --> 00:03:04,420
Y eso llevó a casi todas 
las matemáticas modernas.

52
00:03:04,420 --> 00:03:08,350
Descubriendo una manera de hablar 
precisamente acerca del así llamando

53
00:03:08,350 --> 00:03:10,000
conocimiento declarativo. 
Acerca de lo que es verdadero.

54
00:03:12,550 --> 00:03:15,680
Similarmente, pienso que en futuro,
la gente observará hacia atrás

55
00:03:15,680 --> 00:03:18,520
y dirá que sí, que esos primitivos del 
siglo XX

56
00:03:18,520 --> 00:03:20,190
estaban jugueteando con esos 
dispositivos llamados

57
00:03:20,190 --> 00:03:25,790
computadoras, pero que en realidad lo que
estaban haciendo era comenzar

58
00:03:25,790 --> 00:03:32,730
a aprender a formalizar intuiciones 
acerca del proceso, acerca de cómo

59
00:03:32,730 --> 00:03:47,100
hacer cosas. Empezar a desarrollar 
una manera para hablar

60
00:03:47,100 --> 00:03:52,190
precisamente acerca del conocimiento 
del 'cómo', en contraste con

61
00:03:52,190 --> 00:03:56,470
con la geometría que habla sobre
lo que es verdad.

62
00:03:56,470 --> 00:03:57,810
Déjenme darles un ejemplo de esto.

63
00:04:01,650 --> 00:04:02,550
Echemos un vistazo.

64
00:04:02,550 --> 00:04:08,250
Aquí está una pieza matemática
que dice qué

65
00:04:08,250 --> 00:04:10,250
es una raíz cuadrada.

66
00:04:10,250 --> 00:04:17,019
La raíz cuadrada de X es el número Y, 
tal que Y al cuadrado

67
00:04:17,019 --> 00:04:20,290
es igual a X e Y es mayor a cero.

68
00:04:20,290 --> 00:04:23,510
Ahora bien, esa es una pieza 
matemática, pero solamente decirte

69
00:04:23,510 --> 00:04:26,900
qué es una raíz cuadrada no dice 
realmente nada

70
00:04:26,900 --> 00:04:31,420
acerca de cómo uno puede ir 
y encontrar una.

71
00:04:31,420 --> 00:04:37,410
Así que contrastemos eso con una pieza
de conocimiento imperativo,

72
00:04:37,410 --> 00:04:39,840
cómo ir y encontrar la raíz cuadrada.

73
00:04:39,840 --> 00:04:44,660
Esto, de hecho, también proviene de 
Egipto,

74
00:04:44,660 --> 00:04:45,640
pero no el antiguo, antiguo Egipto.

75
00:04:45,640 --> 00:04:50,050
Este es un algoritmo de 
Herón de Alejandría, llamado

76
00:04:50,050 --> 00:04:52,910
cómo encontrar la raíz cuadrada
mediante promedios sucesivos.

77
00:04:52,910 --> 00:05:03,370
Y lo que dice es que, 
para hallar la raíz cuadrada,

78
00:05:03,370 --> 00:05:07,560
uno hace una estimación y luego
la mejora.

79
00:05:10,070 --> 00:05:12,670
Y la manera en la que mejora esa 
estimación es promediándola

80
00:05:12,670 --> 00:05:15,170
con X sobre la estimación. 
Luego hablaremos un poco acerca de

81
00:05:15,170 --> 00:05:17,080
por qué eso es algo razonable.

82
00:05:17,080 --> 00:05:19,740
Y se sigue mejorando la estimación
hasta que sea lo suficientemente buena.

83
00:05:19,740 --> 00:05:20,800
Eso es un método.

84
00:05:20,800 --> 00:05:25,070
Eso es cómo hacer algo
en oposición al conocimiento

85
00:05:25,070 --> 00:05:28,270
declarativo que dice 
qué es lo que están buscando.

86
00:05:28,270 --> 00:05:29,520
Eso es un proceso.

87
00:05:34,130 --> 00:05:38,850
Ahora bien,
¿Qué es un proceso en general?

88
00:05:38,850 --> 00:05:40,000
Es difícil de decir.

89
00:05:40,000 --> 00:05:45,350
Uno podría pensarlo como un espíritu
mágico que

90
00:05:45,350 --> 00:05:47,870
vive en la computadora y hace algo.

91
00:05:47,870 --> 00:05:56,250
Y aquello que dirige a un proceso
es una patrón de reglas

92
00:05:56,250 --> 00:05:57,500
llamado procedimiento.

93
00:06:01,690 --> 00:06:05,940
Así que los procedimientos son hechizos,
por así decirlo, que controlan

94
00:06:05,940 --> 00:06:10,700
a estos espíritus mágicos 
que son los procesos.

95
00:06:10,700 --> 00:06:12,650
Imagino que saben que todos necesitan
un lenguaje mágico y que

96
00:06:12,650 --> 00:06:17,310
los hechiceros, los verdaderos hechiceros,
usaban antiguo Arcadio o Sumerio

97
00:06:17,310 --> 00:06:18,670
o Babilonio o lo que sea.

98
00:06:18,670 --> 00:06:21,540
Nosotros conjuraremos nuestros espíritus
en un lenguaje mágico

99
00:06:21,540 --> 00:06:26,750
llamado Lisp, que es un lenguaje 
diseñado para hablar sobre

100
00:06:26,750 --> 00:06:31,120
y para realizar los hechizos 
que son los procedimienntos que dirigen

101
00:06:31,120 --> 00:06:32,040
los procesos.

102
00:06:32,040 --> 00:06:33,780
Ahora bien, es muy fácil aprender Lisp.

103
00:06:33,780 --> 00:06:35,810
De hecho, en unos pocos minutos, 
les enseñaré,

104
00:06:35,810 --> 00:06:36,960
esencialmente, todo Lisp.

105
00:06:36,960 --> 00:06:40,660
Les voy a enseñar, esencialmente,
todas las reglas.

106
00:06:40,660 --> 00:06:43,440
Y no deberían encontrar eso 
particularmente sorprendente.

107
00:06:43,440 --> 00:06:46,150
Es como decir que es muy fácil aprender

108
00:06:46,150 --> 00:06:46,940
las reglas del ajedrez.

109
00:06:46,940 --> 00:06:48,860
Y en efecto, en unos pocos minutos,
le pueden contar a alguien

110
00:06:48,860 --> 00:06:50,710
las reglas del ajedrez.

111
00:06:50,710 --> 00:06:53,490
Pero por supuesto, eso es muy diferente
a que tu digas que

112
00:06:53,490 --> 00:06:55,740
entiendes las implicaciones de esas reglas
y cómo usarlas

113
00:06:55,740 --> 00:06:58,420
para convertirte en un excelente
jugador de ajedrez.

114
00:06:58,420 --> 00:07:00,380
Bueno, Lisp es así.

115
00:07:00,380 --> 00:07:02,610
Declararemos las reglas en unos minutos

116
00:07:02,610 --> 00:07:03,360
y serán muy fácil de ver.

117
00:07:03,360 --> 00:07:06,210
Pero lo que será realmente difícil
son las implicaciones

118
00:07:06,210 --> 00:07:09,310
de esas reglas, cómo explotarlas
para ser

119
00:07:09,310 --> 00:07:12,080
un maestro programador.

120
00:07:12,080 --> 00:07:15,260
Y las implicaciones de esas reglas
nos llevarán

121
00:07:15,260 --> 00:07:17,770
bueno, el resto de la materia y, 
por supuesto,

122
00:07:17,770 --> 00:07:19,020
mucho más.

123
00:07:21,420 --> 00:07:26,070
Así que es ciencias de la computación,
estamos en el negocio de

124
00:07:26,070 --> 00:07:30,910
formalizar esta forma de 
conocimiento imperativo.

125
00:07:30,910 --> 00:07:33,330
Cómo hacer cosas.

126
00:07:33,330 --> 00:07:35,120
Y los verdaderos problemas de 
las ciencias de la computación son,

127
00:07:35,120 --> 00:07:38,620
por supuesto, no decirle a la gente
cómo calcular raíces cuadradas.

128
00:07:38,620 --> 00:07:40,050
Porque si eso fuera todo lo que hay,

129
00:07:40,050 --> 00:07:41,760
no sería un gran inconveniente.

130
00:07:41,760 --> 00:07:45,550
Los verdaderos problemas vienen cuando
intentamos construir sistemas muy grandes,

131
00:07:45,550 --> 00:07:49,270
programas de computadoras que 
tienen miles de páginas de longitud.

132
00:07:49,270 --> 00:07:52,640
Tan largos que nadie puede realmente
mantenerlo en su cabeza

133
00:07:52,640 --> 00:07:54,640
todo al mismo tiempo.

134
00:07:54,640 --> 00:07:58,770
Y la razón por la que eso es posible,
es porque

135
00:07:58,770 --> 00:08:17,830
hay técnicas que controlan la complejidad

136
00:08:17,830 --> 00:08:21,590
de estos sistemas grandes. 
Y esas técnicas

137
00:08:21,590 --> 00:08:22,950
que controlan la complejidad son

138
00:08:22,950 --> 00:08:24,700
el verdadero objeto de este curso.

139
00:08:24,700 --> 00:08:26,030
Y de alguna manera, 
eso es acerca de lo que

140
00:08:26,030 --> 00:08:29,650
las ciencias de la computación son.

141
00:08:29,650 --> 00:08:31,740
Ahora bien, eso puede parecer
algo muy extraño de decir.

142
00:08:31,740 --> 00:08:34,960
Porque, después de todo, un montón 
de gente al margen de los computadores

143
00:08:34,960 --> 00:08:37,970
científicos lidian con el control de 
la complejidad.

144
00:08:37,970 --> 00:08:41,860
Una gran aerolínea un es sistema
extremadamente complejo y

145
00:08:41,860 --> 00:08:44,760
los ingenieros aeronáuticos que la 
diseñan lidian con

146
00:08:44,760 --> 00:08:47,030
una complejidad inmensa.

147
00:08:47,030 --> 00:08:49,380
Pero hay una diferencia entre esa clase

148
00:08:49,380 --> 00:08:52,205
de complejidad y lo que nos enfrentamos
en las ciencias de la computación.

149
00:08:55,090 --> 00:08:57,750
Y eso es que es la ciencias de 
la computación

150
00:08:57,750 --> 00:08:59,700
en algún sentido, no son reales.

151
00:09:02,670 --> 00:09:07,070
Verán, cuando un ingeniero está 
diseñando un sistema físico,

152
00:09:07,070 --> 00:09:09,520
eso está hecho de piezas reales.

153
00:09:09,520 --> 00:09:12,820
Los ingenieros que se preocupan de eso
tienen que resolver problemas

154
00:09:12,820 --> 00:09:16,540
de tolerancia, aproximación
y ruido en el sistema.

155
00:09:16,540 --> 00:09:19,280
Por ejemplo, como un ingeniero eléctrico,
puedo ir

156
00:09:19,280 --> 00:09:21,885
y construir fácilmente un amplificador
de un nivel

157
00:09:21,885 --> 00:09:25,090
o un amplificador de dos niveles, 
y puedo imaginar apilar muchos de ellos

158
00:09:25,090 --> 00:09:26,760
para construir un amplificador
de millones de niveles.

159
00:09:26,760 --> 00:09:30,900
Pero es ridículo construir algo así,
porque mucho antes

160
00:09:30,900 --> 00:09:33,160
del millonésimo nivel,
el sonido térmico en esos

161
00:09:33,160 --> 00:09:34,740
componentes en el principio será

162
00:09:34,740 --> 00:09:36,200
amplificado y dejará toda la construcción
sin sentido.

163
00:09:38,880 --> 00:09:44,070
Las ciencias de la computación lidian
con componentes idealizados.

164
00:09:44,070 --> 00:09:47,430
Sabemos tanto como queremos acerca
de estos pequeños programas y

165
00:09:47,430 --> 00:09:51,820
piezas de datos que estamos juntando.

166
00:09:51,820 --> 00:09:53,090
No nos tenemos que preocupar
acerca de la tolerancia.

167
00:09:53,090 --> 00:09:57,960
Y eso significa que, al construir
un programa grande,

168
00:09:57,960 --> 00:10:01,720
no hay mucha diferencia 
entre lo que puedo

169
00:10:01,720 --> 00:10:06,520
construir y lo que puedo imaginar,
porque las partes son estas

170
00:10:06,520 --> 00:10:10,250
entidades abstractas de las que
conozco tanto como quiero.

171
00:10:10,250 --> 00:10:13,430
Conozco sobre ellas con tanta
precisión como quiera.

172
00:10:13,430 --> 00:10:15,920
Así que en contraste con otras
formas de ingeniería, donde

173
00:10:15,920 --> 00:10:17,830
las restricciones sobre lo que puedo
construir son aquellas de los

174
00:10:17,830 --> 00:10:19,810
sistemas físicos, las restricciones
de la física y

175
00:10:19,810 --> 00:10:24,160
del ruido y de la aproximación, 
las restricciones impuestas

176
00:10:24,160 --> 00:10:26,640
sobre los grandes sistemas de software
son las limitaciones

177
00:10:26,640 --> 00:10:28,930
de nuestras propias mentes.

178
00:10:28,930 --> 00:10:32,460
Así que de alguna manera, 
las ciencias de la computación son

179
00:10:32,460 --> 00:10:33,530
una forma abstracta de ingeniería.

180
00:10:33,530 --> 00:10:35,680
Es la clase de ingeniería donde
se ignoran las

181
00:10:35,680 --> 00:10:37,645
restricciones que se imponen
sobre la realidad

182
00:10:42,050 --> 00:10:46,400
Bueno, ¿cuáles son algunas 
de estas técnicas?

183
00:10:46,400 --> 00:10:47,830
No son únicas de las
ciencias de la computación

184
00:10:50,360 --> 00:10:54,140
La primera técnica, que se usa
en toda forma de ingeniería, es

185
00:10:54,140 --> 00:10:57,785
una especie de abstracción llamada
abstracción de caja negra.

186
00:11:07,670 --> 00:11:14,340
Agarrar algo y 
construir una caja alrededor.

187
00:11:14,340 --> 00:11:19,220
Por ejemplo, si miramos el método para
obtener raíces cuadradas,

188
00:11:19,220 --> 00:11:29,678
podría querer agarrarlo 
y construir una caja

189
00:11:29,678 --> 00:11:38,980
que dijera cómo encontrar la raíz
cuadrada de X. Y eso

190
00:11:38,980 --> 00:11:42,560
podría ser complejo conjunto de reglas.

191
00:11:42,560 --> 00:11:46,280
Y eso podría terminar siendo una cosa
donde puedo poner,

192
00:11:46,280 --> 00:11:50,270
digamos, 36 y preguntar cuál es la
raíz cuadrada de 36.

193
00:11:50,270 --> 00:11:51,520
Y saldrá un 6.

194
00:11:53,880 --> 00:11:59,630
Y lo importante es que me gustaría
diseñarlo para que si

195
00:11:59,630 --> 00:12:05,080
George viniese y quisiese computar,

196
00:12:05,080 --> 00:12:11,580
digamos, la raíz cuadrada de A
más la raíz cuadrada de B, él podría

197
00:12:11,580 --> 00:12:14,930
agarrar esta cosa y usarla 
como un módulo sin tener

198
00:12:14,930 --> 00:12:16,760
que mirar adentro y construir algo
que se parezca a esto:

199
00:12:16,760 --> 00:12:24,960
Una A, una B y una 
caja de raíz cuadrada y otra

200
00:12:24,960 --> 00:12:32,660
caja de raíz cuadrada y luego
algo que sume

201
00:12:32,660 --> 00:12:33,870
que devuelva la respuesta.

202
00:12:33,870 --> 00:12:38,830
Y pueden ver, que solo
por el hecho de que quiero hacer eso,

203
00:12:38,830 --> 00:12:41,560
desde el punto de vista de George, 
lo que hay adentro de esto

204
00:12:41,560 --> 00:12:44,170
no debería ser importante.

205
00:12:44,170 --> 00:12:46,940
Así que, por ejemplo, no debería
importar que, cuando escribo esto,

206
00:12:46,940 --> 00:12:50,750
digo que quiero hallar 
la raíz cuadrada de X. Podría

207
00:12:50,750 --> 00:12:54,840
haber dicho la raíz cuadrada de Y, 
o la raíz cuadrada de A, o

208
00:12:54,840 --> 00:12:56,890
ninguna cosa.

209
00:12:56,890 --> 00:13:03,480
Esa es la noción fundamental
de poner algo en una caja,

210
00:13:03,480 --> 00:13:07,520
usar abstracción de caja negra
para suprimir detalle.

211
00:13:07,520 --> 00:13:10,070
Y la razón de eso es que uno
querría ir construir

212
00:13:10,070 --> 00:13:11,990
cajas más grandes.

213
00:13:11,990 --> 00:13:13,880
Hay otra razón para hacer
abstracción de caja negra

214
00:13:13,880 --> 00:13:17,340
más allá de queres suprimir
detalles para

215
00:13:17,340 --> 00:13:18,310
construir cajas más grandes.

216
00:13:18,310 --> 00:13:24,880
A veces, uno quiere decir que
la manera de hacer algo,

217
00:13:24,880 --> 00:13:30,210
el método, es una instancia
de algo más general,

218
00:13:30,210 --> 00:13:33,430
y uno quisiera que el lenguaje
sea capaz de expresar

219
00:13:33,430 --> 00:13:35,560
esa generalidad.

220
00:13:35,560 --> 00:13:37,800
Déjenme darles otro ejemplo,

221
00:13:37,800 --> 00:13:38,740
siguiendo con raíces cuadradas.

222
00:13:38,740 --> 00:13:42,260
Miremos de vuelta la diapositiva

223
00:13:42,260 --> 00:13:44,380
del algoritmo de la raíz cuadrada.

224
00:13:44,380 --> 00:13:45,460
Recuerden lo que dice.

225
00:13:45,460 --> 00:13:50,700
Dice que, para hacer algo, 
hago una estimación y

226
00:13:50,700 --> 00:13:53,800
mejoro esa estimación y sigo

227
00:13:53,800 --> 00:13:56,970
mejorándola.

228
00:13:56,970 --> 00:13:59,560
Así que es la estrategia general.
Busco algo

229
00:13:59,560 --> 00:14:02,440
y la forma en la que lo encuentro es

230
00:14:02,440 --> 00:14:04,280
seguir mejorándolo.

231
00:14:04,280 --> 00:14:10,930
Ahora bien, eso es un caso particular
de otra clase de estrategia

232
00:14:10,930 --> 00:14:14,176
para hallar un punto fijo de algo.

233
00:14:14,176 --> 00:14:17,660
Así que tienes un punto fijo 
de una función

234
00:14:17,660 --> 00:14:26,090
Un punto fijo de una función es algo,
un valor.

235
00:14:26,090 --> 00:14:30,710
Un punto fijo de una función F 
es un valor Y, tal que F(Y)

236
00:14:30,710 --> 00:14:41,592
es igual a Y. Y la forma en que podría 
hacerlo es empezando con una estimación.

237
00:14:41,592 --> 00:14:44,630
Y luego si quiero que algo no cambie
cuando

238
00:14:44,630 --> 00:14:47,800
le sigo aplicando F, sigo aplicando F
una y otra vez hasta

239
00:14:47,800 --> 00:14:50,150
que el resultado no cambie
demasiado.

240
00:14:50,150 --> 00:14:52,290
Así que hay una estrategia general.

241
00:14:52,290 --> 00:14:56,250
Y luego, por ejemplo, para computar
la raíz cuadrada de X

242
00:14:56,250 --> 00:15:00,780
puedo intentar y hallar un punto fijo
de la función que

243
00:15:00,780 --> 00:15:05,020
lleva a Y al promedio de X/Y.
Y la idea es que si

244
00:15:05,020 --> 00:15:09,300
realmente tuviera en Y la raíz 
cuadrada de X, entonces Y y

245
00:15:09,300 --> 00:15:12,080
X/Y serían el mismo valor.

246
00:15:12,080 --> 00:15:16,370
Ambos serían la raíz cuadrada de X,
porque X sobre

247
00:15:16,370 --> 00:15:19,080
la raíz cuadrada de X 
es la raíz cuadrada de X.

248
00:15:19,080 --> 00:15:23,860
Así que si Y fuera
la raíz cuadrada de X,

249
00:15:23,860 --> 00:15:26,230
entonces el promedio no cambiaría.

250
00:15:26,230 --> 00:15:27,530
Así que la raíz cuadrada de X es 
un punto fijo

251
00:15:27,530 --> 00:15:30,250
de una función en particular.

252
00:15:30,250 --> 00:15:34,010
Ahora bien, lo que me gustaría tener,
lo que me gustaría expresar es

253
00:15:34,010 --> 00:15:36,430
una estrategia general para hallar
puntos fijos.

254
00:15:36,430 --> 00:15:37,210
Así que lo podría imaginar hacer, 
es ser capaz de

255
00:15:37,210 --> 00:15:37,309
usar mi lenguaje para definir una caja
que dijera "punto fijo",

256
00:15:37,309 --> 00:15:37,417
de la misma manera que podría hacer una
caja que dijera "raíz cuadrada".

257
00:15:37,417 --> 00:15:38,667
Y me gustaría poder expresar 
esto en mi lenguaje.

258
00:15:56,350 --> 00:16:00,870
Así que me gustaría expresar
no sólo el conocimento imperativo

259
00:16:00,870 --> 00:16:03,620
de una cosa en particular 
como la raíz cuadrada, sino que

260
00:16:03,620 --> 00:16:05,600
me gustaría poder expresar el 
conocimiento imperativo de

261
00:16:05,600 --> 00:16:09,930
cómo hacer algo general como hallar un
punto fijo.

262
00:16:09,930 --> 00:16:12,090
Y de hecho, miremos la diapositiva
de vuelta.

263
00:16:15,010 --> 00:16:23,380
No sólo es una pieza de conocimento
imperativo, cómo

264
00:16:23,380 --> 00:16:27,190
hallar un punto fijo, 
pare aquí debajo hay

265
00:16:27,190 --> 00:16:29,890
otra pieza de conocimento imperativo que

266
00:16:29,890 --> 00:16:34,350
dice que una forma de computar
la raíz cuadrada es aplicar este

267
00:16:34,350 --> 00:16:36,140
método general de punto fijo.

268
00:16:36,140 --> 00:16:37,710
Así que quiero ser capaz
de expresar

269
00:16:37,710 --> 00:16:39,700
ese conocimiento imperativo.

270
00:16:39,700 --> 00:16:40,650
¿Cómo se vería eso?

271
00:16:40,650 --> 00:16:46,010
Diría, esta caja de punto fijo
es tal que si

272
00:16:46,010 --> 00:16:56,980
le introduzco la función que 
lleva a Y de al promedio de Y

273
00:16:56,980 --> 00:17:04,300
y X/Y, entonces lo que saldrá
de esa caja de punto fijo será

274
00:17:04,300 --> 00:17:06,200
un método para hallar raíces cuadradas.

275
00:17:08,800 --> 00:17:10,829
Así que en estas cajas que estamos
construyendo, no sólo estamos

276
00:17:10,829 --> 00:17:16,368
construyendo cajas que reciben números
y devuelven números,

277
00:17:16,368 --> 00:17:19,410
sino también construiremos cajas que,
en efecto, computan

278
00:17:19,410 --> 00:17:22,250
métodos como hallar la raíz cuadrada.

279
00:17:22,250 --> 00:17:27,480
Y lo hago introduciendo funciones,
como Y va

280
00:17:27,480 --> 00:17:32,360
al promedio de Y y X/Y. Y la razón por
la queremos hacer eso,

281
00:17:32,360 --> 00:17:35,425
la razón por la que es un procedimiento, 
que terminará siendo un procedimiento,

282
00:17:35,425 --> 00:17:39,640
cuyo valor es, como veremos, otro
procedimiento, la razón por la que

283
00:17:39,640 --> 00:17:42,630
queremos hacer eso es porque
los procedimientos van a ser nuestros

284
00:17:42,630 --> 00:17:47,960
medios para hablar acerca de
conocimiento imperativo.

285
00:17:47,960 --> 00:17:50,560
Y la forma de hacer eso muy 
poderoso es poder hablar

286
00:17:50,560 --> 00:17:53,260
acerca de otros tipos de conocimiento.

287
00:17:53,260 --> 00:17:55,930
Así que aquí hay un procedimiento que,
en efecto, habla sobre otro

288
00:17:55,930 --> 00:17:59,450
procedimiento. Una estrategia general que
por sí misma habla sobre

289
00:17:59,450 --> 00:18:00,700
estrategias generales.

290
00:18:04,290 --> 00:18:08,370
El primer tema de este curso
-- habrá tres grandes temas--

291
00:18:08,370 --> 00:18:11,070
será abstracción de caja negra.

292
00:18:11,070 --> 00:18:15,150
Miremos eso con un poco más de detalle.

293
00:18:15,150 --> 00:18:23,910
Lo que haremos es empezar a hablar sobre

294
00:18:23,910 --> 00:18:27,480
como Lisp está construido con 
objetos primitivos.

295
00:18:27,480 --> 00:18:29,580
¿Qué nos provee el lenguaje?

296
00:18:29,580 --> 00:18:32,690
Y veremos que hay 
procedimientos primitivos

297
00:18:32,690 --> 00:18:35,620
y datos primitivos.

298
00:18:35,620 --> 00:18:38,510
Luego veremos cómo tomar esas primitivas

299
00:18:38,510 --> 00:18:41,940
y combinarlas para hacer cosas más
complicadas.

300
00:18:41,940 --> 00:18:42,860
Medio de combinación.

301
00:18:42,860 --> 00:18:44,824
Y lo que veremos es que hay formas
de poner

302
00:18:44,824 --> 00:18:47,850
cosas juntas, poner primitivas juntas

303
00:18:47,850 --> 00:18:50,960
para hacer procedimientos más
complicados.

304
00:18:50,960 --> 00:18:53,250
Y veremos cómo combinar datos primitivos

305
00:18:53,250 --> 00:18:55,830
para hacer datos compuestos.

306
00:18:55,830 --> 00:18:59,700
Luego diremos, bueno, habiendo hecho
estas cosas compuestas,

307
00:18:59,700 --> 00:19:02,830
¿cómo las abstraemos?

308
00:19:02,830 --> 00:19:05,290
¿Cómo ponemos esas cajas negras 
alrededor para

309
00:19:05,290 --> 00:19:08,090
usarlas como componentes en cosas más
complejas?

310
00:19:08,090 --> 00:19:11,640
Y veremos que eso se hace
definiendo procedimientos y

311
00:19:11,640 --> 00:19:13,740
una técnica para lidiar con datos
compuestos llamada

312
00:19:13,740 --> 00:19:15,540
abstracción de datos.

313
00:19:15,540 --> 00:19:19,150
Y luego, lo que quizá es lo 
más importante, es ir

314
00:19:19,150 --> 00:19:21,650
desde sólo las reglas a como 
trabaja un experto.

315
00:19:21,650 --> 00:19:25,800
¿Cómo expresar patrones comunes para
hacer cosas, como

316
00:19:25,800 --> 00:19:28,580
digamos, bueno, hay un método
general del punto fijo

317
00:19:28,580 --> 00:19:32,822
y la raíz cuadrada es un caso particular
de eso?

318
00:19:32,822 --> 00:19:34,290
Y usaremos,

319
00:19:34,290 --> 00:19:36,640
ya les di la pista, algo llamado 
procedimientos

320
00:19:36,640 --> 00:19:40,770
de alto orden. Procedimientos 
cuyas entradas y salidas

321
00:19:40,770 --> 00:19:43,230
son procedimientos.

322
00:19:43,230 --> 00:19:44,900
Y luego veremos algo muy interesante.

323
00:19:44,900 --> 00:19:47,730
Veremos, mientras avanzamos más
y más y nos volvamos

324
00:19:47,730 --> 00:19:50,310
más abstractos, que

325
00:19:50,310 --> 00:19:53,700
la línea entre lo que consideramos datos
y lo que

326
00:19:53,700 --> 00:19:56,920
consideramos procedimientos se hará difusa

327
00:19:56,920 --> 00:19:58,170
a un ritmo increíble.

328
00:20:03,270 --> 00:20:06,300
Bueno, ese el primer tema:
Abstracciones

329
00:20:06,300 --> 00:20:07,020
de caja negra.

330
00:20:07,020 --> 00:20:08,270
Miremos el segundo tema

331
00:20:10,640 --> 00:20:13,510
Puedo introducirlo así&gt;

332
00:20:13,510 --> 00:20:19,590
Supongan que quiero expresar la idea --

333
00:20:19,590 --> 00:20:22,790
recuerden, estamos hablando de ideas --

334
00:20:22,790 --> 00:20:30,950
Supongan que quiero expresa la idea de
puedo tomar algo

335
00:20:30,950 --> 00:20:36,070
y multiplicarlo por la suma de dos otras cosas.

336
00:20:36,070 --> 00:20:40,180
Por ejemplo, so tuviera 1 y 3 
y multiplico

337
00:20:40,180 --> 00:20:41,920
eso por 2, obtendría 8.

338
00:20:41,920 --> 00:20:43,930
Pero estoy hablando de la idea general
de lo que se conoce como

339
00:20:43,930 --> 00:20:46,470
combinación lineal, que puedas
sumar dos cosas

340
00:20:46,470 --> 00:20:49,170
y multiplicarlas por otra.

341
00:20:49,170 --> 00:20:51,040
Es muy fácil cuando lo pienso para
números, pero

342
00:20:51,040 --> 00:20:56,060
supongan que quiero usar la misma idea

343
00:20:56,060 --> 00:21:00,920
para sumar dos vectores a1 y a2,
y luego escalarlos por

344
00:21:00,920 --> 00:21:03,060
algún factor X y obtener otro vector.

345
00:21:03,060 --> 00:21:08,570
O podría decir, 
quisiera pensar a a1 y a2

346
00:21:08,570 --> 00:21:13,720
como polinomios y quisiera sumar
esos dos polinomios

347
00:21:13,720 --> 00:21:16,680
y luego multiplicarlos por 2
para obtener otro más complicado.

348
00:21:20,020 --> 00:21:24,650
O a1 y a2 pueden ser señales eléctricas
y podría

349
00:21:24,650 --> 00:21:26,870
pensar acerca de sumar esas dos señales

350
00:21:26,870 --> 00:21:29,350
eléctricas y luego poner resultado
a travéz

351
00:21:29,350 --> 00:21:33,890
de un amplificador, multiplicándolo
pr un facto de 2 o algo.

352
00:21:33,890 --> 00:21:34,850
La idea es que quiero pensar sobre

353
00:21:34,850 --> 00:21:38,530
la noción general de eso.

354
00:21:38,530 --> 00:21:42,880
Ahora, si nuestro lenguaje va ser
un buen lenguaje

355
00:21:42,880 --> 00:21:47,960
para expresar ese tipo de ideas
generales, si yo pudiera

356
00:21:47,960 --> 00:21:55,190
realmente hacer eso, me gustaría
ser capaz de decir que voy a

357
00:21:55,190 --> 00:22:03,660
multiplicar por X la suma de a1 y a2, 
y me gustaría que eso

358
00:22:03,660 --> 00:22:07,470
expresra la idea general de 
todas las cosas diferentes que

359
00:22:07,470 --> 00:22:09,980
a1 y a2 puedan ser.

360
00:22:09,980 --> 00:22:11,690
Si piensan sobre eso, 
hay un problema porque

361
00:22:11,690 --> 00:22:16,370
después de todo, las verdaderas
operaciones primitivas que van

362
00:22:16,370 --> 00:22:17,870
a la máquina serán obviamente diferentes

363
00:22:17,870 --> 00:22:22,070
si estuviera sumando dos números
o si estuviera sumando

364
00:22:22,070 --> 00:22:25,790
dos polinomios, o si estuviera
sumando la representación de dos

365
00:22:25,790 --> 00:22:27,940
señales eléctricas o formas de ondas.

366
00:22:27,940 --> 00:22:30,950
En algún lugar, tiene que haber
un conocimiento de la clase de

367
00:22:30,950 --> 00:22:33,140
distintas cosas que uno puede sumar

368
00:22:33,140 --> 00:22:34,390
y la forma de sumarlas.

369
00:22:37,110 --> 00:22:39,430
Para construir un sistema así, 
la pregunta es, ¿dónde

370
00:22:39,430 --> 00:22:41,090
pongo ese conocimiento?

371
00:22:41,090 --> 00:22:43,280
¿Cómo hago para pensar acerca de
las diferentes clases

372
00:22:43,280 --> 00:22:44,480
de opciones que tengo?

373
00:22:44,480 --> 00:22:48,310
Y si mañana George viene con una 
nueva clase de objeto

374
00:22:48,310 --> 00:22:51,770
que puede ser sumado y multiplicado,
¿Cómo agrego

375
00:22:51,770 --> 00:22:54,280
el nuevo objeto de George 
al sistema sin arruinar

376
00:22:54,280 --> 00:22:57,690
todo lo que ya estaba allí?

377
00:22:57,690 --> 00:23:00,790
Bueno, ese será el segundo gran tema.

378
00:23:00,790 --> 00:23:03,720
La forma de controlar esa clase de complejidad.

379
00:23:03,720 --> 00:23:07,480
Y la forma de hacerlo es
establecimiento interfaces

380
00:23:07,480 --> 00:23:20,230
convencionales, poniendo de acuerdo
en formas de combinar cosas.

381
00:23:20,230 --> 00:23:23,530
De la misma manera que la ingeniería
eléctrica, la gente

382
00:23:23,530 --> 00:23:26,520
tiene impedancias estándar para conectores,
y luego sabes

383
00:23:26,520 --> 00:23:28,080
que si construyes algo con uno de esas 
impedancias

384
00:23:28,080 --> 00:23:30,160
estándard, entonces puedes conectarlo
con otra cosa.

385
00:23:32,720 --> 00:23:34,300
Así que ese será nuestro
segundo gran tema,

386
00:23:34,300 --> 00:23:35,690
interfaces convencionales.

387
00:23:35,690 --> 00:23:39,000
Lo que veremos es que, 
primero, hablaremos

388
00:23:39,000 --> 00:23:41,400
sobre el problema de operaciones
genéricas, que es aquél

389
00:23:41,400 --> 00:23:46,100
al que aludí, cosas como "suma"
que tiene que trabajar con

390
00:23:46,100 --> 00:23:47,350
diferentes tipos de datos.

391
00:23:52,149 --> 00:23:54,660
Así que hablamos de operaciones
genéricas.

392
00:23:54,660 --> 00:23:58,270
Luego vamos a hablar sobre
estructuras de larga escala.

393
00:23:58,270 --> 00:24:01,820
¿Cómo combinar programs muy grandes
que modelan

394
00:24:01,820 --> 00:24:03,880
la clase de sistemas complejos del mundo real

395
00:24:03,880 --> 00:24:05,480
que queremos modelar?

396
00:24:05,480 --> 00:24:08,990
Y vermos que hay dos

397
00:24:08,990 --> 00:24:11,770
metáforas muy importantes para combinar
dichos sistemas.

398
00:24:11,770 --> 00:24:14,730
Una se llama programación orientada
a objetos, donde uno

399
00:24:14,730 --> 00:24:19,840
piensa al sistema como una sociedad
llena de pequeñas coasa

400
00:24:19,840 --> 00:24:21,150
que interactúan enviándose

401
00:24:21,150 --> 00:24:23,300
información entre ellos.

402
00:24:23,300 --> 00:24:26,540
Y la segunda es operaciones
en agregados,

403
00:24:26,540 --> 00:24:29,820
llamados flujos, donde uno piensa
a un sistema grande combinado

404
00:24:29,820 --> 00:24:33,530
de la misma forma que un ingeniero 
de procesamiento de señales

405
00:24:33,530 --> 00:24:35,020
construye un sistema eléctrico.

406
00:24:38,610 --> 00:24:40,240
Ese será nuestro segundo tema.

407
00:24:43,370 --> 00:24:47,000
La tercer forma veremos, 
la tercer ténica

408
00:24:47,000 --> 00:24:49,640
básica para controlar complejidad

409
00:24:49,640 --> 00:24:51,680
es crear nuevos lenguajes.

410
00:24:51,680 --> 00:24:54,370
Porque a veces, cuando uno está
sobrepasado

411
00:24:54,370 --> 00:24:56,640
por la complejidad del diseño,
la manera en que controlas

412
00:24:56,640 --> 00:25:01,330
esa complejidad es elegir
un nuevo lenguaje de diseño.

413
00:25:01,330 --> 00:25:03,330
Y el propósito de este nuevo lenguaje
de diseño será

414
00:25:03,330 --> 00:25:05,730
resaltar diferentes 
aspectos del sistema.

415
00:25:05,730 --> 00:25:08,360
Suprimirá algunos detalles y
enfatizará

416
00:25:08,360 --> 00:25:09,610
otros tipos de detalles.

417
00:25:12,910 --> 00:25:15,910
Esa va a ser la parte
más mágica del curso.

418
00:25:15,910 --> 00:25:18,350
Vamos a empezar por mirar

419
00:25:18,350 --> 00:25:21,730
a la tecnología para construir
nuevos lenguajes de computadora.

420
00:25:21,730 --> 00:25:25,770
Lo primero que haremos es
construir en Lisp.

421
00:25:29,210 --> 00:25:32,940
Vamos a expresar en Lisp
el proceso de interpretar

422
00:25:32,940 --> 00:25:33,800
el propio Lisp.

423
00:25:33,800 --> 00:25:36,840
Y eso va a ser algo
medio meta circular.

424
00:25:36,840 --> 00:25:38,870
Hay un pequeño símbolo místico

425
00:25:38,870 --> 00:25:40,750
que tiene que ver con eso.

426
00:25:40,750 --> 00:25:45,500
El proceso de interpretar Lis
es como una rueda gigante

427
00:25:45,500 --> 00:25:49,150
de dos procesos, apply y eval,
que constantente

428
00:25:49,150 --> 00:25:52,031
reducen expresiones entre sí.

429
00:25:52,031 --> 00:25:54,150
Luego veremos todo tipo 
de otras cosas mágicas.

430
00:25:54,150 --> 00:25:56,690
Este es otro símbolo mágico.

431
00:25:59,870 --> 00:26:02,260
Este es como el operador Y, 
que es, de alguna manera,

432
00:26:02,260 --> 00:26:04,800
la expresión de infinito

433
00:26:04,800 --> 00:26:06,390
dentro de nuestro lenguaje procedural.

434
00:26:06,390 --> 00:26:08,610
Le echaremos un vistazo a eso.

435
00:26:08,610 --> 00:26:11,880
En cualquier caso, esta sección
del curso se llama

436
00:26:11,880 --> 00:26:24,270
Abstracción Metalinguística,
abstrayendo hablando acerca de

437
00:26:24,270 --> 00:26:25,535
cómo construir nuevos lenguajes.

438
00:26:30,270 --> 00:26:34,140
Como dije, vamos a empezar mirando al

439
00:26:34,140 --> 00:26:35,530
proceso de interpretación.

440
00:26:35,530 --> 00:26:38,270
Miraremos este ciclo de apply-eval

441
00:26:38,270 --> 00:26:41,980
y contruiremos Lisp.

442
00:26:41,980 --> 00:26:44,450
Luego, solo para mostrarles que
es estoy es muy general,

443
00:26:44,450 --> 00:26:47,100
vamos a usar la misma tecnología
para construir un muy

444
00:26:47,100 --> 00:26:49,780
diferente tipo de lenguaje, un lenguaje
conocido como lenguaje de

445
00:26:49,780 --> 00:26:52,880
programación lógica, donde no se 
habla de procedimientos

446
00:26:52,880 --> 00:26:54,560
que tienen entradas y salidas.

447
00:26:54,560 --> 00:26:57,290
Lo que se hace es hablar de relaciones
entre cosas.

448
00:26:57,290 --> 00:27:01,220
Y luego, finalmente, vamos a hablar
sobre cómo

449
00:27:01,220 --> 00:27:04,140
implementar estas cosas de manera
muy concreta en

450
00:27:04,140 --> 00:27:06,830
los tipos de máquinas más simples.

451
00:27:06,830 --> 00:27:09,860
Veremos algo así.

452
00:27:09,860 --> 00:27:14,880
Esta es una imagen de un chip,
que es el intérprete de Lisp

453
00:27:14,880 --> 00:27:17,330
del que hablaremos en hardware.

454
00:27:21,010 --> 00:27:24,840
Bueno, hay un bosquejo del curso,
tres grande tópicos.

455
00:27:24,840 --> 00:27:28,120
Abstracción de caja negra, 
interfaces convencionales,

456
00:27:28,120 --> 00:27:31,590
abstracción metalinguística.

457
00:27:31,590 --> 00:27:33,480
Ahora, tomémonos un descanso
y luego empezaremos.

458
00:28:04,770 --> 00:28:08,020
Empecemos aprendiendo Lisp ahora.

459
00:28:08,020 --> 00:28:10,250
De hecho, empezaremos aprendiendo
algo mucho más

460
00:28:10,250 --> 00:28:12,320
importante, quizá la cosa más importante

461
00:28:12,320 --> 00:28:16,220
de este curso, que no es Lisp, en particular,
por supuesto, sino

462
00:28:16,220 --> 00:28:20,320
un framework general para pensar 
sobre lenguajes al que

463
00:28:20,320 --> 00:28:21,970
ya aludí.

464
00:28:21,970 --> 00:28:24,420
Cuando alguien te dice que te va 
mostrar un

465
00:28:24,420 --> 00:28:27,150
lenguaje, lo que deberían decir es, 
lo que me gustaría que dijeras es

466
00:28:27,150 --> 00:28:32,510
cuáles son los elemento primitivos.

467
00:28:37,490 --> 00:28:38,930
¿Con qué viene el lenguaje?

468
00:28:38,930 --> 00:28:43,650
Luego, ¿cuáles son las formas 
de combinar esas cosas?

469
00:28:43,650 --> 00:28:46,720
¿Cuáles son los medios de combinación?

470
00:28:50,190 --> 00:28:53,400
¿Cuáles son las cosas que te 
permiten tomar esos elementos

471
00:28:53,400 --> 00:28:57,920
primitivos y construir 
cosas más grandes con ellos?

472
00:28:57,920 --> 00:29:01,280
¿Cuáles con las formas de
combinar cosas?

473
00:29:01,280 --> 00:29:04,890
Y luego, 
¿cuáles son los medios de abstracción?

474
00:29:08,110 --> 00:29:15,830
¿Cómo tomamos esas cosas
complicadas y dibujamos

475
00:29:15,830 --> 00:29:16,750
cajas alrededor de ellas?

476
00:29:16,750 --> 00:29:20,180
¿Cómo las nombramos 
para que las podamos usar

477
00:29:20,180 --> 00:29:22,810
como elementos primitivos para hacer

478
00:29:22,810 --> 00:29:23,790
cosas aún más complejas?

479
00:29:23,790 --> 00:29:26,850
Y así y así y así.

480
00:29:26,850 --> 00:29:28,580
Así que cuando alguien te dice,
"tengo un gran lenguaje

481
00:29:28,580 --> 00:29:32,900
de computadora nuevo", no le preguntes
cuántos caracteres necesita

482
00:29:32,900 --> 00:29:35,810
para invertir una matriz.

483
00:29:35,810 --> 00:29:37,460
Es irrelevante.

484
00:29:37,460 --> 00:29:41,220
Lo que dices es, 
si el lenguaje no viene con matrices

485
00:29:41,220 --> 00:29:43,470
o con otra cosa, ¿cómo

486
00:29:43,470 --> 00:29:45,910
puedo hacer para contruirla?

487
00:29:45,910 --> 00:29:47,590
¿Cuáles son los medio de combinación
que me permiten

488
00:29:47,590 --> 00:29:48,610
hacer eso?

489
00:29:48,610 --> 00:29:52,450
Y luego, ¿cuáles son los medios
de abstracción que me permiten

490
00:29:52,450 --> 00:29:55,750
usar esos elementos para hacer

491
00:29:55,750 --> 00:29:57,000
cosas más complicadas?

492
00:29:58,960 --> 00:30:02,330
Bueno, veremos que Lisp
tiene algunos datos primitivos

493
00:30:02,330 --> 00:30:05,280
y algunos procedimientos primitivos.

494
00:30:05,280 --> 00:30:08,410
De hecho, empecemos realmente.

495
00:30:08,410 --> 00:30:09,950
Aquí hay una pieza de dato primitivo

496
00:30:09,950 --> 00:30:16,710
en Lisp, el número 3.

497
00:30:16,710 --> 00:30:18,800
En realidad, si estuviera muy pedante,

498
00:30:18,800 --> 00:30:19,790
ese no es el número 3.

499
00:30:19,790 --> 00:30:24,620
Ese es un símbolo que representa
el concepto de Platón

500
00:30:24,620 --> 00:30:27,060
del número 3.

501
00:30:27,060 --> 00:30:30,500
Y aquí hay otro.

502
00:30:30,500 --> 00:30:35,370
Aquí hay más datos primitivos
en Lisp, 17.4.

503
00:30:35,370 --> 00:30:40,940
O, en realidad, alguna representación
del 17.4.

504
00:30:40,940 --> 00:30:43,795
Y aquí hay otra, 5.

505
00:30:46,750 --> 00:30:48,490
Aquí hay otro objetivo primitivo
que está construido

506
00:30:48,490 --> 00:30:52,130
en Lisp, la suma.

507
00:30:52,130 --> 00:30:56,830
En verdad, para ser igual de pedante,
este es un nombre

508
00:30:56,830 --> 00:31:00,140
para el método primitivo
para sumar cosas.

509
00:31:00,140 --> 00:31:02,920
De la misma manera que esto es un 
nombre para el número 3 de Platón, esto es

510
00:31:02,920 --> 00:31:10,370
un nombre para el concepto platónico
de cómo sumar cosas.

511
00:31:10,370 --> 00:31:12,370
Así que esos son elementos primitivos.

512
00:31:12,370 --> 00:31:14,090
Los puedo poner juntos.

513
00:31:14,090 --> 00:31:18,140
Puedo decir, ¿cuál es la suma de
3 y 17.4 y 5?

514
00:31:18,140 --> 00:31:25,580
Y la forma de hacerlo es decir,
apliquemos el operador de suma

515
00:31:25,580 --> 00:31:27,600
a estos tres números.

516
00:31:27,600 --> 00:31:28,310
Y debo obtener, ¿qué?

517
00:31:28,310 --> 00:31:29,690
8,17.

518
00:31:29,690 --> 00:31:34,390
25.4.

519
00:31:34,390 --> 00:31:37,590
Así que debería poder preguntarle
a Lisp cuál es el valor de esto

520
00:31:37,590 --> 00:31:43,050
y me devolverá 25.4.

521
00:31:43,050 --> 00:31:44,610
Introduzcamos algunos nombres.

522
00:31:44,610 --> 00:31:50,950
Eso que escribí se llama
una combinación.

523
00:31:56,830 --> 00:31:59,040
Y una combinación consiste,
en general,

524
00:31:59,040 --> 00:32:02,790
en aplicar un operador --

525
00:32:02,790 --> 00:32:04,220
esto es un operador--

526
00:32:09,500 --> 00:32:13,190
a algunos operandos.

527
00:32:13,190 --> 00:32:14,440
Estos son los operandos.

528
00:32:21,760 --> 00:32:23,640
Y por supuesto, puedo hacer
cosas más complejas.

529
00:32:23,640 --> 00:32:25,950
La razón por la que puede obtener
complejidad de esto es

530
00:32:25,950 --> 00:32:30,290
porque en los operandos mismo, 
en general, pueden ser

531
00:32:30,290 --> 00:32:31,200
combinaciones.

532
00:32:31,200 --> 00:32:37,770
Así que por ejemplo, podría decir
¿cuál es la suma de 3 y

533
00:32:37,770 --> 00:32:45,660
el producto de 5 y 6 y 8 y 2?

534
00:32:45,660 --> 00:32:47,520
Y debería obtener, veamos.

535
00:32:47,520 --> 00:32:52,355
30, 40, 43.

536
00:32:52,355 --> 00:32:56,520
Así que Lisp debería
decirme que eso es 43.

537
00:32:56,520 --> 00:33:01,610
Formar combinaciones es la 
necesidad de combinación

538
00:33:01,610 --> 00:33:04,690
más básica que veremos.

539
00:33:04,690 --> 00:33:10,520
Y luego, bueno, 
verán un poco de sintaxis aquí.

540
00:33:10,520 --> 00:33:16,940
Lisp usa lo que se llama notación
prefija, que quiere decir que

541
00:33:16,940 --> 00:33:25,400
el operador se escribe a la izquierda
de los operandos.

542
00:33:25,400 --> 00:33:27,810
Sólo es una convención.

543
00:33:27,810 --> 00:33:29,960
Y noten, está totalmente
entre paréntesis.

544
00:33:29,960 --> 00:33:32,170
Y los paréntesis lo dejan
completamente sin ambiguedades.

545
00:33:32,170 --> 00:33:36,840
Asi que mirando esto, puedo ver 
que está el operador,

546
00:33:36,840 --> 00:33:42,760
y que hay 1,2,3,4 operandos.

547
00:33:42,760 --> 00:33:46,980
Y puedo ver que el segundo operando
aquí es en sí mismo una

548
00:33:46,980 --> 00:33:52,500
combinación que tiene 
un operador y dos operandos.

549
00:33:52,500 --> 00:33:55,740
Los paréntesis en Lisp, son un poco,
o muy diferentes,

550
00:33:55,740 --> 00:33:57,630
a los paréntesis de la matemática
convencional.

551
00:33:57,630 --> 00:34:01,400
En matemática, lo usamos para indicar
una agrupación,

552
00:34:01,400 --> 00:34:03,140
y a veces no molesta que no los pongas

553
00:34:03,140 --> 00:34:04,610
si la gente entiende

554
00:34:04,610 --> 00:34:05,790
que eso es un grupo.

555
00:34:05,790 --> 00:34:07,660
Y en general, 
no molesta si pones paréntesis

556
00:34:07,660 --> 00:34:09,760
de más, porque quizá distinga

557
00:34:09,760 --> 00:34:10,570
más aún la agrupación.

558
00:34:10,570 --> 00:34:13,010
Lisp no es así.

559
00:34:13,010 --> 00:34:17,020
En Lisp, no puede dejar los paréntesis,
y no puede poner paréntesis

560
00:34:17,020 --> 00:34:20,530
de más, porque agregar
paréntesis

561
00:34:20,530 --> 00:34:23,980
siempre significa de manera 
exacta y precisa que esto es

562
00:34:23,980 --> 00:34:27,260
una combinación que
tiene sentido, aplicando

563
00:34:27,260 --> 00:34:29,050
operadores a operandos.

564
00:34:29,050 --> 00:34:32,290
Y si no los pongo, 
si no pongo esos paréntesis,

565
00:34:32,290 --> 00:34:35,469
significaría otra cosa.

566
00:34:35,469 --> 00:34:38,100
De hecho, la manera de pensar sobre esto 
es que lo que realmente estoy

567
00:34:38,100 --> 00:34:42,280
haciendo cuando escribo algo así
es estar escribiendo un árbol.

568
00:34:42,280 --> 00:34:48,909
Así que esta combinación es un árbol
que tiene un más y luego un 3

569
00:34:48,909 --> 00:34:54,500
y luego algo más y un 8 y un 2.

570
00:34:54,500 --> 00:34:57,670
Y entonces esta otra cosa 
es en sí misma un pequeño

571
00:34:57,670 --> 00:35:03,770
subárbol que tiene una estrella
y un 5 y un 6.

572
00:35:03,770 --> 00:35:07,400
Y la manera de pensar en eso 
es que lo que en verdad

573
00:35:07,400 --> 00:35:13,260
estamos escribiendo estos árboles
y los paréntesis son una forma

574
00:35:13,260 --> 00:35:16,390
de escribir esta estructura 
de dos dimensiones como

575
00:35:16,390 --> 00:35:19,130
una cadena de caracteres lineal.

576
00:35:19,130 --> 00:35:22,110
Porque, por lo menos al principio,
cuando Lisp comenzaba y la gente

577
00:35:22,110 --> 00:35:24,630
tenía teletipo o tarjetas perforadas
o lo que sea, esto

578
00:35:24,630 --> 00:35:25,890
era más conveniente.

579
00:35:25,890 --> 00:35:29,590
Quizá si Lisp apareciera hoy,
la sintaxis de Lisp

580
00:35:29,590 --> 00:35:31,900
se vería así.

581
00:35:31,900 --> 00:35:33,720
Bueno, observemos cómo
se ve eso

582
00:35:33,720 --> 00:35:36,450
en una computadora.

583
00:35:36,450 --> 00:35:39,320
Aquí tengo establecida
una interacción Lisp.

584
00:35:39,320 --> 00:35:41,060
Hay un editor.

585
00:35:41,060 --> 00:35:43,980
Y arriba, voy a tipear algunos valores
y preguntarle a Lisp

586
00:35:43,980 --> 00:35:45,050
lo que son.

587
00:35:45,050 --> 00:35:46,750
Por ejemplo, puedo preguntarle a Lisp,
cuál es

588
00:35:46,750 --> 00:35:49,370
el valor de este símbolo.

589
00:35:49,370 --> 00:35:50,050
Es un 3.

590
00:35:50,050 --> 00:35:51,850
Y le pido a Lisp que lo evalúe.

591
00:35:51,850 --> 00:35:55,530
Y ahí ven que Lisp ha terminado
debajo y ha dicho

592
00:35:55,530 --> 00:35:57,690
oh sí, es un 3.

593
00:35:57,690 --> 00:36:06,490
O puedo decir, ¿cuál es la suma de 3 y 
4 y de 8?

594
00:36:06,490 --> 00:36:08,950
¿Cuánto da esa combinación?

595
00:36:08,950 --> 00:36:10,660
Y pedirle a Lisp que lo evalúe.

596
00:36:14,660 --> 00:36:16,246
Es 15.

597
00:36:16,246 --> 00:36:19,210
O puedo tipear algo
más complicado.

598
00:36:19,210 --> 00:36:29,510
Puedo preguntar cuál es la suma 
del producto de 3 y la suma

599
00:36:29,510 --> 00:36:35,210
de 7 y 19.5.

600
00:36:35,210 --> 00:36:37,820
Y notarán que Lisp viene 
con algo incorporado

601
00:36:37,820 --> 00:36:39,660
que ayuda para dar seguimiento
a todos estos paréntesis.

602
00:36:39,660 --> 00:36:42,260
Miren que al tipear el próximo
paréntesis de cierre, que va

603
00:36:42,260 --> 00:36:45,620
a cerrar la combinación que 
comienza con la estrella,

604
00:36:45,620 --> 00:36:48,220
el paréntesis de apertura 
se remarcará.

605
00:36:48,220 --> 00:36:50,200
Borraré estos y lo haré de nuevo.

606
00:36:50,200 --> 00:36:53,590
Tipeo el cierre y 
verán que cierra el más.

607
00:36:53,590 --> 00:36:57,910
Cierro de nuevo y 
eso cierra la estrella.

608
00:36:57,910 --> 00:36:59,570
Ahora vuelvo a la suma,
y quizá voy a sumar

609
00:36:59,570 --> 00:37:01,480
a todo eso un 4.

610
00:37:01,480 --> 00:37:02,630
Eso cierra el más.

611
00:37:02,630 --> 00:37:05,750
Ahora tengo una combinación
completa y puedo preguntarle

612
00:37:05,750 --> 00:37:07,170
a Lisp el valor de eso.

613
00:37:07,170 --> 00:37:11,310
Ese balanceo de paréntesis
está incorporado en un montón

614
00:37:11,310 --> 00:37:13,630
de sistemas Lisp para dar seguimiento
porque es realmente

615
00:37:13,630 --> 00:37:16,760
difícil de hacer a mano con todos
esos paréntesis.

616
00:37:16,760 --> 00:37:20,520
Hay otra convención 
para mantener un seguimiento

617
00:37:20,520 --> 00:37:21,100
de los paréntesis.

618
00:37:21,100 --> 00:37:24,800
Déjenme escribir otra 
combinación complicada.

619
00:37:24,800 --> 00:37:33,170
Tomemos la suma del producto
de 3 y de 5 y sumemos eso

620
00:37:33,170 --> 00:37:34,090
a algo más.

621
00:37:34,090 --> 00:37:37,510
Y lo que voy a hacer es 
indentar para que

622
00:37:37,510 --> 00:37:39,830
los operandos se escriban
verticalmente.

623
00:37:39,830 --> 00:37:47,250
Que es la suma de eso y 
el producto de 47 y --

624
00:37:47,250 --> 00:37:50,340
digamos el producto el 47 con la

625
00:37:50,340 --> 00:37:54,520
diferencia de 20 y 6.8.

626
00:37:54,520 --> 00:37:58,236
Eso quiere decir restarle 6.8 a 20.

627
00:37:58,236 --> 00:38:00,050
Y luego ven los 
paréntesis cerrarse.

628
00:38:00,050 --> 00:38:01,890
Cierro el menos.

629
00:38:01,890 --> 00:38:03,572
Cierro la estrella.

630
00:38:03,572 --> 00:38:05,150
Y ahora pongamos otro operando.

631
00:38:05,150 --> 00:38:08,230
Verán que el editor de Lisp
está indentando a la derecha

632
00:38:08,230 --> 00:38:12,660
de la posición automáticamente
para ayudarme a dar seguimiento.

633
00:38:12,660 --> 00:38:13,920
Lo haré de nuevo.

634
00:38:13,920 --> 00:38:16,220
Cerraré ese último 
paréntesis de nuevo.

635
00:38:16,220 --> 00:38:17,470
Verán que balancea el más.

636
00:38:20,340 --> 00:38:24,100
Ahora puedo preguntar,
¿cuál es el valor de eso?

637
00:38:24,100 --> 00:38:29,620
Así que esas dos cosas,
indentar a la derecha, que se conoce

638
00:38:29,620 --> 00:38:34,230
como impresión bonita, 
y remarcar paréntesis, son dos

639
00:38:34,230 --> 00:38:37,120
cosas que muchos sistemas Lisp
tienen incorporadas para ayudar

640
00:38:37,120 --> 00:38:37,660
a dar seguimiento.

641
00:38:37,660 --> 00:38:38,910
Y deberían aprender cómo usarlos.

642
00:38:42,020 --> 00:38:44,640
Bueno, esas son las primitivas.

643
00:38:44,640 --> 00:38:46,190
Hay un medio de combinación.

644
00:38:46,190 --> 00:38:49,360
Ahora vayamos a los medios
de abstracción.

645
00:38:49,360 --> 00:38:52,400
Me gustaría poder tomar la idea
de que hago una

646
00:38:52,400 --> 00:38:54,820
combinación como esta 
y abstraerla y darle un

647
00:38:54,820 --> 00:38:57,300
nombre simple, para que la pueda
usar como un elemento.

648
00:38:57,300 --> 00:39:01,770
Y eso lo hago en Lisp con "define".
Y puedo decir,

649
00:39:01,770 --> 00:39:14,515
por ejemplo, define A para que sea
el producto de 5 y 5.

650
00:39:17,936 --> 00:39:23,240
Y luego puedo preguntarle a Lisp,
por ejemplo, cuál es el

651
00:39:23,240 --> 00:39:26,742
producto de A y A.

652
00:39:26,742 --> 00:39:31,980
Y esto debería ser 25,
y esto otro debería ser 625.

653
00:39:31,980 --> 00:39:36,200
Y luego, algo crucial,
puedo usar ahora A--

654
00:39:36,200 --> 00:39:38,360
aquí lo usé como una combinación--

655
00:39:38,360 --> 00:39:41,770
pero puedo usarlo en cosas
más complicadas que puedo

656
00:39:41,770 --> 00:39:43,440
nombrar también.

657
00:39:43,440 --> 00:39:53,970
Así que puedo decir, define B para
que sea la suma de, digamos, A y

658
00:39:53,970 --> 00:40:00,260
el producto de 5 y A. 
Y luego cierro el más.

659
00:40:03,470 --> 00:40:04,920
Miremos esto en la computadora y

660
00:40:04,920 --> 00:40:07,850
observemos cómo se ve.

661
00:40:07,850 --> 00:40:10,515
Solo tipearé lo que escribí
en el pizarrón.

662
00:40:10,515 --> 00:40:21,165
Puedo decir, define A como 
el producto de 5 y 5.

663
00:40:23,675 --> 00:40:25,640
Y contarle eso a a Lisp.

664
00:40:25,640 --> 00:40:27,320
Y noten que Lisp 
respondió ahí con

665
00:40:27,320 --> 00:40:29,120
una A debajo.

666
00:40:29,120 --> 00:40:31,680
En general, cuando tipeas
una definición en Lisp,

667
00:40:31,680 --> 00:40:35,180
éste responde con el símbolo
que se está definiendo.

668
00:40:35,180 --> 00:40:39,200
Ahora podría preguntarle a Lisp
cuál es el producto de A y A.

669
00:40:42,266 --> 00:40:46,140
Y dice que es 625.

670
00:40:46,140 --> 00:40:59,790
Puedo definir B como la suma
de A y el producto de 5 y A.

671
00:40:59,790 --> 00:41:03,110
Cierro el paréntesis de la estrella.

672
00:41:03,110 --> 00:41:04,600
Cierro el más.

673
00:41:04,600 --> 00:41:11,030
Cierro el "define". Lisp dice, OK,
B, ahí debajo.

674
00:41:11,030 --> 00:41:13,110
Y ahora puedo preguntarle a Lisp
el valor de B.

675
00:41:17,100 --> 00:41:19,310
O puedo pedirle algo más complicado,
como cuál es

676
00:41:19,310 --> 00:41:26,600
la suma de A y el cociente entre B y 5.

677
00:41:26,600 --> 00:41:30,430
Esa barra es dividir, otro
operador primitivo.

678
00:41:30,430 --> 00:41:33,830
Dividí B por 5 y se lo sumé a A.
Lisp dice,

679
00:41:33,830 --> 00:41:36,830
OK, eso es 55.

680
00:41:36,830 --> 00:41:39,810
Así que así es que cómo se ve.

681
00:41:39,810 --> 00:41:43,670
Ahí está el medio básico
para definir algo.

682
00:41:43,670 --> 00:41:47,870
Es la manera más simple de nombrar,
pero no es realmente

683
00:41:47,870 --> 00:41:49,970
muy poderoso.

684
00:41:49,970 --> 00:41:51,760
Verán, lo que en verdad
quisiera nombrar --

685
00:41:51,760 --> 00:41:53,510
recuerden que estamos hablando
de métodos generales --

686
00:41:53,510 --> 00:41:56,810
Me gustaría nombrar la idea general de,

687
00:41:56,810 --> 00:42:11,440
por ejemplo, multiplicar 5 por 5,
o 6 por 6, o 1001

688
00:42:11,440 --> 00:42:18,240
por 1001, o 1001.7 por 1001.7.

689
00:42:18,240 --> 00:42:22,350
Me gustaría poder nombrar
la idea general de

690
00:42:22,350 --> 00:42:23,970
multiplicar algo por sí mismo.

691
00:42:28,400 --> 00:42:28,960
Bueno, ustedes saben qué es.

692
00:42:28,960 --> 00:42:31,146
Se llama elevar al cuadrado.

693
00:42:31,146 --> 00:42:43,640
Y la forma en que puedo 
hacerlo en Lisp es definir

694
00:42:43,640 --> 00:42:57,850
"square" de algo X como 
multiplicar X por sí mismo.

695
00:42:57,850 --> 00:43:01,260
Y al hacer eso, puedo 
preguntarle a Lisp, por ejemplo,

696
00:43:01,260 --> 00:43:06,240
cuánto es 10 al cuadrado.

697
00:43:06,240 --> 00:43:10,240
Y Lisp dirá 100.

698
00:43:10,240 --> 00:43:14,796
Ahora miremos esto 
un poco más de cerca.

699
00:43:14,796 --> 00:43:17,040
Aquí está la definición de "square".

700
00:43:17,040 --> 00:43:23,730
Para elevar algo al cuadrado,
multiplicarlo por sí mismo.

701
00:43:23,730 --> 00:43:26,210
Ven esta X aquí.

702
00:43:26,210 --> 00:43:28,550
Es algo así como un pronombre,
algo a lo que

703
00:43:28,550 --> 00:43:31,380
voy a elevar al cuadrado.

704
00:43:31,380 --> 00:43:35,220
Y lo que hago con él es
multiplico X,

705
00:43:35,220 --> 00:43:36,930
lo multiplico por sí mismo.

706
00:43:44,670 --> 00:43:44,775
OK.

707
00:43:44,775 --> 00:43:48,280
Esa es la notación para definir 
un procedimiento.

708
00:43:48,280 --> 00:43:52,500
De hecho, esto es un poco confuso,
porque es

709
00:43:52,500 --> 00:43:53,830
algo así a cómo usaría "square".

710
00:43:53,830 --> 00:43:57,790
Y digo "square" de X,
o "square" de 10, pero

711
00:43:57,790 --> 00:44:00,300
no estoy dejando muy en claro
que estoy en efecto nombrando algo.

712
00:44:02,970 --> 00:44:05,790
Así que déjenme escribir esta
definición de otra forma

713
00:44:05,790 --> 00:44:06,770
que deja un poco más claro

714
00:44:06,770 --> 00:44:08,420
que estoy nombrando algo.

715
00:44:08,420 --> 00:44:28,250
Diré, "define square" como 
lambda de x , multiplicar X por X.

716
00:44:36,550 --> 00:44:40,480
Aquí estoy nombrando algo como "square",
de la misma manera que aquí

717
00:44:40,480 --> 00:44:44,390
estoy nombrando algo A. Pero aquello a
lo que estoy llamando "square"--

718
00:44:44,390 --> 00:44:49,290
Aquí, lo que nombro A 
es el valor de esta combinación.

719
00:44:49,290 --> 00:44:52,270
Aquí, lo que estoy llamando "square"
es esta cosa que

720
00:44:52,270 --> 00:44:55,610
comienza con un lambda, y 
lambda es la forma de Lisp de decir

721
00:44:55,610 --> 00:44:56,860
"haz un procedimiento".

722
00:45:00,150 --> 00:45:04,170
Miremos esto más de cerca 
en la diapositiva.

723
00:45:04,170 --> 00:45:07,410
La manera en leo esta definición es
defino "square" como

724
00:45:07,410 --> 00:45:09,910
un procedimiento --

725
00:45:12,730 --> 00:45:14,010
eso es lo que la lambda es--

726
00:45:14,010 --> 00:45:19,220
Haz un procedimiento 
con un argumento llamado X.

727
00:45:19,220 --> 00:45:22,030
Y lo hace es retorna el resultado de

728
00:45:22,030 --> 00:45:24,920
multiplicar X por sí mismo.

729
00:45:24,920 --> 00:45:32,380
Ahora bien, en general, 
vamos a usar esta anterior forma

730
00:45:32,380 --> 00:45:35,050
de definir, solamente porque 
es un poco más conveniente.

731
00:45:35,050 --> 00:45:38,750
Pero no pierdan de vista el hecho
que en realidad es esto.

732
00:45:38,750 --> 00:45:41,530
De hecho, en lo que al intérprete
de Lisp respecta,

733
00:45:41,530 --> 00:45:44,830
no hay diferencia entre tipear esto

734
00:45:44,830 --> 00:45:46,460
o tipear esto otro.

735
00:45:46,460 --> 00:45:54,380
Y hay una palabra para eso,
azúcar sintáctico.

736
00:45:54,380 --> 00:45:58,400
Lo que azúcar sintáctico significa,
es tener formas más

737
00:45:58,400 --> 00:46:01,060
convenientes para escribir algo.

738
00:46:01,060 --> 00:46:04,470
Así que esto es en realidad esto es
azúcar sintáctico para

739
00:46:04,470 --> 00:46:07,310
esta cosa griega con la lambda.

740
00:46:07,310 --> 00:46:09,710
Y la razón por la que deben recordar
esto es que no se olviden que,

741
00:46:09,710 --> 00:46:12,430
al escribir algo así,

742
00:46:12,430 --> 00:46:14,380
estoy realmente nombrando algo.

743
00:46:14,380 --> 00:46:17,040
Estoy nombrando algo como "square",
y ese algo que estoy

744
00:46:17,040 --> 00:46:21,620
nombrando como "square" es un 
procedimiento que se está construyendo.

745
00:46:21,620 --> 00:46:24,820
Miremos eso en la computadora también.

746
00:46:24,820 --> 00:46:30,660
Así que diré, "define square" de

747
00:46:30,660 --> 00:46:34,670
X como multiplicar X por X.

748
00:46:49,570 --> 00:46:53,042
Ahora digámosle eso a Lisp.

749
00:46:53,042 --> 00:46:56,580
Dice "square". Ven, he nombrado algo
como "square". Ahora,

750
00:46:56,580 --> 00:47:00,760
habiendo hecho esto, 
le puedo preguntar a Lisp cuál es

751
00:47:00,760 --> 00:47:05,230
"square" de 1001?

752
00:47:05,230 --> 00:47:14,920
O , en general, podría decir,
¿cuánto es elevar al cuadrado la suma de

753
00:47:14,920 --> 00:47:17,340
de 5 y de 7?

754
00:47:22,532 --> 00:47:25,190
Eso es elevar al cuadrado 12, 144.

755
00:47:25,190 --> 00:47:28,080
O puedo usar "square" en sí mismo 
como un elemento en alguna

756
00:47:28,080 --> 00:47:28,680
combinación.

757
00:47:28,680 --> 00:47:36,240
Puedo preguntar, 
¿cuál es la suma del "square" de 3 y

758
00:47:36,240 --> 00:47:37,490
el "square"de 4?

759
00:47:42,480 --> 00:47:44,950
9 más 16 es 25.

760
00:47:44,950 --> 00:47:49,580
O puedo usar "square" como un elemento
en una cosa mucho más

761
00:47:49,580 --> 00:47:50,390
complicada.

762
00:47:50,390 --> 00:47:53,032
Puedo preguntar, ¿cuál es el "square" del
"square" del

763
00:47:53,032 --> 00:48:07,016
"square" de 1001?

764
00:48:07,016 --> 00:48:11,160
Y eso elevar al cuadrado 
el cuadrado del cuadrado de 1001.

765
00:48:11,160 --> 00:48:15,620
O puedo preguntarle a Lisp
¿qué es "square"?

766
00:48:15,620 --> 00:48:17,040
¿Cuál es el valor de eso?

767
00:48:17,040 --> 00:48:21,040
Y Lisp retorna una manera
convencional para decirme

768
00:48:21,040 --> 00:48:22,200
que eso es un procedimiento.

769
00:48:22,200 --> 00:48:24,990
Dice, "procedimiento compuesto square".
Recuerden que el valor de

770
00:48:24,990 --> 00:48:30,050
"square" es este procedimiento,
y las estrellas

771
00:48:30,050 --> 00:48:33,810
y los corchetes es la forma
convencional de Lisp

772
00:48:33,810 --> 00:48:37,010
para describir eso.

773
00:48:37,010 --> 00:48:40,830
Ahora veamos dos 
ejemplos más de definición.

774
00:48:45,020 --> 00:48:47,210
Aquí hay dos procedimientos más.

775
00:48:47,210 --> 00:48:51,860
Defino el promedio de X e Y 
como la suma de X y de Y

776
00:48:51,860 --> 00:48:54,460
dividido por 2.

777
00:48:54,460 --> 00:49:00,830
O teniendo el promedio 
y el cuadrado medio, teniendo el promedio

778
00:49:00,830 --> 00:49:03,970
y el cuadrado, puedo usarlos para definir
el "mean square" o cuadrado medio de

779
00:49:03,970 --> 00:49:08,325
algo, que es el promedio 
del cuadrado de X y el

780
00:49:08,325 --> 00:49:10,790
cuadrado de Y.

781
00:49:10,790 --> 00:49:13,870
Así que por ejemplo, habiendo hecho eso,
podría preguntar cuál es

782
00:49:13,870 --> 00:49:24,915
el "mean square" de 2 y 3?

783
00:49:24,915 --> 00:49:29,530
Y debería obtener el promedio
de 4 y 9, que es 6.5.

784
00:49:32,970 --> 00:49:37,000
Lo clave aquí es que, al haber
definido "square", puedo

785
00:49:37,000 --> 00:49:38,560
usarlo como si fuera una primitiva.

786
00:49:41,410 --> 00:49:45,200
Así que si miramos en
la diapositiva, si miro a

787
00:49:45,200 --> 00:49:50,910
"mean square", la persona que define
el cuadrado medio no tiene que

788
00:49:50,910 --> 00:49:54,660
saber, en este punto, si "square"
vino incorporado

789
00:49:54,660 --> 00:49:57,540
en el lenguaje o si fue

790
00:49:57,540 --> 00:49:59,600
un procedimiento que fue definido.

791
00:49:59,600 --> 00:50:04,040
Y eso es algo clave en Lisp,
que uno no hace

792
00:50:04,040 --> 00:50:08,230
distinciones arbitrarias entre
cosas que resultan que son

793
00:50:08,230 --> 00:50:10,400
primitivas del lenguaje
y cosas que

794
00:50:10,400 --> 00:50:12,740
resultan que viene incorporadas.

795
00:50:12,740 --> 00:50:14,750
Una persona usándolo 
ni siquiera debería tener que saberlo.

796
00:50:14,750 --> 00:50:17,800
Así que las que cosas que construimos
son usada con todo el poder

797
00:50:17,800 --> 00:50:19,700
y la flexibilidad 
a que si fueran primitivas.

798
00:50:19,700 --> 00:50:21,470
De hecho, podemos asentar esto
mirando en la

799
00:50:21,470 --> 00:50:24,750
computadora una vez más.

800
00:50:24,750 --> 00:50:26,680
Ya hablamos del "plus".

801
00:50:26,680 --> 00:50:29,920
Y de hecho, si vengo aquí en la
pantalla de la computadora y pregunto

802
00:50:29,920 --> 00:50:31,745
cuál es el valor de "plus".

803
00:50:34,380 --> 00:50:36,120
Noten lo que escribe Lisp.

804
00:50:36,120 --> 00:50:38,230
Aquí debajo, escribió
"procedimiento compuesto

805
00:50:38,230 --> 00:50:43,070
plus". Porque en este sistema, 
resulta que el

806
00:50:43,070 --> 00:50:45,770
operador de adición es en sí mismo
un procedimiento compuesto.

807
00:50:45,770 --> 00:50:48,140
Y si no hubiera tipeado esto, 
ustedes nunca lo hubieran sabido, y

808
00:50:48,140 --> 00:50:49,710
de cualquier manera no habría
marcado la diferencia.

809
00:50:49,710 --> 00:50:50,240
No nos interesa.

810
00:50:50,240 --> 00:50:52,500
Está por debajo del nivel de 
abstracción

811
00:50:52,500 --> 00:50:54,120
con el que estamos lidiando.

812
00:50:54,120 --> 00:50:57,230
Así que la clave es que uno no puede
determinar, no debería ser capaz

813
00:50:57,230 --> 00:51:00,910
de determinar, en general, la diferencia
entre cosas que

814
00:51:00,910 --> 00:51:03,590
están incorporadas y 
cosas que son compuestas.

815
00:51:03,590 --> 00:51:04,160
¿Por qué es esto?

816
00:51:04,160 --> 00:51:06,630
Porque las cosas compuestas
tienen una abstracción

817
00:51:06,630 --> 00:51:09,420
alrededor de ellas.

818
00:51:09,420 --> 00:51:12,510
Ya hemos visto casi todos los
elementos de Lisp.

819
00:51:12,510 --> 00:51:15,090
Solo queda una cosa más que tenemos
que mirar, y eso cómo

820
00:51:15,090 --> 00:51:16,510
hacer un análisis de casos.

821
00:51:16,510 --> 00:51:18,760
Déjenme mostrarles lo que quiero decir.

822
00:51:18,760 --> 00:51:22,550
Querríamos pensar acerca de la 
definición matemática del

823
00:51:22,550 --> 00:51:23,740
de la función de valor absoluto.

824
00:51:23,740 --> 00:51:30,520
Podría decir que el valor absoluto
de X es al función que tiene la

825
00:51:30,520 --> 00:51:35,670
propiedad que es el negativo de X

826
00:51:35,670 --> 00:51:42,580
para X menor a cero. Cero si X es igual a cero.

827
00:51:42,580 --> 00:51:46,360
Y es X para X mayor a cero.

828
00:51:49,190 --> 00:51:51,490
Y Lisp tiene una forma de hacer
análisis de casos.

829
00:51:51,490 --> 00:51:55,210
Déjenme definirles el valor absoluto.

830
00:51:55,210 --> 00:52:03,080
Defino el valor absoluto de X
como un condicional.

831
00:52:03,080 --> 00:52:05,075
Esto significa análisis de casos, COND.

832
00:52:08,773 --> 00:52:18,760
Si X es menor a 0, 
la respuesta es negar X.

833
00:52:22,990 --> 00:52:24,290
Lo que escribí aquí es una cláusula.

834
00:52:29,490 --> 00:52:33,818
Toda esta cosa 
es una cláusula condicional,

835
00:52:33,818 --> 00:52:36,380
y tiene dos partes.

836
00:52:36,380 --> 00:52:44,760
Esta parte es el 
predicado de la condición.

837
00:52:44,760 --> 00:52:45,640
Eso es una condición.

838
00:52:45,640 --> 00:52:47,680
Y la condición se expresa
con algo llamado

839
00:52:47,680 --> 00:52:51,170
predicato. Y un predicado en Lisp
es una cosa

840
00:52:51,170 --> 00:52:53,440
que devuelve o verdadero o falso.

841
00:52:53,440 --> 00:52:55,490
Y puede ver que Lisp tiene un
procedimiento primitivo,

842
00:52:55,490 --> 00:53:00,510
"less-than", menor que, 
que prueba si algo es verdadero o falso.

843
00:53:00,510 --> 00:53:06,940
Y la parte de la cláusula es
un acción o algo para hacer

844
00:53:06,940 --> 00:53:07,930
en el caso en el que eso
sea verdadero.

845
00:53:07,930 --> 00:53:12,130
Y aquí, lo que estoy
haciendo es negar X.

846
00:53:12,130 --> 00:53:13,300
El operador de negación, 
el símbolo menos en Lisp,

847
00:53:13,300 --> 00:53:14,550
es un poco gracioso.

848
00:53:17,880 --> 00:53:19,186
Si hay dos o más argumentos, si hay dos

849
00:53:19,186 --> 00:53:21,740
argumentos, le resta el segundo al primero, y

850
00:53:21,740 --> 00:53:22,380
ya vimos eso.

851
00:53:22,380 --> 00:53:25,280
Y si hay un único argumento, lo niega.

852
00:53:25,280 --> 00:53:27,700
Así que eso se corresponde con aquello.

853
00:53:27,700 --> 00:53:28,960
Y luego hay otra cláusula COND.

854
00:53:28,960 --> 00:53:34,630
Dice que en el caso
en que X es igual a cero,

855
00:53:34,630 --> 00:53:37,482
la respuesta es cero.

856
00:53:37,482 --> 00:53:43,480
Y en el caso donde X es mayor a cero,

857
00:53:43,480 --> 00:53:45,430
la respuesta es X.

858
00:53:45,430 --> 00:53:46,790
Cierro la cláusula.

859
00:53:46,790 --> 00:53:48,250
Cierro el COND.

860
00:53:48,250 --> 00:53:48,920
Cierro la definición.

861
00:53:48,920 --> 00:53:51,110
Y esa es la definición
de valor absoluto.

862
00:53:51,110 --> 00:53:53,560
Y verán que el análisis de casos
es muy parecido

863
00:53:53,560 --> 00:53:55,265
al análisis de casos 
que usan en matemáticas.

864
00:53:58,500 --> 00:54:02,300
Hay una manera algo diferente
de escribir un caso de

865
00:54:02,300 --> 00:54:03,090
análisis restringido.

866
00:54:03,090 --> 00:54:05,520
A menudo, uno tiene un caso de 
análisis donde hay un único

867
00:54:05,520 --> 00:54:08,810
caso, donde pruebas una condición,
y luego, dependiendo de

868
00:54:08,810 --> 00:54:11,000
si es verdadero o falso, haces algo.

869
00:54:11,000 --> 00:54:16,150
Y hay otra definición 
de valor absoluto que es

870
00:54:16,150 --> 00:54:21,010
muy parecida y que dice que
si X es menor a cero, entonces

871
00:54:21,010 --> 00:54:24,380
el resultado es el negado de x.

872
00:54:24,380 --> 00:54:25,960
En otro caso, la respuesta es X.

873
00:54:25,960 --> 00:54:27,120
Y usaremos el "IF" un montón.

874
00:54:27,120 --> 00:54:30,650
Pero de nuevo, lo que hay que
recordar es que esta form

875
00:54:30,650 --> 00:54:35,130
de valor absoluto que están mirando
aquí, y esta otra

876
00:54:35,130 --> 00:54:37,650
aquí que escribí en el pizarrón, son

877
00:54:37,650 --> 00:54:39,040
esencialmente lo mismo.

878
00:54:39,040 --> 00:54:40,700
Y "IF" y "COND" son--

879
00:54:40,700 --> 00:54:42,020
Bueno, de la manera que quieran.

880
00:54:42,020 --> 00:54:45,100
Pueden pensar en "COND"
como azúcar sintáctico para "IF", o

881
00:54:45,100 --> 00:54:47,375
pueden pensar en "IF" 
como azúcar sintáctico para "COND", y

882
00:54:47,375 --> 00:54:48,810
no marca la diferencia.

883
00:54:48,810 --> 00:54:51,400
La persona que implemente un 
sistema Lisp, elegirá una de las dos

884
00:54:51,400 --> 00:54:52,840
e implementará la otra 
en términos del elegido.

885
00:54:52,840 --> 00:54:54,570
Y no importa cuál elijas.

886
00:55:02,660 --> 00:55:05,640
¿Por qué no nos tomamos un descanso?
Y luego respondemos algunas preguntas.

887
00:55:05,640 --> 00:55:11,760
¿Cómo es que a veces cuando escribo
"define", abro un

888
00:55:11,760 --> 00:55:16,790
paréntesis aquí y digo, "define" 
abro paréntesis algo u otra cosa,

889
00:55:16,790 --> 00:55:19,480
y a veces cuando escribo esto,

890
00:55:19,480 --> 00:55:22,330
no abro paréntesis?

891
00:55:22,330 --> 00:55:27,550
La respuesta es que esta forma
particular de "define", donde uno

892
00:55:27,550 --> 00:55:30,850
dice "define" alguna expresión es 
una cosa muy especial para

893
00:55:30,850 --> 00:55:33,630
definir procedimientos.

894
00:55:33,630 --> 00:55:37,900
Pero de nuevo, lo que realmente
significa es que estoy definiendo este

895
00:55:37,900 --> 00:55:41,350
símbolo, "square", como eso.

896
00:55:41,350 --> 00:55:44,810
Así que la manera en que deberían pensar
en eso es que lo que hace "define"

897
00:55:44,810 --> 00:55:48,330
es uno escribe "define" y la segunda
cosa que escribe es e

898
00:55:48,330 --> 00:55:49,830
símbolo aquí -- sin paréntesis--

899
00:55:49,830 --> 00:55:54,610
el símbolo que uno está definiendo
y qué uno esta definiendo que sea.

900
00:55:54,610 --> 00:55:57,300
Como aquí y aquí.

901
00:55:57,300 --> 00:56:01,480
Esa es la manera básica de
usar "define". Y luego,

902
00:56:01,480 --> 00:56:05,040
hay una truco sintáctico especial
que le permite a uno

903
00:56:05,040 --> 00:56:08,140
definir un procedimiento que se ve así.

904
00:56:08,140 --> 00:56:10,690
Así que la diferencia es si uno
está o no definiendo

905
00:56:10,690 --> 00:56:11,755
un procedimiento.

906
00:56:38,110 --> 00:56:42,600
Bueno, créanlo o no, 
ya saben suficiente Lisp

907
00:56:42,600 --> 00:56:46,610
para esencialmente escribir
cualquier procedimento numérico

908
00:56:46,610 --> 00:56:49,470
que escribirían es un lenguaje como
FORTRAN o Basic o lo que sea,

909
00:56:49,470 --> 00:56:51,656
o esencialmente, cualquier
otro lenguaje.

910
00:56:51,656 --> 00:56:55,190
Y probablemente digan que 
eso no es creíble porque

911
00:56:55,190 --> 00:56:56,890
saben que esos lenguajes
tiene cosas como "for"

912
00:56:56,890 --> 00:57:00,910
o sentencias como "do until while"
o algo así.

913
00:57:00,910 --> 00:57:04,745
Pero en realidad no necesitamos
nada de eso.

914
00:57:04,745 --> 00:57:06,220
De hecho, no usaremos
nada de eso

915
00:57:06,220 --> 00:57:08,180
en este curso.

916
00:57:08,180 --> 00:57:10,410
Déjenme mostrarles.

917
00:57:10,410 --> 00:57:14,400
De nuevo, mirando a la raíz cuadrada, 
volvamos al

918
00:57:14,400 --> 00:57:18,505
algoritmo de raíz cuadrada de
Herón de Alejandría.

919
00:57:18,505 --> 00:57:20,000
Recuerden lo que decía.

920
00:57:20,000 --> 00:57:23,060
Decía, para hallar una
aproximación de la raíz

921
00:57:23,060 --> 00:57:28,730
cuadrada de X, hacer una estimación 
y mejorar esa estimación

922
00:57:28,730 --> 00:57:32,900
promediándola con X sobre la estimación.

923
00:57:32,900 --> 00:57:36,382
Se sigue mejorándola hasta que la 
estimación sea lo suficientemente buena.

924
00:57:36,382 --> 00:57:38,460
Ya aludí a la idea.

925
00:57:38,460 --> 00:57:44,650
La idea es que si 
la estimación inicial que uno hizo

926
00:57:44,650 --> 00:57:48,430
fuera igual a la raíz cuadrada de X,
entonces G aquí

927
00:57:48,430 --> 00:57:52,760
sería igual a X/G.

928
00:57:52,760 --> 00:57:54,400
Así que si uno alcanza 
la raíz cuadrada, promediarla

929
00:57:54,400 --> 00:57:55,630
no cambiaría nada.

930
00:57:55,630 --> 00:57:59,160
Si la G que uno elige es más grande
que la raíz cuadrada de

931
00:57:59,160 --> 00:58:03,280
X, entonces X/G será menor que
la raíz cuadrada de X, así que

932
00:58:03,280 --> 00:58:05,890
cuando uno promedie G y X/G, obtendrá

933
00:58:05,890 --> 00:58:09,130
algo en el medio.

934
00:58:09,130 --> 00:58:11,790
Así que si uno elige un G
que es muy pequeño,

935
00:58:11,790 --> 00:58:13,040
la respuesta será muy grande.

936
00:58:13,040 --> 00:58:17,190
Si uno elige un G que es muy grande,
si el G de uno es más grande

937
00:58:17,190 --> 00:58:19,420
que la raíz cuadrada de X y
X/G será menor que

938
00:58:19,420 --> 00:58:21,110
la raíz cuadrada de X.

939
00:58:21,110 --> 00:58:24,460
Así que promediar siempre
de algo en el medio.

940
00:58:24,460 --> 00:58:27,450
Y luego, no es trivial, 
pero es posible

941
00:58:27,450 --> 00:58:31,050
mostrar que, de hecho, si G es ligeramente 
distinto a la raíz cuadrada de X,

942
00:58:31,050 --> 00:58:34,220
el promedio de G y X/G seguirá

943
00:58:34,220 --> 00:58:37,800
acercándose a la raíz cuadrada de X.
Así que si uno sigue

944
00:58:37,800 --> 00:58:40,140
haciendo esto lo suficiente, 
eventualmente estará

945
00:58:40,140 --> 00:58:41,680
tan cerca como quiera.

946
00:58:41,680 --> 00:58:44,170
Y luego está el otro hecho de que
uno siempre puede empezar este

947
00:58:44,170 --> 00:58:49,210
proceso usando un 1 como 
estimación inicial.

948
00:58:49,210 --> 00:58:52,440
Y siempre convergerá 
a la raíz cuadrada de X. Así

949
00:58:52,440 --> 00:58:55,610
que ese es el método de promedios sucesivos

950
00:58:55,610 --> 00:58:56,660
de Herón de Alejandría.

951
00:58:56,660 --> 00:59:00,250
Escribámoslo en Lisp.

952
00:59:00,250 --> 00:59:05,770
Bueno, la idea central es:
¿qué significa hacer una

953
00:59:05,770 --> 00:59:07,940
estimación de la raíz cuadrada de X?

954
00:59:07,940 --> 00:59:09,780
Escribamos eso.

955
00:59:09,780 --> 00:59:24,310
Diremos, "define" para probar 
una estimación de la raíz cuadrada de X.

956
00:59:24,310 --> 00:59:27,750
¿Qué hacemos?

957
00:59:27,750 --> 00:59:44,130
Diremos, si la estimación es lo
suficientemente buena para

958
00:59:44,130 --> 00:59:48,330
la raíz cuadrada de X, entonces, 
como respuesta,

959
00:59:48,330 --> 00:59:51,550
tomaremos la estimación.

960
00:59:51,550 --> 00:59:58,620
En otro caso, intentaremos 
mejorar la estimación.

961
00:59:58,620 --> 01:00:05,400
Mejoraremos la estimación 
para la raíz cuadrada de X y

962
01:00:05,400 --> 01:00:09,690
la probaremos como una estimación
para la raíz cuadrada de X. Cierro

963
01:00:09,690 --> 01:00:13,510
el "TRY". Cierro el "IF". 
Cierro el "define". Así que así

964
01:00:13,510 --> 01:00:15,820
es como probamos una estimación.

965
01:00:15,820 --> 01:00:18,050
Y luego, la otra parte del proceso
dice que, para

966
01:00:18,050 --> 01:00:28,370
computar las raíces cuadradas, diremos
"define" para computar las

967
01:00:28,370 --> 01:00:35,290
raíces cuadradas de X, probaremos
1 como una estimación de la raíz

968
01:00:35,290 --> 01:00:40,280
cuadrada de X. Bueno, 
tenemos que definir un par de cosas más.

969
01:00:40,280 --> 01:00:43,770
Tenemos que decir cómo es una estimación
lo suficientemente buena.

970
01:00:43,770 --> 01:00:45,545
Y cómo mejoramos esa estimación.

971
01:00:45,545 --> 01:00:47,380
Miremos eso.

972
01:00:47,380 --> 01:00:53,650
El algoritmo para mejorar la estimación
de la raíz cuadrada de

973
01:00:53,650 --> 01:00:55,640
X, promediamos--

974
01:00:55,640 --> 01:00:57,000
ese era el algoritmo--

975
01:00:57,000 --> 01:01:00,680
promediamos la estimación con el 
cociente de

976
01:01:00,680 --> 01:01:03,030
dividir X por la estimación.

977
01:01:03,030 --> 01:01:05,810
Así es como mejoramos una estimación.

978
01:01:05,810 --> 01:01:07,720
Y para determinar si una estimación
es lo suficientemente buena, bueno,

979
01:01:07,720 --> 01:01:09,530
tenemos que dedicir algo.

980
01:01:09,530 --> 01:01:11,510
Esto se supone que es una estimación
de la raíz cuadrada de X, así

981
01:01:11,510 --> 01:01:14,700
que una posible cosa que pueden hacer
es preguntar si al tomar

982
01:01:14,700 --> 01:01:19,110
la estimación y elevarla al cuadrado
se obtiene algo muy cercano a X.

983
01:01:19,110 --> 01:01:22,870
Una forma de decir eso es decir
elevo al cuadrado la estimación,

984
01:01:22,870 --> 01:01:26,900
le resto X a eso y veo 
si el valor absoluto

985
01:01:26,900 --> 01:01:31,200
de toda esa cosa es menor que algún
número pequeño, que depende

986
01:01:31,200 --> 01:01:32,450
de mi propósito.

987
01:01:35,080 --> 01:01:40,410
Así que ese es un procedimento
completo para cómo computar

988
01:01:40,410 --> 01:01:42,830
la raíz cuadrada de X. 
Veamos la estructura de eso

989
01:01:42,830 --> 01:01:44,080
un poco.

990
01:01:47,970 --> 01:01:49,100
Tengo toda la cosa.

991
01:01:49,100 --> 01:01:55,370
Tengo la noción de cómo computar
la raíz cuadrada.

992
01:01:55,370 --> 01:01:56,960
Es una especie de módulo.

993
01:01:56,960 --> 01:01:58,580
Es una especie de caja negra.

994
01:01:58,580 --> 01:02:07,340
Está definido en términos de cómo
probar una estimación para la raíz

995
01:02:07,340 --> 01:02:09,090
cuadrada de X.

996
01:02:09,090 --> 01:02:15,110
"TRY" está definido en términos de,
bueno, poder determinar

997
01:02:15,110 --> 01:02:16,640
si algo es lo 
suficientemente bueno y decir

998
01:02:16,640 --> 01:02:18,680
cómo mejorar algo.

999
01:02:18,680 --> 01:02:19,800
Lo suficientemente bueno.

1000
01:02:19,800 --> 01:02:30,790
"TRY" está definido en términos de
"GOOD-ENOUGH" e "IMPROVE".

1001
01:02:30,790 --> 01:02:32,170
Y vemos que más puedo completar.

1002
01:02:32,170 --> 01:02:34,640
Bueno, bajaré por este árbol.

1003
01:02:34,640 --> 01:02:36,040
"GOOD-ENOUGH" 
está definido en términos del

1004
01:02:36,040 --> 01:02:37,930
valor absoluto y de "SQUARE"".

1005
01:02:40,910 --> 01:02:43,290
E "IMPROVE" está definido en términos de
algo llamado

1006
01:02:43,290 --> 01:02:47,340
promedio y 
luego otro operador primitivo.

1007
01:02:47,340 --> 01:02:49,530
La raíz cuadrada está definida en 
términos de "TRY". "TRY" está

1008
01:02:49,530 --> 01:02:53,860
definido en términos de "GOOD-ENOUGH"
e "IMPROVE",

1009
01:02:53,860 --> 01:02:55,410
pero también 
en términos del mismo "TRY".

1010
01:02:55,410 --> 01:03:02,750
Así que "TRY" está definido en términos
de "TRY" en sí mismo.

1011
01:03:02,750 --> 01:03:06,240
Bueno, eso podría darles algunos 
problemas. Su profesor de geometría

1012
01:03:06,240 --> 01:03:10,680
de secundario probablemente les dijo
que está mal definir ir y

1013
01:03:10,680 --> 01:03:13,360
definir cosas en términos
de sí mismos, porque

1014
01:03:13,360 --> 01:03:13,810
no tiene sentido.

1015
01:03:13,810 --> 01:03:16,440
Pero eso es falso.

1016
01:03:16,440 --> 01:03:18,730
A veces tiene perfecto sentido
definir cosas en

1017
01:03:18,730 --> 01:03:20,210
términos de ellas mismas.

1018
01:03:20,210 --> 01:03:22,918
Y este es el caso.

1019
01:03:22,918 --> 01:03:24,150
Y podemos mirar eso.

1020
01:03:24,150 --> 01:03:28,140
Podemos escribir lo que esto significa
y decir, supongan que

1021
01:03:28,140 --> 01:03:30,100
le pregunto a Lisp 
qué es la raíz cuadrada de 2.

1022
01:03:32,690 --> 01:03:35,710
¿Qué significa la raíz
cuadrada de 2?

1023
01:03:35,710 --> 01:03:42,700
Bueno, eso significa que pruebo con 1
como una estimación

1024
01:03:42,700 --> 01:03:43,950
para la raíz cuadrada de 2.

1025
01:03:47,100 --> 01:03:47,760
Y ahora miro.

1026
01:03:47,760 --> 01:03:50,000
Pregunto si 1 es una estimación
lo suficientemente buena

1027
01:03:50,000 --> 01:03:51,140
para la raíz cuadrada de 2.

1028
01:03:51,140 --> 01:03:54,140
Y eso depende de la prueba
que hace "GOOD-ENOUGH".

1029
01:03:54,140 --> 01:03:57,240
Y en este caso, "GOOD-ENOUGH" dice
que no, que 1 no es

1030
01:03:57,240 --> 01:03:59,740
una estimación lo suficientemente buena
de la raíz cuadrada de 2.

1031
01:03:59,740 --> 01:04:10,350
Y eso se reduce en decir,
tengo que probar una mejora--

1032
01:04:10,350 --> 01:04:15,910
mejorar 1 como estimación para la
raíz cuadrada de 2, y probar eso

1033
01:04:15,910 --> 01:04:19,110
como una estimación de la
raíz cuadrada de 2.

1034
01:04:19,110 --> 01:04:22,350
Mejorar 1 como una estimación
de la raíz cuadrada de 2 significa que

1035
01:04:22,350 --> 01:04:27,270
promedio 1 y 2 dividido 1.

1036
01:04:27,270 --> 01:04:29,550
Así que está será un promedio.

1037
01:04:29,550 --> 01:04:37,830
Esta cosa de aquí será el promedio
de 1 y del

1038
01:04:37,830 --> 01:04:40,930
cociente entre 2 y 1.

1039
01:04:40,930 --> 01:04:44,910
Es esta pieza de aquí.

1040
01:04:44,910 --> 01:04:46,160
Y eso es 1.5.

1041
01:04:49,060 --> 01:04:53,670
Así que la raíz cuadrada de 2 
se reduce a probar 1 para

1042
01:04:53,670 --> 01:05:03,370
la raíz cuadrada 2, que se reduce
a probar 1.5 como la

1043
01:05:03,370 --> 01:05:06,220
estimación para la raíz cuadrada de 2.

1044
01:05:06,220 --> 01:05:07,880
Así que eso tiene sentido.

1045
01:05:07,880 --> 01:05:09,650
Miremos el resto del proceso.

1046
01:05:09,650 --> 01:05:14,890
Si probarmos 1.5, eso reduce.

1047
01:05:14,890 --> 01:05:18,210
1.5 resulta que no es una estimación
lo suficientemente buena para

1048
01:05:18,210 --> 01:05:20,130
la raíz cuadrada de 2.

1049
01:05:20,130 --> 01:05:23,340
Y eso reduce en probar el promedio
de 1.5 y 2 dividido por

1050
01:05:23,340 --> 01:05:28,200
1.5 como estimación para
la raíz cuadrada de 2.

1051
01:05:28,200 --> 01:05:31,110
Y ese promedio resulta ser 1.333.

1052
01:05:31,110 --> 01:05:34,215
Así que toda esta cosa reduce
en probar 1.333 como una estimación

1053
01:05:34,215 --> 01:05:35,130
de la raíz cuadrada de 2.

1054
01:05:35,130 --> 01:05:37,910
Y luego seguimos así.

1055
01:05:37,910 --> 01:05:40,750
Eso reduce a otro llamado
a "GOOD-ENOUGH", 1.4

1056
01:05:40,750 --> 01:05:41,630
algo u otro.

1057
01:05:41,630 --> 01:05:45,160
Y sigo así hasta que el proceso
finalmente se detiene con

1058
01:05:45,160 --> 01:05:47,780
algo que es lo suficientemente bueno, 
cree que es lo suficientemente bueno, que

1059
01:05:47,780 --> 01:05:52,500
en este caso, es 1.4142, algo u otro.

1060
01:05:52,500 --> 01:05:55,890
Así que el proceso 
tiene perfecto sentido.

1061
01:05:59,710 --> 01:06:02,620
Esto se llama, por cierto, 
una definición recursiva.

1062
01:06:14,410 --> 01:06:19,470
Y la habilidad de poder hacer
definiciones recursivas es

1063
01:06:19,470 --> 01:06:20,710
una fuente de increíble poder.

1064
01:06:20,710 --> 01:06:24,040
Y como pueden ver que di la pista,
es la cosa

1065
01:06:24,040 --> 01:06:27,160
que efectivamente nos permite
hacer estos cómputos infinitos

1066
01:06:27,160 --> 01:06:30,730
que continúan hasta que algo 
se hace verdadero, sin tener otra

1067
01:06:30,730 --> 01:06:33,235
restricción más que la posibilidad
de llamar a un procedimiento.

1068
01:06:35,890 --> 01:06:37,970
Bueno, veamos, hay una cosa más.

1069
01:06:37,970 --> 01:06:43,210
Déjenme mostrarles una variante
de la definición de raíz cuadrada

1070
01:06:43,210 --> 01:06:46,300
aquí en la diapositiva.

1071
01:06:46,300 --> 01:06:48,320
Es casi la misma cosa.

1072
01:06:48,320 --> 01:06:51,430
Lo que hemos hecho es
empaquetar las definiciones de

1073
01:06:51,430 --> 01:06:55,340
"IMPROVE", "GOOD-ENOUGH" y "TRY"
dentro de "SQUARE-

1074
01:06:55,340 --> 01:06:59,760
ROOT". Así que, de hecho, lo que hice fue
construir una

1075
01:06:59,760 --> 01:07:01,860
caja de raíz cuadrada.

1076
01:07:01,860 --> 01:07:07,320
Así que construí una caja
que el procedimiento de raíz cuadrada

1077
01:07:07,320 --> 01:07:08,150
que alguien puede usar.

1078
01:07:08,150 --> 01:07:11,910
Podrían poner 36 y saldría un 6.

1079
01:07:11,910 --> 01:07:15,080
Y luego, empaquetados dentro de esta caja, 
están las definiciones de

1080
01:07:15,080 --> 01:07:26,530
"TRY", "GOOD-ENOUGH" e "IMPROVE",

1081
01:07:26,530 --> 01:07:28,260
Están escondidas dentro
de la caja.

1082
01:07:28,260 --> 01:07:32,010
Y la razón para hacer eso
es que si, si alguien está usando

1083
01:07:32,010 --> 01:07:34,920
la raíz cuadrada, si George está
usando la raíz cuadrada, a George

1084
01:07:34,920 --> 01:07:39,180
probablemente no le interese que
cuando implementé

1085
01:07:39,180 --> 01:07:42,600
la raíz cuadrada, tenía cosa dentro
llamadas "TRY" y

1086
01:07:42,600 --> 01:07:48,150
"GOOD-ENOUGH" e "IMPROVE". 
Y, de hecho, Harry podría tener

1087
01:07:48,150 --> 01:07:50,300
un procedimiento de raíz cúbica
que tiene "TRY" y "GOOD-ENOUGH" e

1088
01:07:50,300 --> 01:07:53,260
"IMPROVE". Y para no confundir
a todo el sistema,

1089
01:07:53,260 --> 01:07:55,430
sería bueno que Harry 
empaquetara los procedimientos

1090
01:07:55,430 --> 01:07:58,320
internos dentro de su procedimiento
de raíz cúbica.

1091
01:07:58,320 --> 01:08:00,970
Bueno, esto se llama estructura 
de bloque, esta forma particular

1092
01:08:00,970 --> 01:08:09,940
de empaquetar las entrañas dentro
de la definición.

1093
01:08:09,940 --> 01:08:13,040
Volvamos y miremos la diapositiva
de nuevo.

1094
01:08:13,040 --> 01:08:17,720
La manera de leer esta especie
de procedimiento es decir, para definir

1095
01:08:17,720 --> 01:08:23,010
la raíz cuadrada, bueno, dentro 
de la definición tengo la

1096
01:08:23,010 --> 01:08:26,479
definición de "IMPROVE" y la 
definción de "GOOD-

1097
01:08:26,479 --> 01:08:31,149
ENOUGH" y la definición de "TRY".
Y luego, sujeto a

1098
01:08:31,149 --> 01:08:36,010
esas definiciones, la manera de hacer
la raíz cuadrada es probar con 1.

1099
01:08:36,010 --> 01:08:38,310
Y noten que aquí no tengo que decir que
1 es una estimación para la

1100
01:08:38,310 --> 01:08:41,290
raíz cuadrada de X, porque como
todo está dentro de

1101
01:08:41,290 --> 01:08:44,270
raíz cuadrada, casi que tiene
este X conocido.

1102
01:08:54,770 --> 01:08:56,510
Déjenme resumir.

1103
01:08:56,510 --> 01:08:59,890
Empezamos con la idea 
de que lo vamos a estar

1104
01:08:59,890 --> 01:09:04,960
haciendo es expresar
conocimiento imperativo.

1105
01:09:04,960 --> 01:09:08,960
Y de hecho, aquí hay una diapositiva
que resume la manera en que

1106
01:09:08,960 --> 01:09:09,680
miramos en Lisp.

1107
01:09:09,680 --> 01:09:13,609
Empezamos mirando algunos
elementos primitivos en

1108
01:09:13,609 --> 01:09:17,609
la adición y la multiplicación,
algunos predicados para probar

1109
01:09:17,609 --> 01:09:19,630
si algo es menor o igual que otra cosa.

1110
01:09:19,630 --> 01:09:22,330
Y de hecho, vimos que en el sistema que

1111
01:09:22,330 --> 01:09:25,160
estamos usando, estas ni siquiera son
en efecto primitivas, pero

1112
01:09:25,160 --> 01:09:26,550
que no importa.

1113
01:09:26,550 --> 01:09:28,120
Lo que importa es que vamos 
a usarlas como si fueran

1114
01:09:28,120 --> 01:09:28,510
primitivas.

1115
01:09:28,510 --> 01:09:30,220
No vamos a mirar adentro.

1116
01:09:30,220 --> 01:09:34,540
También tenemos algunos datos
primitivos y algunos números.

1117
01:09:34,540 --> 01:09:36,830
Vimos algunos medios de 
composición, medios de

1118
01:09:36,830 --> 01:09:41,300
combianción, siendo el básico
la composición de funciones y

1119
01:09:41,300 --> 01:09:44,840
la construcción de combinaciones
con operadores y operandos.

1120
01:09:44,840 --> 01:09:47,600
Y luego hay otras cosas, 
como "COND" e "IF" y

1121
01:09:47,600 --> 01:09:53,790
"DEFINE". Pero lo principal de 
"DEFINE" en particular,

1122
01:09:53,790 --> 01:09:55,710
era que un medio de abstracción.

1123
01:09:55,710 --> 01:09:57,670
Era la forma en la que nombramos cosas.

1124
01:09:57,670 --> 01:09:59,770
También pueden ver de esta
diapositiva que no sólo dónde

1125
01:09:59,770 --> 01:10:01,450
hemos estado, sino los agujeros 
que tenemos que llenar.

1126
01:10:01,450 --> 01:10:03,930
En algún punto, tenemos que
hablar acerca de cómo combinar

1127
01:10:03,930 --> 01:10:07,720
datos primitivos para obtener 
datos compuestos y cómo abstraer

1128
01:10:07,720 --> 01:10:11,950
datos para poder usar grandes
pedazos de datos como

1129
01:10:11,950 --> 01:10:13,900
si fueran primitivos.

1130
01:10:13,900 --> 01:10:16,370
Así que ahí es hacia donde vamos.

1131
01:10:16,370 --> 01:10:20,790
Pero antes de hacer eso, por 
el próximo par de clases, vamos

1132
01:10:20,790 --> 01:10:25,720
a estar hablando, en primer lugar, 
cómo es que uno

1133
01:10:25,720 --> 01:10:28,900
enlaza estos procedimiento 
que escribimos y los procesos

1134
01:10:28,900 --> 01:10:32,040
que ocurren dentro de la máquina.

1135
01:10:32,040 --> 01:10:36,210
Y luego, cómo es que uno puede
empezar a usa el poder de Lisp

1136
01:10:36,210 --> 01:10:38,710
para hablar no sólo acerca 
estos pequeños cómputos

1137
01:10:38,710 --> 01:10:43,080
individuales, sino también acerca
de métodos de convención general

1138
01:10:43,080 --> 01:10:45,200
para hacer cosas.

1139
01:10:45,200 --> 01:10:46,730
OK. ¿Hay alguna pregunta?

1140
01:10:46,730 --> 01:10:47,640
AUDIENCIA: Sí.

1141
01:10:47,640 --> 01:10:51,880
Si definimos A usando paréntesis
en vez de como lo

1142
01:10:51,880 --> 01:10:53,400
hicimos, ¿cuál sería la diferencia?

1143
01:10:53,400 --> 01:10:58,130
PROFESOR: Si escribo esto,
si escribo aquello, lo que estaría

1144
01:10:58,130 --> 01:11:03,740
haciendo es definir un procedimiento
llamado A. En este caso, un

1145
01:11:03,740 --> 01:11:07,950
procedimiento sin argumentos, 
que, cuando lo corra, me

1146
01:11:07,950 --> 01:11:10,274
devolverá 5 multiplicado por 5.

1147
01:11:10,274 --> 01:11:10,716
AUDIENCIA: Bien.

1148
01:11:10,716 --> 01:11:12,610
Quiero decir, obtienes el mismo
resultado, excepto que para uno

1149
01:11:12,610 --> 01:11:13,940
realmente tiene diferentes--

1150
01:11:13,940 --> 01:11:14,120
PROFESOR: Correcto.

1151
01:11:14,120 --> 01:11:16,330
Y la diferencia sería, en el viejo --

1152
01:11:16,330 --> 01:11:19,180
Déjenme ser un poco más claro aquí.

1153
01:11:19,180 --> 01:11:24,070
Llamemos a esto A, como aquí.

1154
01:11:24,070 --> 01:11:35,060
Y pretendan que aquí, solo para 
contrastar, defino D como

1155
01:11:35,060 --> 01:11:37,300
el producto de 5 y 5.

1156
01:11:40,200 --> 01:11:42,450
Y la diferencia entre ambos,
pensemos acerca de

1157
01:11:42,450 --> 01:11:45,770
interacciones con el 
intérprete de Lisp.

1158
01:11:45,770 --> 01:11:52,860
Podría tipear A y Lisp devolvería 25.

1159
01:11:52,860 --> 01:12:01,240
Podría tipear D, y si solo tipeo D,
Lisp retornaría un

1160
01:12:01,240 --> 01:12:08,000
procedimiento compuesto D, 
porque eso es lo que es.

1161
01:12:08,000 --> 01:12:09,670
Es un procedimiento.

1162
01:12:09,670 --> 01:12:12,500
Podría correr D. Podría decir,
¿cuál es el valor de correr D?

1163
01:12:12,500 --> 01:12:16,520
Esta es una combinación sin operandos.

1164
01:12:16,520 --> 01:12:17,570
Veo que no hay operandos.

1165
01:12:17,570 --> 01:12:22,940
No puse ninguno después de D.

1166
01:12:22,940 --> 01:12:28,070
O podría decir, sólo por completitud,
si tipeara,

1167
01:12:28,070 --> 01:12:29,310
¿cuál es el valor de correr A?

1168
01:12:29,310 --> 01:12:31,690
Y obtendría un error.

1169
01:12:31,690 --> 01:12:35,150
El error sería el mismo que allí.

1170
01:12:35,150 --> 01:12:40,010
El error diría, lo siento, 25, 
que es el valor de

1171
01:12:40,010 --> 01:12:43,720
A, no es un operador 
que pueda aplicar a algo.
