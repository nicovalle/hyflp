1
00:00:16,830 --> 00:00:22,479
Bueno, hasta ahora hemos
inventado suficiente programación

2
00:00:22,480 --> 00:00:24,850
para hacer algunas cosas
muy complicadas.

3
00:00:24,850 --> 00:00:28,710
Y ciertamente aprendieron
un montón

4
00:00:28,710 --> 00:00:29,760
de programación a esta altura.

5
00:00:29,760 --> 00:00:32,189
Aprendieron casi todos los
trucos más importantes

6
00:00:32,189 --> 00:00:34,870
que usualmente nos se les enseña
a la gente hasta que tengan

7
00:00:34,870 --> 00:00:36,610
mucha experiencia.

8
00:00:36,610 --> 00:00:40,800
Por ejemplo, programación
orientada a datos es un gran truco,

9
00:00:40,800 --> 00:00:42,754
y ayer también vieron un 
lenguaje interpretado.

10
00:00:45,300 --> 00:00:50,319
Y lo hicimos todo en un lenguaje
de computadora dónde

11
00:00:50,320 --> 00:00:54,200
no hay una sentencia de asignación.

12
00:00:54,200 --> 00:00:56,790
Y presumiblemente, para aquellos
de ustedes que hayan visto Basic

13
00:00:56,790 --> 00:01:00,170
o Pascal o lo que sea, eso es
usualmente considerado

14
00:01:00,170 --> 00:01:02,400
lo más importante.

15
00:01:02,400 --> 00:01:03,580
Bueno, hoy vamos a hacer algo horrible.

16
00:01:03,580 --> 00:01:07,370
Vamos a añadir una sentencia
de asignación.

17
00:01:07,370 --> 00:01:09,220
Y ya que podemos hacer todas
estas cosas maravillas sin ella,

18
00:01:09,220 --> 00:01:11,110
¿por qué deberíamos añadirla?

19
00:01:11,110 --> 00:01:13,400
Algo importante de entender es que hoy

20
00:01:13,400 --> 00:01:17,270
vamos a, en primer lugar, 
tener una regla, que siempre

21
00:01:17,270 --> 00:01:19,520
será obedecida, que es que la única
razón por la cual agregar una funcionalidad

22
00:01:19,520 --> 00:01:23,636
nueva al lenguaje es porque hay
una buena razón.

23
00:01:23,636 --> 00:01:27,470
Y la razón será reducida a la habilidad,

24
00:01:27,470 --> 00:01:30,500
ahora obtienes la habilidad de partir
el problema en pedazos

25
00:01:30,500 --> 00:01:32,100
que son diferentes conjuntos
de piezas en las que

26
00:01:32,100 --> 00:01:35,380
no podrías haberlo partido sin eso.
Te da otro medio

27
00:01:35,380 --> 00:01:36,630
de descomposición.

28
00:01:38,350 --> 00:01:39,490
Empecemos.

29
00:01:39,490 --> 00:01:43,270
Déjenme empezar repasando
el tipo de lenguaje que

30
00:01:43,270 --> 00:01:48,240
tenemos ahora.

31
00:01:48,240 --> 00:01:51,309
Estuvimos escribiendo lo que 
se llaman programas funcionales.

32
00:01:51,310 --> 00:01:56,770
Y los programas funcionales, son somo
codificar

33
00:01:56,770 --> 00:01:58,890
verdades matemáticas.

34
00:01:58,890 --> 00:02:02,420
Por ejemplo, cuando miramos
el procedimiento factorial que

35
00:02:02,420 --> 00:02:07,900
ven en la diapositiva aquí,
es básicamente dos cláusulas.

36
00:02:07,900 --> 00:02:09,530
Si n es uno, el resultado es uno,
caso contrario n por

37
00:02:09,530 --> 00:02:11,230
el factorial de n menos 1.

38
00:02:11,230 --> 00:02:12,989
Ese es el factorial de n.

39
00:02:12,990 --> 00:02:14,960
Ese es el factorial de n.

40
00:02:14,960 --> 00:02:17,120
Y escrito en alguna notación rara

41
00:02:17,120 --> 00:02:22,310
que quizá hayan aprendido en las 
clases de cálculo, lógica matemática,

42
00:02:22,310 --> 00:02:28,900
lo que ven es que si n es igual a uno, 
el resultado de

43
00:02:28,900 --> 00:02:31,600
factorial d en es uno. Caso contrario, 
si es mayor a uno, el factorial de n

44
00:02:31,600 --> 00:02:32,680
es n por el factorial de n menos uno.

45
00:02:32,680 --> 00:02:35,560
Sentencias verdaderas, ese el tipo

46
00:02:35,560 --> 00:02:37,000
de lenguaje que hemos estado usando.

47
00:02:37,000 --> 00:02:39,610
Y cuando tenemos sentencias
verdaderas de ese estilo, hay

48
00:02:39,610 --> 00:02:47,490
una manera de entender cómo funcionan

49
00:02:47,490 --> 00:02:50,170
que es que tales procesos
pueden evolucionar mediante

50
00:02:50,170 --> 00:02:51,390
sustitución.\

51
00:02:51,390 --> 00:02:56,230
Y vemos en la segunda diapositiva,
que la manera en que

52
00:02:56,230 --> 00:03:02,100
entendemos la ejecución implicada
por esas sentencias,

53
00:03:02,100 --> 00:03:05,640
ordenadas en ese orden, es que haces
sucesivas

54
00:03:05,640 --> 00:03:09,369
sustituciones de argumentos por
parámetros formales en el cuerpo

55
00:03:09,370 --> 00:03:12,430
del procedimiento.

56
00:03:12,430 --> 00:03:14,710
Esto es básicamente una secuencia
de igualdades.

57
00:03:14,710 --> 00:03:17,390
Factorial de cuatro es cuatro veces
el factorial de tres.

58
00:03:17,390 --> 00:03:21,290
Y eso es cuatro veces tres veces el
factorial de dos, y así.

59
00:03:21,290 --> 00:03:23,325
Siempre preservamos la verdad.

60
00:03:26,580 --> 00:03:29,190
Aunque estemos hablando de sentencias
verdaderas,

61
00:03:29,190 --> 00:03:31,390
podría haber más de una manera
de organizar estas

62
00:03:31,390 --> 00:03:34,630
sentencias para describir la
computación de una función

63
00:03:34,630 --> 00:03:37,490
particular, la computación
del valor de una

64
00:03:37,490 --> 00:03:38,640
función particular.

65
00:03:38,640 --> 00:03:42,459
Por ejemplo, miren la siguiente aquí.

66
00:03:42,460 --> 00:03:49,780
Esta es una manera de mirar
la suma de n y m.

67
00:03:49,780 --> 00:03:52,930
Y lo hicimos mediante 
un procedimiento recursivo.

68
00:03:52,930 --> 00:04:00,130
Es el incremento de la suma del
decremento de n y m.

69
00:04:00,130 --> 00:04:03,780
Y, por supuesto, hay una pieza
de lógica matemática

70
00:04:03,780 --> 00:04:06,240
que describe eso.

71
00:04:06,240 --> 00:04:11,450
Es el incremento de la suma
del decremento de n y m,

72
00:04:11,450 --> 00:04:13,119
justo así.

73
00:04:13,120 --> 00:04:16,440
Así que no haya nada particularmente
mágico sobre eso.

74
00:04:16,440 --> 00:04:19,589
Y, por supuesto, si también
podemos ver un proceso iterativo

75
00:04:19,589 --> 00:04:22,920
para eso, un programa que involucra
un proceso iterativo

76
00:04:22,920 --> 00:04:25,310
para la misma función,

77
00:04:25,310 --> 00:04:29,930
estas son dos cosas que computan
la misma respuesta.

78
00:04:29,930 --> 00:04:34,220
Y tenemos verdades matemáticas
equivalente que están

79
00:04:34,220 --> 00:04:36,720
ordenadas ahí.

80
00:04:36,720 --> 00:04:38,920
Y la manera en que las ordenas
determina el

81
00:04:38,920 --> 00:04:40,430
proceso particular.

82
00:04:40,430 --> 00:04:42,810
La manera de elegir y 
ordenarlas determina

83
00:04:42,810 --> 00:04:44,400
la evolución del proceso.

84
00:04:44,400 --> 00:04:47,370
Así que tenemos la flexibilidad
para hablar sobre

85
00:04:47,370 --> 00:04:49,260
la función a computar y el método

86
00:04:49,260 --> 00:04:50,409
por el cual se computa.

87
00:04:50,410 --> 00:04:53,580
No está claro si necesitamos más.

88
00:04:53,580 --> 00:04:55,440
Sin embargo, hoy voy a hacer
algo horrible.

89
00:04:55,440 --> 00:04:59,700
Voy a introducir una operación
de asignación.

90
00:04:59,700 --> 00:05:02,890
Ahora bien, ¿qué es esto?

91
00:05:02,890 --> 00:05:07,830
Bueno, en primer lugar, habrá una
nueva clase

92
00:05:07,830 --> 00:05:09,960
de sentencia, por así decirlo,
en un lenguaje

93
00:05:09,960 --> 00:05:11,210
de programación, llamada Set.

94
00:05:13,800 --> 00:05:16,550
A las cosas que hacer cosas como
asignaciones, les voy a poner

95
00:05:16,550 --> 00:05:18,570
un signo de exclamación.

96
00:05:18,570 --> 00:05:20,990
Vamos a hablar de su 
significado en un segundo.

97
00:05:20,990 --> 00:05:23,370
El signo de exclamación, como 
el signo de interrogación, es una

98
00:05:23,370 --> 00:05:25,960
cosa arbitraria que adherimos
al símbolo que es el nombre

99
00:05:25,960 --> 00:05:28,900
pero que no tiene significancia
para el sistema.

100
00:05:28,900 --> 00:05:31,520
Es significante para mí y para
ustedes para alertarlos que es

101
00:05:31,520 --> 00:05:35,909
una asignación de algún tipo.

102
00:05:35,910 --> 00:05:39,960
Vamos a asignar a una variable un valor.

103
00:05:43,800 --> 00:05:47,120
Y eso va a significar que hay un
momento

104
00:05:47,120 --> 00:05:48,600
el que algo pasa.

105
00:05:48,600 --> 00:05:50,100
Aquí hay un tiempo.

106
00:05:50,100 --> 00:05:55,300
Si tengo el tiempo corriendo
en este sentido, un eje de tiempo.

107
00:05:55,300 --> 00:05:58,650
El tiempo progresa bajando por la página.

108
00:05:58,650 --> 00:06:01,250
Entonces una asignación es la
primer cosa que tenemos que

109
00:06:01,250 --> 00:06:06,670
produce una diferencia entre el antes
y el después.

110
00:06:06,670 --> 00:06:09,660
En todos los otros programas que escribimos, 
que no tenían

111
00:06:09,660 --> 00:06:12,400
asignación en ellos, el orden en el que se
evaluaban

112
00:06:12,400 --> 00:06:14,590
no importaba.

113
00:06:14,590 --> 00:06:17,989
Pero la asignación es especial, 
produce un momento en el tiempo.

114
00:06:17,990 --> 00:06:27,980
Hay un momento antes del Set y otro después,

115
00:06:27,980 --> 00:06:39,500
tal que después de este momento, 
la variable tiene

116
00:06:39,500 --> 00:06:43,320
un valor.

117
00:06:49,310 --> 00:06:53,340
Independientemente del valor
que tenía antes, Set!

118
00:06:53,340 --> 00:06:57,659
cambia el valor de la variable.

119
00:06:57,660 --> 00:07:03,150
Hasta este momento, no teníamos
nada que cambiara.

120
00:07:03,150 --> 00:07:06,909
Así que, por ejemplo, una de la cosas
en las que podemos pensar es que

121
00:07:06,910 --> 00:07:09,890
los procedimiento que escribimos
para algo como factorial son

122
00:07:09,890 --> 00:07:13,740
de hecho bastante idénticos
a la función factorial.

123
00:07:13,740 --> 00:07:18,120
Factorial de cuatro, si escribo
'fact' 4, independientemente

124
00:07:18,120 --> 00:07:20,920
del contexto en el que está, e
independientemente de cuántas

125
00:07:20,920 --> 00:07:23,400
veces lo escriba, siempre voy 
a obtener la misma respuesta.

126
00:07:23,400 --> 00:07:25,430
Siempre es 24.

127
00:07:25,430 --> 00:07:30,360
Es un mapeo único del
argumento a la respuesta.

128
00:07:30,360 --> 00:07:33,580
Y todos los programas que escribimos
hasta ahora son así.

129
00:07:33,580 --> 00:07:37,200
Sin embargo, una vez que tengo asignación,
eso no es cierto.

130
00:07:37,200 --> 00:07:50,700
Por ejemplo defino a count como uno.

131
00:07:50,700 --> 00:07:55,550
Y luego voy a definir un procedimiento
simple

132
00:07:55,550 --> 00:08:02,960
llamado demo, que toma un argumento
x y hace

133
00:08:02,960 --> 00:08:03,870
las siguientes operaciones:

134
00:08:03,870 --> 00:08:09,650
Primero asigna x a x más uno.

135
00:08:09,650 --> 00:08:13,159
Dios mío, estoy parece Fortran,
¿verdad?

136
00:08:13,160 --> 00:08:14,410
con una sintaxis rara.

137
00:08:16,910 --> 00:08:24,330
Y luego le sumo count a x.
Cometí un error.

138
00:08:24,330 --> 00:08:27,100
Quería decir, Set! count
a 1 más count.

139
00:08:30,310 --> 00:08:31,730
Esta cosa definida aquí.

140
00:08:34,350 --> 00:08:36,369
Y luego más x y count.

141
00:08:40,409 --> 00:08:42,558
Entonces, puedo probar
este procedimiento.

142
00:08:42,558 --> 00:08:43,880
Corrámoslo.

143
00:08:43,880 --> 00:08:48,125
Supongan que tengo un cursor y
que le digo demo tres.

144
00:08:52,210 --> 00:08:53,540
Bueno, ¿qué pasa aquí?

145
00:08:53,540 --> 00:08:57,200
Lo primero que pasa es que
count es actualmente uno.

146
00:08:57,200 --> 00:08:59,130
Hay un tiempo.

147
00:08:59,130 --> 00:09:00,710
Estamos hablando del tiempo.

148
00:09:00,710 --> 00:09:02,960
x vale tres.

149
00:09:02,960 --> 00:09:06,900
En este momento, se incrementa
count

150
00:09:06,900 --> 00:09:08,690
así que count es dos.

151
00:09:08,690 --> 00:09:10,710
Dos más tres es cinco.

152
00:09:10,710 --> 00:09:14,460
Así que obtengo cinco como respuesta.

153
00:09:14,460 --> 00:09:23,640
Luego pido demo de tres de nuevo.

154
00:09:23,640 --> 00:09:24,830
¿Qué obtengo?

155
00:09:24,830 --> 00:09:29,310
Bueno, ahora count es dos, 
no es más uno, porque

156
00:09:29,310 --> 00:09:30,760
lo incrementé.

157
00:09:30,760 --> 00:09:35,500
Pero ahora paso por este proceso,
tres va a x,

158
00:09:35,500 --> 00:09:38,160
count se convierte en count más uno,
así que ahora es tres.

159
00:09:38,160 --> 00:09:42,130
La suma de esos dos es seis,
así que la respuesta es seis.

160
00:09:42,130 --> 00:09:45,760
Y vemos que la misma expresión
nos lleva a

161
00:09:45,760 --> 00:09:52,170
respuestas diferentes, dependiendo
del tiempo.

162
00:09:52,170 --> 00:09:55,400
Asi que demo no es una función, 
no computa una

163
00:09:55,400 --> 00:09:56,290
función matemática.

164
00:10:00,200 --> 00:10:03,180
De hecho, también pueden ver que
ahora, por supuesto, este es

165
00:10:03,180 --> 00:10:05,650
el primer lugar donde el modelo
de sustitución

166
00:10:05,650 --> 00:10:07,780
no va a funcionar.

167
00:10:07,780 --> 00:10:11,410
Esto mata al modelo de sustitución.

168
00:10:11,410 --> 00:10:14,600
Con las comillas había algunos
problemitas que un

169
00:10:14,600 --> 00:10:17,380
filósofo podría notar con las
sustituciones,

170
00:10:17,380 --> 00:10:19,560
porque tienes que preocuparte
sobre qué deducciones puedes

171
00:10:19,560 --> 00:10:23,690
hacer cuando sustituyes con comillas,
si es que puedes

172
00:10:23,700 --> 00:10:25,150
hacerlo en absoluto.

173
00:10:25,150 --> 00:10:28,590
Pero aquí, el modelo de sustitución
está muerte, no puedes

174
00:10:28,590 --> 00:10:29,810
hacer nada.

175
00:10:29,810 --> 00:10:34,489
Porque, suponiendo que quisiera usar
un modelo de sustitución para

176
00:10:34,490 --> 00:10:37,560
considerar sustituir a count.

177
00:10:37,560 --> 00:10:42,150
Bueno, dios mío, si sustituyo
aquí y aquí, son cosas

178
00:10:42,150 --> 00:10:44,540
diferentes.

179
00:10:44,540 --> 00:10:46,569
No es el mismo count.

180
00:10:46,570 --> 00:10:47,880
Obtengo la respuesta incorrecta.

181
00:10:47,880 --> 00:10:51,410
El modelo de sustitución es un
fenómeno estático que

182
00:10:51,410 --> 00:10:55,560
describe cosas que son verdad
y cosas que no cambian.

183
00:10:55,560 --> 00:10:56,810
Aquí, tenemos verdades que cambian.

184
00:11:01,860 --> 00:11:06,770
Bueno, antes de que les haga
entender esto,

185
00:11:06,770 --> 00:11:07,870
esto es muy malo.

186
00:11:07,870 --> 00:11:11,520
Perdimos nuestro modelo de computación.

187
00:11:11,520 --> 00:11:13,420
Dentro de poco, vamos a tener
que construir un nuevo modelo

188
00:11:13,420 --> 00:11:15,300
de computación.

189
00:11:15,300 --> 00:11:18,709
Pero juguemos con este,
de una manera informal.

190
00:11:18,710 --> 00:11:21,490
Por supuesto, lo que ya pueden ver
es que cuando tengo algo

191
00:11:21,490 --> 00:11:24,600
como la asignación, el modelo
que vamos a necesitar

192
00:11:24,600 --> 00:11:27,760
es diferente del modelo que
teníamos antes dado que

193
00:11:27,760 --> 00:11:31,840
las variables, esos símbolos
como count o x, ya no referencian

194
00:11:31,840 --> 00:11:35,100
a los valores que tienen, sino a algún

195
00:11:35,100 --> 00:11:37,810
lugar donde los valores están guardados.

196
00:11:37,810 --> 00:11:40,329
Vamos a tener que pensar así 
por un tiempo.

197
00:11:40,330 --> 00:11:42,290
Y va a ser algo muy malo y va

198
00:11:42,290 --> 00:11:44,589
a causar un montón de problemas.

199
00:11:44,590 --> 00:11:47,350
Y como dije, el hecho de que estemos
inventando algo tan malo,

200
00:11:47,350 --> 00:11:49,750
significa que tiene una haber una buena
razón para hacerlo,

201
00:11:49,750 --> 00:11:52,400
sino, en caso contrario, estaría
perdiendo el tiempo

202
00:11:52,400 --> 00:11:53,510
y un montón de esfuerzo.

203
00:11:53,510 --> 00:11:56,900
Miremos un poco sólo para jugar.

204
00:11:56,900 --> 00:11:59,130
Supongamos que escribo una versión
funcional, funcional

205
00:11:59,130 --> 00:12:02,770
en el viejo sentido, de factorial

206
00:12:02,770 --> 00:12:04,430
como un proceso iterativo.

207
00:12:09,780 --> 00:12:26,810
Factorial de n, vamos a iterar m e i.
Y dice que

208
00:12:26,810 --> 00:12:40,300
si i es mayor a n, entonces el 
resultado es m. Caso contrario,

209
00:12:40,300 --> 00:12:46,930
el resultado de iterar el producto
de i y m.

210
00:12:46,930 --> 00:12:51,689
m va a ser el producto
que estoy acumulando.

211
00:12:51,690 --> 00:12:52,940
m es el producto.

212
00:12:58,170 --> 00:12:59,990
Y el i lo voy a incrementar en uno.

213
00:13:04,810 --> 00:13:12,600
Más, ITER, ELSE, COND, DEFINE.

214
00:13:12,600 --> 00:13:13,310
Voy a iniciar esto.

215
00:13:17,000 --> 00:13:18,980
Y ya no deberían tener 
problemas al leer

216
00:13:18,980 --> 00:13:21,200
algo como esto.

217
00:13:21,200 --> 00:13:23,750
Lo que tengo aquí un
producto siendo

218
00:13:23,750 --> 00:13:26,750
acumulado y un contador.

219
00:13:26,750 --> 00:13:29,500
Los inicio ambos en uno.

220
00:13:29,500 --> 00:13:32,380
Voy a aumentar el contador,
i va a i más uno cada

221
00:13:32,380 --> 00:13:34,800
iteración.

222
00:13:34,800 --> 00:13:38,910
Pero esto es solo nosostros
poniéndoles tiempo al proceso,

223
00:13:38,910 --> 00:13:42,839
cada uno de estos es solamente un
conjunto de verdades, reglas verdaderas.

224
00:13:42,840 --> 00:13:47,100
Y m va a tener un nuevo valor
a partir de i y de m, i multiplicado por m

225
00:13:47,100 --> 00:13:49,860
cada vez que itera, y eventualmente
i va a ser

226
00:13:49,860 --> 00:13:52,750
mayor a n, en cuyo caso, 
la respuesta va a ser m.

227
00:13:52,750 --> 00:13:55,760
Ahora les estoy hablando usando el tiempo
en esto.

228
00:13:55,760 --> 00:13:58,210
Pero es solo porque sé cómo
funciona la computadora.

229
00:13:58,210 --> 00:13:59,900
Pero podría no haberlo hecho.

230
00:13:59,900 --> 00:14:01,810
Esto podría ser una descripción
puramente matemática a esta

231
00:14:01,810 --> 00:14:03,400
altura, porque la sustitución

232
00:14:03,400 --> 00:14:05,280
resolverá esto.

233
00:14:05,280 --> 00:14:08,870
Pero escribamos un programa
similar, usando

234
00:14:08,870 --> 00:14:11,975
el mismo algoritmo, pero
con asignaciones.

235
00:14:15,296 --> 00:14:16,940
Esta es la versión funcional.

236
00:14:23,840 --> 00:14:25,255
Quiero escribir una versión
imperativa.

237
00:14:34,150 --> 00:14:36,100
Factorial de n.

238
00:14:36,100 --> 00:14:37,510
Voy a crear dos variables.

239
00:14:40,120 --> 00:14:48,230
Voy a inicializar i en uno,
y m lo voy a inicializar

240
00:14:48,230 --> 00:14:50,930
en uno también.

241
00:14:50,930 --> 00:15:05,839
Vamos a crear un ciclo
que dice que si

242
00:15:05,840 --> 00:15:07,360
i es mayor a n, entonces
terminamos.

243
00:15:07,360 --> 00:15:10,910
Y el resultado es m, el producto
que estoy acumulando.

244
00:15:10,910 --> 00:15:19,319
Caso contrario, voy a escribir
tres cosas para hacer.

245
00:15:19,320 --> 00:15:22,300
Voy a hacer set!

246
00:15:22,300 --> 00:15:34,609
de m como el producto de i y m.
Y set! y como la suma de i y

247
00:15:34,610 --> 00:15:40,610
uno y volveré al ciclo.

248
00:15:40,610 --> 00:15:44,890
Les resultará familiar a ustedes
programadores de FORTRAN.

249
00:15:44,890 --> 00:15:47,760
ELSE, COND, DEFINe, una sintaxis
rara en cambio.

250
00:15:51,270 --> 00:15:59,319
Inicializamos el ciclo y ese es
el programa.

251
00:15:59,320 --> 00:16:02,790
Ahora bien, este programa, 
¿como razonamos sobre él?

252
00:16:02,790 --> 00:16:04,689
Bueno, digamos lo que vemos aquí.

253
00:16:04,690 --> 00:16:07,820
Hay dos variables locales, 
i y m, que fueron

254
00:16:07,820 --> 00:16:10,810
inicializadas en uno.

255
00:16:10,810 --> 00:16:13,119
Cada vez que paso por el ciclo, 
compruebo para ver si i es mayor

256
00:16:13,120 --> 00:16:16,400
que n, que es el argumento de entrada,
y si lo es,

257
00:16:16,400 --> 00:16:19,240
el resultado es el producto
que se está acumulando en m.

258
00:16:19,240 --> 00:16:23,640
Sin embargo, si no llegué
al final del ciclo, si no terminé,

259
00:16:23,640 --> 00:16:26,260
lo que voy a hacer es cambiar
el producto por el

260
00:16:26,260 --> 00:16:29,130
resultado de multiplicar i por el 
producto actual.

261
00:16:29,130 --> 00:16:31,530
Que es lo que estamos haciendo aquí.

262
00:16:31,530 --> 00:16:33,386
Excepto que aquí no estaba cambiando nada.

263
00:16:33,386 --> 00:16:38,219
Estaba haciendo otra copia, 
porque el modelo de sustitución

264
00:16:38,220 --> 00:16:44,410
dice que copies el cuerpo
del procedimiento con los argumentos

265
00:16:44,410 --> 00:16:46,709
sustituídos por los parámetros formales.

266
00:16:46,710 --> 00:16:49,690
Aquí no estoy preocupado por el copiado,
aquí cambié el

267
00:16:49,690 --> 00:16:51,990
valor de m.

268
00:16:51,990 --> 00:16:56,900
Y también cambio el valor
de i por i más uno, y

269
00:16:56,900 --> 00:16:58,300
continúo.

270
00:16:58,300 --> 00:17:01,359
Parece esencialmente el mismo
programa, pero hay

271
00:17:01,360 --> 00:17:03,110
algunas maneras de cometer errores

272
00:17:03,110 --> 00:17:06,160
que no existían hasta hoy.

273
00:17:06,160 --> 00:17:10,660
Por ejemplo, si fuera a hacer
algo horrible como no ser

274
00:17:10,660 --> 00:17:15,329
cuidadoso al escribir mi programa
e intercambiara esas

275
00:17:15,329 --> 00:17:17,888
dos asignaciones, el programa no

276
00:17:17,890 --> 00:17:20,339
computaría la misma función.

277
00:17:20,339 --> 00:17:24,858
Obtendría un error temporal
porque hay una dependencia en

278
00:17:24,858 --> 00:17:27,460
que m tenga el último valor de i.

279
00:17:27,460 --> 00:17:32,760
Si intento cambiar i primero,
tendría el valor incorrecto de i cuando

280
00:17:32,760 --> 00:17:36,600
multiplico por m.

281
00:17:36,600 --> 00:17:38,600
Es un bug que no existía 
hasta este momento,

282
00:17:38,600 --> 00:17:40,659
hasta que introdujimos algo
que tenía tiempo.

283
00:17:43,470 --> 00:17:47,650
Así que, como dije, primero necesitamos un
nuevo modelo de computación, y

284
00:17:47,650 --> 00:17:49,790
segundo, tenemos que tener una buena
razón para hacer algo

285
00:17:49,790 --> 00:17:52,800
tan feo.

286
00:17:52,800 --> 00:17:54,500
¿Alguna pregunta?

287
00:17:58,800 --> 00:18:00,504
Habla más fuerte, David.

288
00:18:00,505 --> 00:18:04,220
Estoy confundido porque
definimos el set! ahora, pero

289
00:18:04,220 --> 00:18:07,630
teníamos el let y el define antes.

290
00:18:07,630 --> 00:18:09,980
Estoy confundido sobre la diferencia
entre los tres.

291
00:18:09,980 --> 00:18:14,100
¿No funcionaría define en la misma
situación que set!

292
00:18:14,100 --> 00:18:15,280
si lo introdujeras?

293
00:18:15,280 --> 00:18:18,230
No, define pretende
asigna algo

294
00:18:18,230 --> 00:18:20,230
la primera vez, para crear algo.

295
00:18:22,790 --> 00:18:26,440
Nunca me viste escribir en el pizarrón
dos defines

296
00:18:26,440 --> 00:18:30,940
seguido cuya intención sea
cambiar el viejo valor

297
00:18:30,940 --> 00:18:31,970
de una variable por uno nuevo.

298
00:18:31,970 --> 00:18:34,380
¿Es por convención o --?

299
00:18:34,380 --> 00:18:38,120
No, es intencional.

300
00:18:38,120 --> 00:18:41,679
La respuesta es que, por ejemplo,
internamente a un procedimiento,

301
00:18:41,680 --> 00:18:47,250
dos defines seguidos son ilegales,
dos defines seguidos

302
00:18:47,250 --> 00:18:49,850
de la misma variable.

303
00:18:49,850 --> 00:18:51,889
x no puede definirse dos veces.

304
00:18:51,890 --> 00:18:54,300
Si un sistema o no maneja ese error
es una pregunta

305
00:18:54,300 --> 00:18:58,840
diferente, pero te digo que
define

306
00:18:58,840 --> 00:19:00,840
ocurre una vez para cualquier cosa.

307
00:19:00,840 --> 00:19:04,770
Ahora, ciertamente, en un debugging
interactivo, pretendemos que

308
00:19:04,770 --> 00:19:08,460
al interactuar con la computadora
redefinas cosas, así que

309
00:19:08,460 --> 00:19:10,500
se hace una excepción especial

310
00:19:10,500 --> 00:19:11,610
para el debugging interactivo.

311
00:19:11,610 --> 00:19:18,479
Pero se pretende que define 
signifique definir algo que

312
00:19:18,480 --> 00:19:22,460
por siempre tendrá el mismo valor.

313
00:19:22,460 --> 00:19:26,490
Es como si todos los defines
se hicieran al principio.

314
00:19:26,490 --> 00:19:29,870
De hecho, el única lugar legal
para poner un define en Scheme,

315
00:19:29,870 --> 00:19:32,570
internamente en un procedimiento, es 
al principio de

316
00:19:32,570 --> 00:19:36,605
una expresión lambda, el principio del

317
00:19:36,605 --> 00:19:37,855
cuerpo de un procedimiento.

318
00:19:41,750 --> 00:19:46,670
Ahora bien, let, por supuesto, 
no hace ninguna de esas cosas.

319
00:19:46,670 --> 00:19:50,520
Quiero decir, si miras lo que ocurre
en un let, esto ocurre

320
00:19:50,520 --> 00:19:52,220
exactamente una vez.

321
00:19:52,220 --> 00:19:56,820
Setea un contexto donde i y m
son valores uno y uno.

322
00:19:56,820 --> 00:20:01,629
Ese contexto existe a través
de este ámbito, esta

323
00:20:01,630 --> 00:20:02,880
región del programa.

324
00:20:05,800 --> 00:20:11,110
Sin embargo, no piensas en let
como si asignara i de nuevo.

325
00:20:11,110 --> 00:20:12,350
No lo cambia.

326
00:20:12,350 --> 00:20:15,389
i nunca cambia por el let.

327
00:20:15,390 --> 00:20:18,690
i se crea por el let.

328
00:20:18,690 --> 00:20:22,300
De hecho, el let es una idea
muy simple.

329
00:20:22,300 --> 00:20:30,930
Let no hace nada más, let 
de una variable para que

330
00:20:30,930 --> 00:20:37,660
tenga un cierto valor. Escribiré esto un 
poco más prolijo. Escribamos esto

331
00:20:37,660 --> 00:20:43,890
var1 con el valor de la expresión e1,

332
00:20:43,890 --> 00:20:48,470
y var2 con el valor de la expresión e2,
en una

333
00:20:48,470 --> 00:21:00,420
expresión e3, es lo mismo que
un procedimiento de var1 y

334
00:21:00,420 --> 00:21:08,460
var2, los parámetros formales
y e3 como el cuerpo,

335
00:21:08,460 --> 00:21:15,100
donde var1 está ligada al valor de e1,
y var2

336
00:21:15,100 --> 00:21:16,820
tiene el valor de e2.

337
00:21:19,590 --> 00:21:22,500
Esto es, de hecho, algo perfectamente
entendible desde

338
00:21:22,500 --> 00:21:24,930
el punto de vista del modelo de
sustitución.

339
00:21:24,930 --> 00:21:27,300
Es la misma expresión
escrita de dos

340
00:21:27,300 --> 00:21:28,550
maneras diferentes.

341
00:21:31,820 --> 00:21:34,220
De hecho, la manera en que el
sistema funciona es que esto

342
00:21:34,220 --> 00:21:37,311
se traduce en esto
antes de que pase algo.

343
00:21:37,311 --> 00:21:39,689
Bien, todavía no tengo
claro en qué se

344
00:21:39,690 --> 00:21:41,360
diferencian el let y el define.

345
00:21:41,360 --> 00:21:42,125
Podrían --

346
00:21:42,125 --> 00:21:45,570
Un define es azúcar sintáctico, dónde,

347
00:21:45,570 --> 00:21:48,270
esencialmente un montón de variables
se crean con lets y

348
00:21:48,270 --> 00:21:49,520
se setean una única vez.

349
00:21:57,170 --> 00:21:58,790
Es tiempo del primer descanso, creo.

350
00:21:58,790 --> 00:22:00,400
Gracias.

351
00:23:04,430 --> 00:23:06,530
Bueno, veamos.

352
00:23:06,530 --> 00:23:10,520
Ahora tengo que reconstruir
el modelo de computación, para

353
00:23:10,520 --> 00:23:13,690
que entiendan cómo un mecanismo
mecánico podría

354
00:23:13,690 --> 00:23:17,600
funcionar para hacer todo
lo que hablamos recién.

355
00:23:17,600 --> 00:23:22,730
Recientemente destruí 
nuestro modelo de sustitución.

356
00:23:22,730 --> 00:23:25,700
Desafortunadamente, este modelo
es significantemente más complicado

357
00:23:25,700 --> 00:23:26,379
que el modelo de sustitución.

358
00:23:26,380 --> 00:23:29,100
El llama modelo de entorno.

359
00:23:29,100 --> 00:23:32,129
Y voy a tener que introducir
algo de terminología,

360
00:23:32,130 --> 00:23:34,660
que de cualquier manera es una buena
terminología para que sepan.

361
00:23:34,660 --> 00:23:36,640
Es sobre nombres.

362
00:23:36,640 --> 00:23:39,360
Y le vamos a dar nombres 
a los tipos de nombres que las cosas

363
00:23:39,360 --> 00:23:42,719
tienen y a cómo se usan esos nombres.

364
00:23:42,720 --> 00:23:48,290
Es una meta descripción,
por así decirlo.

365
00:23:48,290 --> 00:23:50,840
De cualquier manera, hay una pila
de terminología desafortunada aquí,

366
00:23:50,840 --> 00:23:52,730
para la vamos a necesitar
para entender lo que se conoce

367
00:23:52,730 --> 00:23:54,770
como el modelo de entorno.

368
00:23:54,770 --> 00:23:58,250
Vamos hacer un poco de trabajo
aburrido y de perro.

369
00:23:58,250 --> 00:24:02,280
Veamos la primer transparencia.

370
00:24:02,280 --> 00:24:08,879
Vemos una descripción de una palabra
llamada "ligar".

371
00:24:08,880 --> 00:24:11,980
Y vamos a decir que una variable v 
está ligada a una

372
00:24:11,980 --> 00:24:16,890
expresión e, si el significado de e 
si el significado de e no cambia

373
00:24:16,890 --> 00:24:22,520
reemplazando uniformemente
cualquier varible w, que no aparece

374
00:24:22,520 --> 00:24:25,440
en e, para cada ocurrencia de v en e.

375
00:24:25,440 --> 00:24:28,390
Esa es un oración larga, así que
voy a tener que

376
00:24:28,390 --> 00:24:31,690
decir un poco más sobre eso antes
de que siquiera

377
00:24:31,690 --> 00:24:33,490
empecemos a jugar aquí.

378
00:24:33,490 --> 00:24:35,260
Aquí estamos hablando de
variables ligadas.

379
00:24:44,300 --> 00:24:46,710
Han visto muchas de ellas.

380
00:24:46,710 --> 00:24:48,170
Quizá no sepan que vieron un montón
de ellas.

381
00:24:48,170 --> 00:24:51,880
Bueno, supongo que en lógica vieron
vieron variables lógicas

382
00:24:51,880 --> 00:24:58,210
como para cada x existe un y tal que
p de x y de

383
00:24:58,210 --> 00:24:59,860
y, de sus clases de cálculo.

384
00:25:02,960 --> 00:25:06,780
Esta variable, x, y esta variable
y, están ligadas

385
00:25:06,780 --> 00:25:10,920
porque el significado
de esta expresión no depende

386
00:25:10,920 --> 00:25:16,640
de las letras particular que use
para describir a x y a y.

387
00:25:16,640 --> 00:25:21,740
Si fuera a cambiar x por w,
y dijera que para todo w

388
00:25:21,740 --> 00:25:26,420
existe un y tal que P de x y de y, 
entonces

389
00:25:26,420 --> 00:25:29,540
sería la misma oración.

390
00:25:29,540 --> 00:25:30,389
Eso es lo que significa.

391
00:25:30,390 --> 00:25:35,690
O otro caso de esto es la integral, 
digamos,

392
00:25:35,690 --> 00:25:42,415
desde cero hasta uno de dx
sobre uno más x cuadrado.

393
00:25:46,800 --> 00:25:47,439
Eso es algo que ven todo el tiempo.

394
00:25:47,440 --> 00:25:52,270
Y esta x es una variable ligada.

395
00:25:52,270 --> 00:25:55,190
Si lo cambio por un t, la expresión

396
00:25:55,190 --> 00:25:58,170
sigue siendo lo mismo.

397
00:25:58,170 --> 00:26:04,850
Es 1/4 del arcotangente de uno
o algo así.

398
00:26:04,850 --> 00:26:06,620
Sí, el arcotangente de uno.

399
00:26:06,620 --> 00:26:09,379
Así que las variables ligadas son
muy comunes, de hecho, para

400
00:26:09,380 --> 00:26:13,690
aquellos que jugaron un poco
con las matemáticas.

401
00:26:13,690 --> 00:26:19,100
Bueno, vayamos al mundo
de la programación.

402
00:26:19,100 --> 00:26:22,219
En vez del cuantificador siendo
algo como "para todo" o

403
00:26:22,220 --> 00:26:25,000
"existe", o "integral de", 
un cuantificador es un

404
00:26:25,000 --> 00:26:27,570
símbolo que liga una variable.

405
00:26:27,570 --> 00:26:30,280
Y vamos a usar el cuantificador lambda
como algo

406
00:26:30,280 --> 00:26:33,970
esencial que liga variables.

407
00:26:33,970 --> 00:26:37,730
Y ahora tenemos algunos lindos
ejemplos como ese

408
00:26:37,730 --> 00:26:43,160
procedimiento de un argumento "y"
que hace

409
00:26:43,160 --> 00:26:44,370
lo siguiente.

410
00:26:44,370 --> 00:26:50,300
Llama al procedimiento de un argumento
x que multiplica x por

411
00:26:50,300 --> 00:26:54,145
y se lo aplica a tres.

412
00:26:58,810 --> 00:27:00,860
Ese procedimiento tiene
la propiedad de tener dos variables

413
00:27:00,860 --> 00:27:04,790
ligadas en él, x e y.

414
00:27:04,790 --> 00:27:08,500
Este cuantificador lambda
liga este y y este cuantificador

415
00:27:08,500 --> 00:27:12,120
lambda liga este x.

416
00:27:12,120 --> 00:27:15,000
Porque si si fuera a tomar un
símbolo arbitrario que no

417
00:27:15,000 --> 00:27:20,130
aparece en esta expresión, como w, 
y reemplazara todas las y's con w's

418
00:27:20,130 --> 00:27:23,610
en la expresión, la expresión
seguiría siendo la misma,

419
00:27:23,610 --> 00:27:26,240
el mismo procedimiento.

420
00:27:26,240 --> 00:27:27,430
Y esta es una idea importante.

421
00:27:27,430 --> 00:27:30,700
La razón por la que tenemos cosas
así es por una especie

422
00:27:30,700 --> 00:27:31,500
de modularidad.

423
00:27:31,500 --> 00:27:34,800
Si dos personas están escribiendo
programas y trabajan

424
00:27:34,800 --> 00:27:38,149
juntos, no debería importar qué nombres
usan internamente

425
00:27:38,150 --> 00:27:42,490
en sus pequeñas máquinas.

426
00:27:42,490 --> 00:27:45,960
Y lo que les estoy diciendo, es que,

427
00:27:45,960 --> 00:27:49,490
por ejemplo, este es equivalente
a ese procedimiento

428
00:27:49,490 --> 00:27:54,260
de un argumento y que usa un
procedimiento de un argumento

429
00:27:54,260 --> 00:28:01,200
z que multiplica x por y.

430
00:28:01,200 --> 00:28:03,570
Porque a nadie le importa
qué usé aquí.

431
00:28:06,270 --> 00:28:08,879
Es un lindo ejemplo.

432
00:28:08,880 --> 00:28:15,320
En cambio, tengo algunas
variables que no están ligadas.

433
00:28:15,320 --> 00:28:22,450
Por ejemplo, el procedimiento
de un argumento x que

434
00:28:22,450 --> 00:28:27,390
multiplica x por y.

435
00:28:27,390 --> 00:28:32,370
En este caso, y no está ligada.

436
00:28:32,370 --> 00:28:36,439
Supongan que y vale tres,
y z vale

437
00:28:36,440 --> 00:28:41,420
cuatro, entonces este procedimiento
sería la cosa que multiplica

438
00:28:41,420 --> 00:28:44,910
su argumento por tres.

439
00:28:44,910 --> 00:28:47,793
Si fuera a reemplazar cada ocurrencia
de y con z, obtendría

440
00:28:47,793 --> 00:28:50,189
un procedimiento diferente
que multiplica sus

441
00:28:50,190 --> 00:28:53,491
argumentos por cuatro.

442
00:28:53,491 --> 00:28:57,810
Y, de hecho, tenemos un nombre
para variables así.

443
00:28:57,810 --> 00:29:03,679
Decimos que una variable v
está libre en una expresión e

444
00:29:03,680 --> 00:29:06,200
si el significado de la expresión e 
cambia por el reemplazo

445
00:29:06,200 --> 00:29:09,355
uniforme de una variable w,
que no ocurre en e

446
00:29:09,355 --> 00:29:13,120
por cada ocurrencia de v en e.

447
00:29:13,120 --> 00:29:20,679
Así que por eso esta variable de aquí,

448
00:29:20,680 --> 00:29:22,525
y, es una variable libre.

449
00:29:29,100 --> 00:29:33,610
Y las variables libres en esta
expresión --

450
00:29:33,610 --> 00:29:38,689
Y otro ejemplos de eso es
el procedimiento de un argumento

451
00:29:38,690 --> 00:29:43,160
y, que lo que teníamos antes, que usa

452
00:29:43,160 --> 00:29:48,130
el procedimiento de un argumento x
que multiplica x por y --

453
00:29:51,540 --> 00:29:52,790
y lo usa sobre tres.

454
00:29:56,940 --> 00:30:00,600
Este procedimiento
tiene una variable libre

455
00:30:00,600 --> 00:30:01,794
que es el asterisco.

456
00:30:05,100 --> 00:30:07,170
Ven, porque si eso tuviera
el significado normal de

457
00:30:07,170 --> 00:30:11,360
multiplicación y fuera a reemplazar
uniformemente todos los

458
00:30:11,360 --> 00:30:15,770
asteriscos con más, entonces
el significado de la expresión

459
00:30:15,770 --> 00:30:17,200
cambiaría.

460
00:30:19,360 --> 00:30:22,850
Eso quieren decir con variable libre.

461
00:30:22,850 --> 00:30:26,350
Hasta ahora han aprendido
alguna palabras de la lógica para

462
00:30:26,350 --> 00:30:29,200
describir la manera en que usamos
lo nombre.

463
00:30:29,200 --> 00:30:32,490
Ahora vamos a jugar un poco más
con eso,

464
00:30:32,490 --> 00:30:35,200
un poquito más.

465
00:30:35,200 --> 00:30:38,600
Quiero hablarles sobre las
regiones en las que las

466
00:30:38,600 --> 00:30:39,850
variables están definidas.

467
00:30:42,270 --> 00:30:45,260
Verán, hemos sido bastante informales
hasta ahora y,

468
00:30:45,260 --> 00:30:48,870
por supuesto, muchos de ustedes
han probablemente entendido

469
00:30:48,870 --> 00:30:51,959
claramente, o la mayoría de ustedes,
que el x que está siendo

470
00:30:51,960 --> 00:30:55,170
declarado aquí está
definido sólo aquí.

471
00:30:58,250 --> 00:31:03,580
Este x está definido solamente aquí,
y este y está solamente

472
00:31:03,580 --> 00:31:04,830
definido aquí.

473
00:31:07,800 --> 00:31:08,399
Tenemos un nombre para esta
idea,

474
00:31:08,400 --> 00:31:11,660
se llama ambiente.

475
00:31:11,660 --> 00:31:14,710
Y déjenme darle otra pieza
de terminología.

476
00:31:14,710 --> 00:31:16,500
Es una larga historia.

477
00:31:16,500 --> 00:31:18,850
Si x es una variable ligada en e,
entonces hay una expresión

478
00:31:18,850 --> 00:31:20,560
lambda donde está ligada.

479
00:31:20,560 --> 00:31:23,956
Así que la única manera en que
se puede obtener una variable ligada

480
00:31:23,956 --> 00:31:24,969
es mediante una expresión lambda.

481
00:31:24,970 --> 00:31:28,250
Entoces podrían preocuparse:
¿es define una

482
00:31:28,250 --> 00:31:29,670
excepción de esto?

483
00:31:29,670 --> 00:31:31,840
Y resulta que siempre
podríamos organizarnos para que

484
00:31:31,840 --> 00:31:33,100
no necesitemos defines.

485
00:31:33,100 --> 00:31:34,700
Y veremos eso en un momento.

486
00:31:34,700 --> 00:31:36,899
Es algo muy mágico.

487
00:31:36,900 --> 00:31:39,000
Así que el define podría no existir.

488
00:31:39,000 --> 00:31:42,650
La única cosa que crea nombres
es lambda.

489
00:31:42,650 --> 00:31:44,350
Es su trabajo.

490
00:31:44,350 --> 00:31:46,865
Es lo que es maravilloso sobre
muchas cosas es que puedes

491
00:31:46,865 --> 00:31:48,740
computar sólo con lambda.

492
00:31:48,740 --> 00:31:53,910
Pero, en cualquier caso, una expresión
lambda tiene un lugar donde

493
00:31:53,910 --> 00:31:55,880
declara una variable.

494
00:31:55,880 --> 00:31:59,970
Lo llamamos una lista de parámetros
formales o la lista de variables

495
00:31:59,970 --> 00:32:03,290
ligadas. Decimos que la 
expresión lambda liga--

496
00:32:03,290 --> 00:32:04,970
es un verbo--

497
00:32:04,970 --> 00:32:08,730
liga las variables declaradas
en su lista de variables ligadas.

498
00:32:08,730 --> 00:32:10,580
Además, esas partes de la
expresión donde está definida

499
00:32:10,580 --> 00:32:15,679
la variable, que fue declarada
por alguna declaración,

500
00:32:15,680 --> 00:32:20,400
se conoce como el alcance 
de esa variable.

501
00:32:20,400 --> 00:32:22,270
Esos son los alcances.

502
00:32:22,270 --> 00:32:23,629
Este es el alcance de y.

503
00:32:27,140 --> 00:32:28,690
Y este es el alcance de x--

504
00:32:33,300 --> 00:32:34,280
Ese tipo de cosas.

505
00:32:41,460 --> 00:32:47,120
Bien, ahora tenemos suficiente
terminología para comenzar a

506
00:32:47,120 --> 00:32:52,360
entender cómo hacer un nuevo
modelo para computar, porque

507
00:32:52,360 --> 00:32:56,600
lo clave que está ocurriendo
aquí es que destruímos el

508
00:32:56,600 --> 00:32:58,820
modelo de sustitución, y ahora
vamos a tener que tener un modelo

509
00:32:58,820 --> 00:33:03,950
que represente los como referencias
a lugares.

510
00:33:03,950 --> 00:33:06,460
Porque si vamos a cambiar algo, entonces

511
00:33:06,460 --> 00:33:09,660
tenemos un lugar donde está alojado.

512
00:33:09,660 --> 00:33:14,860
Verán, si un nombre sólo refiere
a un valor, y si intentara

513
00:33:14,860 --> 00:33:19,280
cambiar el significado del nombre, 
bueno, eso no es claro.

514
00:33:19,280 --> 00:33:23,570
No hay nada que sea un lugar 
y que se referenciado

515
00:33:23,570 --> 00:33:25,300
por ese nombre.

516
00:33:25,300 --> 00:33:25,960
¿Cómo lo estoy diciendo?

517
00:33:25,960 --> 00:33:28,220
No hay nada compartido
por todas las

518
00:33:28,220 --> 00:33:29,840
instancias de ese nombre.

519
00:33:29,840 --> 00:33:32,800
Y lo que realmente queremos decir
con un nombre es que

520
00:33:32,800 --> 00:33:34,439
lo mandamos para afuera.

521
00:33:34,440 --> 00:33:37,350
Le dimos un nombre a algo, 
y tú lo tienes, y lo tienes

522
00:33:37,350 --> 00:33:39,469
porque te di una referencia a él,

523
00:33:39,470 --> 00:33:41,130
y porque te di una referencia a él.

524
00:33:41,130 --> 00:33:43,580
Y veremos mucho sobr eso.

525
00:33:43,580 --> 00:33:45,985
Déjenme hablarles sobre 
entonrnos.

526
00:33:45,986 --> 00:33:52,140
Necesito el retroproyector, por favor.

527
00:33:52,140 --> 00:34:01,590
Aquí hay un montón de estructuras
de entorno.

528
00:34:01,590 --> 00:34:06,490
Un entorno es una manera de hacer
sustituciones virtualmente.

529
00:34:06,490 --> 00:34:09,639
Representa un lugar donde
algo está almacenado, que

530
00:34:09,639 --> 00:34:11,409
son las sustitucones
que no hicieron.

531
00:34:14,540 --> 00:34:17,639
Es un lugar donde todo
se acumula, donde los nombres

532
00:34:17,639 --> 00:34:20,600
de las variables están asociados
con los valores

533
00:34:20,600 --> 00:34:26,199
que tienen, de manera tal que
cuando preguntas por un nombre

534
00:34:26,199 --> 00:34:28,900
lo buscas en el entorno.

535
00:34:28,900 --> 00:34:32,420
Así que un entorno es un función
o una tabla,

536
00:34:32,420 --> 00:34:33,290
o algo por el estilo.

537
00:34:33,290 --> 00:34:35,790
Pero está estructurado como una tabla.

538
00:34:35,790 --> 00:34:37,125
Está compuesta de cosas
llamadas frames.

539
00:34:41,500 --> 00:34:45,210
Los frames son pedazos del entorno,
y están encadenados,

540
00:34:45,210 --> 00:34:50,270
por lo que se conoce
como enlaces padre,

541
00:34:50,270 --> 00:34:53,940
o algo así.

542
00:34:53,940 --> 00:34:57,740
Aqui, tenemos una estructura
de entorno

543
00:34:57,740 --> 00:35:00,100
que consiste de tres entornos,

544
00:35:00,100 --> 00:35:05,250
básicamente, A, B y C.

545
00:35:05,250 --> 00:35:11,480
D también es un entorno, pero
es el mismo, se comparten.

546
00:35:11,480 --> 00:35:14,550
Y esa es la esencia de la asignación.

547
00:35:14,550 --> 00:35:18,120
Si cambio una variable, el valor
de una variable que vive aquí,

548
00:35:18,120 --> 00:35:21,950
como esta, debería ser
visible desde todos los lugares

549
00:35:21,950 --> 00:35:23,750
desde dónde la estás mirando.

550
00:35:23,750 --> 00:35:24,990
Tomemos esta, x.

551
00:35:24,990 --> 00:35:28,560
Si cambio x a cuatro, es

552
00:35:28,560 --> 00:35:30,340
visible desde otro lugares.

553
00:35:30,340 --> 00:35:32,270
Pero no me voy a preocupar
por eso ahora.

554
00:35:32,270 --> 00:35:34,590
Vamos a hablar un montón sobre ello
en un momento.

555
00:35:34,590 --> 00:35:36,830
¿Qué tenemos aquí?

556
00:35:36,830 --> 00:35:37,990
Bueno, estos se llaman frames.

557
00:35:37,990 --> 00:35:43,270
Este es un frame, este es un frame
y este es un frame.

558
00:35:43,270 --> 00:35:47,400
A es un entorno que consiste
de la tabla que es

559
00:35:47,400 --> 00:35:52,570
el frame II, seguido de la tabla
que es el frame I.

560
00:35:52,570 --> 00:35:59,280
Y, en este ambiente, digamos
en este ambiente, el frame II,

561
00:35:59,280 --> 00:36:04,150
x e y están ligadas.

562
00:36:04,150 --> 00:36:05,920
Tienen valores.

563
00:36:05,920 --> 00:36:07,290
Perdón, en el frame I.

564
00:36:07,290 --> 00:36:15,340
En el frame II, x está ligada, x está ligada
e y está ligada,

565
00:36:15,340 --> 00:36:18,560
pero el valor de x que vemos,
desde este pinto de vista,

566
00:36:18,560 --> 00:36:20,940
es este x.

567
00:36:20,940 --> 00:36:24,940
Es el x que vale siete, en vez de este
que vale tres.

568
00:36:24,940 --> 00:36:27,660
Decimos que x ensombrece
a este x.

569
00:36:31,700 --> 00:36:33,320
Del entorno tres --

570
00:36:33,320 --> 00:36:36,460
del frame III, del entorno B, que refiere

571
00:36:36,460 --> 00:36:42,155
al frame III, tenemos a m y a y
ligadas y también a x.

572
00:36:44,740 --> 00:36:48,629
Este y ensombrece a este.

573
00:36:48,630 --> 00:36:50,580
Así que el valor, mirando
desde este punto de

574
00:36:50,580 --> 00:36:53,410
vista de y es dos.

575
00:36:53,410 --> 00:36:54,899
El valor al mirar desde este punto de

576
00:36:54,900 --> 00:36:56,500
vista a m es uno.

577
00:36:56,500 --> 00:36:57,620
Y el valor, mirando desde este punto

578
00:36:57,620 --> 00:36:58,870
de vista de x es tres.

579
00:37:02,310 --> 00:37:04,299
Ahí tenemos una estructura
de entorno

580
00:37:04,300 --> 00:37:06,340
simple compuesta de frames.

581
00:37:06,340 --> 00:37:10,990
Estos corresponden a la aplicación
de procedimientos.

582
00:37:10,990 --> 00:37:14,390
Y veremos eso en un segundo.

583
00:37:14,390 --> 00:37:16,859
Así que ahora tengo que 
hacer otra pequeña linda estructura

584
00:37:16,860 --> 00:37:18,110
que construímos.

585
00:37:20,870 --> 00:37:25,819
Siguiente diapositiva, vemos un objeto
que va a dibujar

586
00:37:25,820 --> 00:37:27,850
procedimientos.

587
00:37:27,850 --> 00:37:30,190
Esto es un procedimiento.

588
00:37:30,190 --> 00:37:33,150
Un procedimiento
está compuesto de dos partes.

589
00:37:33,150 --> 00:37:34,515
Es como un CONS.

590
00:37:37,210 --> 00:37:38,460
Son dos partes.

591
00:37:40,820 --> 00:37:46,410
La primera parte refiere al código,
algo que puede ser

592
00:37:46,410 --> 00:37:48,940
ejecutado, un conjunto de instrucciones,
por así decirlo.

593
00:37:48,940 --> 00:37:50,750
Pueden pensarlo de esa manera.

594
00:37:50,750 --> 00:37:53,830
Y la segunda parte es el entorno.

595
00:37:53,830 --> 00:37:57,250
El procedimiento es todo eso.

596
00:37:57,250 --> 00:38:01,420
Y vamos a tener que usar esto
para capturar los valores

597
00:38:01,420 --> 00:38:06,250
de las variables libres que aparecen
en el procedimiento.

598
00:38:06,250 --> 00:38:08,760
Si una variable aparece en el
procedimiento entonces o está ligada

599
00:38:08,760 --> 00:38:11,170
en ese procedimiento o está libre

600
00:38:11,170 --> 00:38:16,930
Si está ligada, entonces
el valor es fácil de encontrar.

601
00:38:16,930 --> 00:38:19,690
Estará en algún entorno fácil
de llegar.

602
00:38:19,700 --> 00:38:21,800
Si está libre, vamos a tener algo

603
00:38:21,800 --> 00:38:24,100
que vaya con el procedimiento y le diga
dónde ir

604
00:38:24,100 --> 00:38:27,100
a buscar el valor.

605
00:38:27,100 --> 00:38:32,290
Y el porqué no es tan obvio por ahora,
pero lo será pronto.

606
00:38:32,290 --> 00:38:33,759
Este es un objeto de procedimiento.

607
00:38:33,760 --> 00:38:40,200
Es un objeto compuesto, 
que consiste de un pedazo de código

608
00:38:40,200 --> 00:38:42,750
y una estructura de entorno.

609
00:38:42,750 --> 00:38:46,400
Ahora les diré las nuevas reglas,
las completas nuevas reglas,

610
00:38:46,400 --> 00:38:47,650
para la evaluación.

611
00:38:50,690 --> 00:38:53,250
La primera regla es --
Solamente son dos.

612
00:38:53,250 --> 00:38:57,250
Que se corresponden con las reglas
de modelo de sustitución.

613
00:38:57,250 --> 00:39:00,830
Y la primera tiene que ver con
cómo aplicar un

614
00:39:00,830 --> 00:39:02,569
procedimiento a sus argumentos.

615
00:39:05,610 --> 00:39:08,890
Y un objeto procedural se aplica
a un conjunto de argumentos

616
00:39:08,890 --> 00:39:11,270
construyendo un nuevo frame.

617
00:39:11,270 --> 00:39:13,860
El frame contendrá el mapeo
de lo parámetros formales

618
00:39:13,860 --> 00:39:16,540
con los verdaderos parámetros
de los argumentos

619
00:39:16,540 --> 00:39:21,490
que nos proveyeron en la llamada.

620
00:39:21,490 --> 00:39:25,319
Como saben, cuando hacemos una
llamado a un procedimiento

621
00:39:25,320 --> 00:39:28,670
como lambda de x, x por y, y lo
llamamos el con argumento

622
00:39:28,670 --> 00:39:31,280
tres, vamos a necesitar un

623
00:39:31,280 --> 00:39:34,290
mapeo de x a tres.

624
00:39:34,290 --> 00:39:38,490
Es lo que mismo que sustituir,
por así decirlo, el

625
00:39:38,490 --> 00:39:41,990
tres por el x en el viejo modelo.

626
00:39:41,990 --> 00:39:45,160
Así que voy a construir un frame
que contiene que x es igual a tres

627
00:39:45,160 --> 00:39:46,549
como su información.

628
00:39:49,230 --> 00:39:52,640
Ahora bien, el cuerpo del 
procedimiento va a tener que ser evaluado,

629
00:39:52,640 --> 00:39:54,170
que es esto.

630
00:39:54,170 --> 00:40:04,710
Será evaluado en un entorno
que está

631
00:40:04,710 --> 00:40:08,780
construído al unir el nuevo
frame que hicimos con

632
00:40:08,780 --> 00:40:10,450
el entorno del que era
parte el

633
00:40:10,450 --> 00:40:13,100
procedimiento que aplicamos.

634
00:40:13,100 --> 00:40:15,670
Voy a mostrarles un pequeño ejemplo
de eso aquí.

635
00:40:19,220 --> 00:40:25,109
Supongan que tengo un entorno.

636
00:40:25,110 --> 00:40:27,980
Aquí hay un frame que lo representa.

637
00:40:27,980 --> 00:40:30,190
Y algún procedimiento, 
que voy a dibjuar con círculos

638
00:40:30,190 --> 00:40:33,370
aquí porque es más fácil
que triángulos pequeños.

639
00:40:33,370 --> 00:40:38,940
Perdonen, esos son rombos,
piezas romboidales de

640
00:40:38,940 --> 00:40:42,710
gelatina o algo.

641
00:40:42,710 --> 00:40:45,960
Aquí hay un procedimiento que
toma este entorno.

642
00:40:45,960 --> 00:40:48,920
Y el procedimento tiene
un pedazo de código que es una

643
00:40:48,920 --> 00:40:55,600
expresión lambda, que liga x e y y luego
ejecuta una

644
00:40:55,600 --> 00:40:58,900
expresión e.

645
00:40:58,100 --> 00:40:59,345
Y este es el procedimiento.

646
00:40:59,345 --> 00:41:01,470
Lo llamaremos p.

647
00:41:01,470 --> 00:41:06,490
Quisiera aplicar ese procedimiento
a tres y a cuatro.

648
00:41:06,490 --> 00:41:09,790
Quiero hacer p de tres y de cuatro.

649
00:41:09,790 --> 00:41:13,210
Lo que voy a hacer, por supuesto,
es crear un nuevo frame.

650
00:41:13,210 --> 00:41:18,630
Construyo un frame que contiene
x igual a tres

651
00:41:18,630 --> 00:41:21,740
e y igual a cuatro.

652
00:41:21,740 --> 00:41:27,680
Voy a conectar ese frame a este
frame de aquí.

653
00:41:27,680 --> 00:41:31,940
Y luego este entorno, que llamaré B, es

654
00:41:31,940 --> 00:41:34,880
el entorno en el que voy a evaluar
el cuerpo de e.

655
00:41:39,940 --> 00:41:46,890
Ahora bien, e puede contener
referencias a x e y y otras cosas.

656
00:41:46,890 --> 00:41:50,790
x e y tendrá valores aquí.

657
00:41:50,790 --> 00:41:55,400
Otras cosas tendrán sus valores aquí.

658
00:41:55,400 --> 00:41:56,920
¿Cómo obtengo este frame?

659
00:41:56,920 --> 00:42:00,110
Lo hacemos mediante la construcción
de procedimientos, que es

660
00:42:00,110 --> 00:42:01,980
la otra regla.

661
00:42:01,980 --> 00:42:05,500
Y creo que es la próxima diapositiva.

662
00:42:05,500 --> 00:42:10,000
Regla dos, cuando una expresión
lambda es evaluada,

663
00:42:10,000 --> 00:42:11,510
relativa a un entorno particular--

664
00:42:14,150 --> 00:42:17,470
La manera que obtengo un procedimiento
es evaluando la expresión

665
00:42:17,470 --> 00:42:18,299
lambda.

666
00:42:18,300 --> 00:42:20,110
Esta es una expresión lambda.

667
00:42:20,110 --> 00:42:22,880
Al evaluarla, obtengo un procedimiento
que le puedo

668
00:42:22,880 --> 00:42:25,170
aplicar a tres.

669
00:42:25,170 --> 00:42:28,710
Ahora esta expresión lambda
es evaluada en un entorno

670
00:42:28,710 --> 00:42:31,820
donde y está definida.

671
00:42:31,820 --> 00:42:33,760
Y quiero que el cuerpo
de esto contenga

672
00:42:33,760 --> 00:42:36,680
una versión libre de y.

673
00:42:36,680 --> 00:42:41,790
y está libre aquí, ligada en el todo, pero

674
00:42:41,790 --> 00:42:43,350
está libre aquí.

675
00:42:43,350 --> 00:42:47,440
Y quiero que este y sea este.

676
00:42:47,440 --> 00:42:53,150
Evalúo el cuerpo de este procedimiento
en el entorno

677
00:42:53,150 --> 00:42:55,470
donde y fue creado.

678
00:42:55,470 --> 00:42:57,799
Es este tipo de cosa, porque
se hizo mediante

679
00:42:57,800 --> 00:42:59,140
aplicación.

680
00:42:59,140 --> 00:43:03,490
Si quisiera buscar el valor de y, 
tendría que saber

681
00:43:03,490 --> 00:43:04,370
dónde está.

682
00:43:04,370 --> 00:43:07,440
Por lo tanto, mejor que el procedimiento
creado, que la creación del

683
00:43:07,440 --> 00:43:09,530
procedimiento que es el
resultado de evaluar la expresión

684
00:43:09,530 --> 00:43:14,480
lambda capture
un puntero para recordar el

685
00:43:14,480 --> 00:43:18,110
frame en el que y está ligada.

686
00:43:18,110 --> 00:43:22,100
Así que eso es lo que nos está
diciendo esta regla.

687
00:43:22,100 --> 00:43:28,610
Por ejemplo, si resultase
que estoy evaluando una expresión

688
00:43:28,610 --> 00:43:37,370
lambda, una expresión lambda
en e, digamos lambda de x e y,

689
00:43:37,370 --> 00:43:43,200
llamémosla g, en e, 
si estuviera evaluando eso.

690
00:43:43,200 --> 00:43:47,190
Bueno, eso significa que
ahora creo un objeto procedural.

691
00:43:47,190 --> 00:43:48,990
e es algún entorno.

692
00:43:48,990 --> 00:43:51,919
e es algo que está siendo
apuntado por un puntero.

693
00:43:51,920 --> 00:43:56,120
Contruyo un objeto procedual
que apunta a ese

694
00:43:56,120 --> 00:44:01,830
entorno, dónde el código de 
la expresión lambda o

695
00:44:01,830 --> 00:44:03,180
lo que sea eso en lo que se traduzca.

696
00:44:06,330 --> 00:44:07,580
Y este es el procedimiento.

697
00:44:12,380 --> 00:44:17,640
Así que esto produce para mí --
este objeto, este puntero al

698
00:44:17,640 --> 00:44:21,140
entorno, captura el lugar
dónde esta expresión lambda

699
00:44:21,140 --> 00:44:25,819
se evaluó, dónde se usó 
la definición, dónde se usó

700
00:44:25,820 --> 00:44:26,900
la definición para hacer

701
00:44:26,900 --> 00:44:32,950
un procedimiento, para hacer el
procedimiento.

702
00:44:32,950 --> 00:44:35,189
Así que levanta el entorno
del lugar dónde ese se definió

703
00:44:35,190 --> 00:44:39,680
ese procedimiento, lo guarda
en el mismo procedimiento

704
00:44:39,680 --> 00:44:42,210
y luego cuando se usa el procedimiento,
el entorno donde

705
00:44:42,210 --> 00:44:44,990
se definió se extiende con el
nuevo frame.

706
00:44:48,740 --> 00:44:51,169
Así que esto nos da una locación
para guardar qué

707
00:44:51,170 --> 00:44:53,900
valor tiene una variable.

708
00:44:53,900 --> 00:44:55,700
Y, por ejemplo, si hay muchas
cosas apuntando a ese

709
00:44:55,700 --> 00:45:01,430
entorno, entonces comparten
ese lugar.

710
00:45:01,430 --> 00:45:03,810
Y veremos más sobre eso pronto.

711
00:45:03,810 --> 00:45:08,940
Bueno, ahora tienen un nuevo modelo
para entender la

712
00:45:08,940 --> 00:45:12,420
ejecución de programas.
Supongo que aceptaré preguntas

713
00:45:12,420 --> 00:45:14,970
ahora y luego usaremos eso
para algo.

714
00:45:17,802 --> 00:45:21,870
Es correcto decir, entonces, 
que un entorno

715
00:45:21,870 --> 00:45:23,694
es una list enlazada de frames

716
00:45:23,695 --> 00:45:24,580
Eso es correcto.

717
00:45:24,580 --> 00:45:25,650
Comenzando con --

718
00:45:25,650 --> 00:45:27,760
¿ir completando hacia atrás?

719
00:45:27,760 --> 00:45:29,400
Sí, el entorno es una secuencia

720
00:45:29,400 --> 00:45:32,470
de frame enlazados entre sí.

721
00:45:32,470 --> 00:45:34,700
Y quiero pensar en ello como
el puntero al

722
00:45:34,700 --> 00:45:38,149
primero, porque una vez que tienes ese,

723
00:45:38,150 --> 00:45:39,400
los tienes a todos.

724
00:45:44,800 --> 00:45:44,995
¿Alguien más?

725
00:45:44,995 --> 00:45:47,799
¿Es posible evaluar
un procedimento o

726
00:45:47,800 --> 00:45:49,300
definir un procedimento
en dos entornos distinto de

727
00:45:49,300 --> 00:45:51,580
manera tal que se comporten
distinto, y que tener

728
00:45:51,580 --> 00:45:52,140
punteros a ambos--?

729
00:45:52,140 --> 00:45:53,600
Sí.

730
00:45:53,600 --> 00:45:55,259
El mismo procedimiento no va
a tener dos entornos

731
00:45:55,260 --> 00:45:57,290
diferentes.

732
00:45:57,290 --> 00:46:01,895
El mismo código, la misma expresión
lambda puede ser evaluada

733
00:46:01,895 --> 00:46:03,430
en dos entornos produciendo
dos procedimientos diferentes.

734
00:46:06,220 --> 00:46:07,140
Cada procedimiento --

735
00:46:07,140 --> 00:46:08,690
Su definición tiene el mismo nombre.

736
00:46:08,690 --> 00:46:09,170
Su operación --

737
00:46:09,170 --> 00:46:11,700
La definición se escriba igual, con

738
00:46:11,700 --> 00:46:12,570
los mismos caracteres.

739
00:46:12,570 --> 00:46:16,700
Puedo evaluar el conjunto
de caracteres, esa

740
00:46:16,700 --> 00:46:19,529
estructura de lista que define,
que es la representación

741
00:46:19,530 --> 00:46:21,340
textual.

742
00:46:21,340 --> 00:46:23,650
Puedo evaluar eso en dos
entornos diferentes

743
00:46:23,650 --> 00:46:25,650
produciendo dos procedimientos
diferentes.

744
00:46:25,650 --> 00:46:31,700
Cada uno de esos procedimientos
tiene su propio conjunto local

745
00:46:31,700 --> 00:46:33,490
de variables, y lo veremos ahora.

746
00:46:36,770 --> 00:46:38,200
¿Alguien más?

747
00:46:42,670 --> 00:46:43,280
Bien, gracias.

748
00:46:43,280 --> 00:46:44,530
Tomemos un descanso.

749
00:47:22,870 --> 00:47:26,670
Bueno, les hice algo
terrible.

750
00:47:26,670 --> 00:47:34,600
Introduje un cosa muy complicada, 
la asginación,

751
00:47:34,600 --> 00:47:36,680
que destruye la mayoría de las
propiedades matemáticas

752
00:47:36,680 --> 00:47:43,270
interesantes de nuestros programas.
¿Por que habré hecho esto?

753
00:47:43,270 --> 00:47:46,590
¿Qué bien podría hacer esto?

754
00:47:46,590 --> 00:47:52,490
Claramente no es algo lindo,
así que mejor que tenga una buena excusa.

755
00:47:52,490 --> 00:47:56,149
Bueno, juguemos un poco, 
para empezar, con unos

756
00:47:56,150 --> 00:47:58,870
muy interesantes programas que
usan asignación.

757
00:47:58,870 --> 00:48:02,000
Vamos a entender algo especial
sobre ellos que los hace

758
00:48:02,000 --> 00:48:04,820
valiosos de alguna forma.

759
00:48:04,820 --> 00:48:08,110
Empiezo con un programa muy
simple que voy a llamar

760
00:48:08,110 --> 00:48:10,670
'make-counter'.

761
00:48:10,670 --> 00:48:26,480
Voy a definirlo como un procedimiento

762
00:48:26,480 --> 00:48:31,280
de un arguemtno n que retorna
como su valor un

763
00:48:31,280 --> 00:48:34,390
procedimiento que no toma argumentos--

764
00:48:34,390 --> 00:48:36,839
un procedimiento que produce
un procedimiento ..

765
00:48:36,840 --> 00:48:48,600
Que setea n como el incremento
de n y retorna

766
00:48:48,600 --> 00:48:50,120
ese valor de n.

767
00:48:55,520 --> 00:48:57,560
Vamos a investigar el comportamiento
de esto.

768
00:48:57,560 --> 00:48:59,840
Es algo interesante.

769
00:48:59,840 --> 00:49:02,150
Para poder investiga el comportamiento,
voy a tener un modelo

770
00:49:02,150 --> 00:49:05,130
de entorno, porque no podemos
entenderlo

771
00:49:05,130 --> 00:49:06,380
de otra manera.

772
00:49:08,630 --> 00:49:10,400
Hagamos eso.

773
00:49:10,400 --> 00:49:13,500
Empezamos con una especie de --

774
00:49:13,500 --> 00:49:15,270
digamos que un entorno global
con el que nace

775
00:49:15,270 --> 00:49:16,240
la máquina.

776
00:49:16,240 --> 00:49:19,720
Lo llamaremos Global.

777
00:49:19,720 --> 00:49:24,529
Y va a tener un montón
de valores iniciales.

778
00:49:24,530 --> 00:49:25,820
Todos sabemos lo que tiene.

779
00:49:25,820 --> 00:49:32,930
Tiene cosas como más, y el producto

780
00:49:32,930 --> 00:49:39,330
y el cociente y la diferencia y CAR,

781
00:49:39,330 --> 00:49:42,960
etcétera, un montón de cosas.

782
00:49:42,960 --> 00:49:46,160
No sé lo que son, algunas cosas

783
00:49:46,160 --> 00:49:51,290
con los que nace la computadora.

784
00:49:51,290 --> 00:49:56,350
Y al hacer la definición aquí,
lo que planeo hacer --

785
00:49:56,350 --> 00:49:57,390
Bueno, ¿Qué estoy haciendo?

786
00:49:57,390 --> 00:49:59,779
Lo estoy haciendo relativo
a este entorno global.

787
00:49:59,780 --> 00:50:03,580
Así que aquí está mi puntero
de entorno.

788
00:50:03,580 --> 00:50:05,980
Para hacer eso tengo que
evaluar la expresión

789
00:50:05,980 --> 00:50:08,270
lambda.

790
00:50:08,270 --> 00:50:11,490
Eso quiere decir que hago
un objeto procedural.

791
00:50:11,490 --> 00:50:13,189
Así que voy a hacer un objeto
procedural aquí.

792
00:50:17,400 --> 00:50:21,430
Y el objeto procedural tiene
como el lugar donde está definido,

793
00:50:21,430 --> 00:50:23,819
el entorno global.

794
00:50:23,820 --> 00:50:29,880
El objeto procedural contiene
el código que representa el

795
00:50:29,880 --> 00:50:33,470
procedimiento de un argumento n
que retorna un procedimiento

796
00:50:33,470 --> 00:50:35,339
sin argumentos que hace algo.

797
00:50:38,320 --> 00:50:44,580
Y el define es una manera de 
cambiar el entorno,

798
00:50:44,580 --> 00:50:53,230
así que ahora le agrego el make-counter,
una regla especial

799
00:50:53,230 --> 00:50:55,470
para la cosa especial definida.

800
00:50:55,470 --> 00:50:59,810
Eso me da un

801
00:50:59,810 --> 00:51:03,840
puntero al procedimiento.

802
00:51:03,840 --> 00:51:06,370
Así que ahora el entorno global
contiene make-counter también.

803
00:51:09,330 --> 00:51:11,799
Vamos a hacer algunas operaciones.

804
00:51:11,800 --> 00:51:14,596
Voy a usar esto para hacer
contadores.

805
00:51:14,596 --> 00:51:17,140
Ya veremos lo que es un contador.

806
00:51:17,140 --> 00:51:26,700
Definamos c1 como un contador
que comienza en cero.

807
00:51:35,440 --> 00:51:39,660
Bueno, ya sabemos como hacer esto
ahora, de acuerdo al modelo.

808
00:51:39,660 --> 00:51:43,339
Tengo que evaluar la expresión
make-counter en el

809
00:51:43,340 --> 00:51:47,900
entorno global, make-counter de cero.

810
00:51:47,900 --> 00:51:50,785
Busco make-counter y observo
que es un procedimiento.

811
00:51:53,630 --> 00:51:56,100
Voy a tener que aplicar este 
procedimiento.

812
00:51:56,100 --> 00:51:59,820
La manera en que lo hago
es contruyendo un frame.

813
00:52:02,400 --> 00:52:12,300
Contruyo un frame que tiene un valor
para n en él, que es

814
00:52:12,300 --> 00:52:16,850
cero, y el entorno padre es 
el que es

815
00:52:16,850 --> 00:52:18,810
el entorno de definición
de make-counter.

816
00:52:23,890 --> 00:52:28,400
Así que creé un entorno 
al aplicar make-counter a cero.

817
00:52:31,580 --> 00:52:34,700
Ahora tengo que evaluar el cuerpo
de make-counter, que es

818
00:52:34,700 --> 00:52:37,455
una expresión lambda en ese entorno.

819
00:52:40,730 --> 00:52:43,770
Evaluando este cuerpo, 
este cuerpo es una expresión

820
00:52:43,770 --> 00:52:46,360
lambda.

821
00:52:46,360 --> 00:52:49,570
Evaluar una expresión lambda
significa crea un objeto procedural.

822
00:52:49,570 --> 00:52:50,820
Así que voy a hacer un objeto procedural.

823
00:52:56,840 --> 00:52:59,620
Y ese objeto procedural
tiene el entorno en el que

824
00:52:59,620 --> 00:53:07,656
fue definido, donde n
se definió como cero.

825
00:53:07,656 --> 00:53:11,370
Y tiene código, que es el
procedimiento sin argumentos

826
00:53:11,370 --> 00:53:17,622
que hace algo, que setea algo, 
y retorna n.

827
00:53:17,622 --> 00:53:22,680
Y esta cosa va a ser el objeto,
que en el entorno

828
00:53:22,680 --> 00:53:26,200
global tendrá el nombre c1.

829
00:53:26,200 --> 00:53:32,625
Así que construimos un nombre aquí, c1,
y decimos a qué es igual.

830
00:53:35,560 --> 00:53:50,790
Si también hago otro
contador c2, como make-counter

831
00:53:50,790 --> 00:53:53,868
digamos, empezando con 10.

832
00:53:53,868 --> 00:53:57,270
Entonces hago esencialmente lo mismo.

833
00:53:57,270 --> 00:53:59,910
Aplico el procedimiento make-counter,
que obtuve de aquí,

834
00:53:59,910 --> 00:54:05,690
para hacer otro frame con n igual a 10.

835
00:54:05,690 --> 00:54:10,500
Ese frame tiene al entorno global
como padre.

836
00:54:10,500 --> 00:54:16,750
Luego contruyo un procedimiento
que tiene eso como su frame

837
00:54:16,750 --> 00:54:18,000
de definición.

838
00:54:20,440 --> 00:54:23,240
Su código es el procedimiento
que no tiene argumento

839
00:54:23,240 --> 00:54:25,390
y que hace algo.

840
00:54:25,390 --> 00:54:28,700
Y hace un set! y así

841
00:54:28,700 --> 00:54:31,509
Y se devuelve n.

842
00:54:31,510 --> 00:54:36,950
Y c2 es este.

843
00:54:36,950 --> 00:54:38,779
Bueno, ya están empezando
a ver algo bastante

844
00:54:38,780 --> 00:54:40,200
interesante.

845
00:54:40,200 --> 00:54:42,879
Hay dos n's aquí.

846
00:54:42,880 --> 00:54:46,330
No son un n.

847
00:54:46,330 --> 00:54:49,310
Cada vez que llamé a make-counter
creé otra

848
00:54:49,310 --> 00:54:52,520
instancia de n.

849
00:54:52,520 --> 00:54:54,370
Estos son distintos y están
separados entre sí.

850
00:54:57,880 --> 00:55:00,783
Hagamos una ejecución,
usemos esos contadores.

851
00:55:00,783 --> 00:55:02,735
Voy a usar esos contadores.

852
00:55:05,990 --> 00:55:15,899
Bueno, ¿qué pasa si digo c1
en este punto?

853
00:55:15,900 --> 00:55:18,420
Bueno, voy aquí y veo

854
00:55:18,420 --> 00:55:20,840
que c1 es un procedimiento.

855
00:55:20,840 --> 00:55:23,490
Voy a llamar este procedimiento
sin argumentos, pero

856
00:55:23,490 --> 00:55:25,600
no tiene parámetros.

857
00:55:25,600 --> 00:55:27,200
Eso está bien.

858
00:55:27,200 --> 00:55:28,800
¿Cuál es su cuerpo?

859
00:55:28,800 --> 00:55:29,776
Bueno, tengo que mirar aquí,
porque no lo

860
00:55:29,776 --> 00:55:30,129
escribí.

861
00:55:30,130 --> 00:55:39,500
Seteaba n en n más uno y
retornaba n. Incrementa n.

862
00:55:39,500 --> 00:55:42,970
Bueno, el n que ve es este de aquí.

863
00:55:42,970 --> 00:55:45,490
Así que incremento este n.

864
00:55:45,490 --> 00:55:50,400
Se convierte en uno y luego
retorno el valor uno.

865
00:55:53,500 --> 00:55:58,220
Supongan que luego llamo a c2.

866
00:55:58,220 --> 00:55:59,819
¿Qué hago?

867
00:55:59,820 --> 00:56:03,600
c2 es el procedimiento 
que hace lo mismo, pero

868
00:56:03,600 --> 00:56:05,450
con este n.

869
00:56:05,450 --> 00:56:11,140
Se convierte en once.

870
00:56:11,140 --> 00:56:15,980
Y tengo un once que es el valor.

871
00:56:15,980 --> 00:56:18,130
Luego puedo probar c1 de nuevo.

872
00:56:21,580 --> 00:56:29,660
c1 es esto, que es dos,
así que la respuesta es dos.

873
00:56:29,660 --> 00:56:36,560
Y c2 me devuelve un doce, 
por el mismo método, yendo quí

874
00:56:36,560 --> 00:56:38,730
mirando eso y viendo que ese es
el n que está

875
00:56:38,730 --> 00:56:39,980
incrementando.

876
00:56:41,630 --> 00:56:44,920
Así que lo que tengo son
objetos computacionales.

877
00:56:44,920 --> 00:56:49,780
Son dos contadores, cada uno

878
00:56:49,780 --> 00:56:51,600
con su estado local independiente.

879
00:56:55,540 --> 00:56:56,650
Hablemos un poco de esto.

880
00:56:56,650 --> 00:56:58,510
Esto es algo extraño.

881
00:57:01,270 --> 00:57:04,140
¿Qué es un objeto?

882
00:57:04,140 --> 00:57:07,560
No es tan obvio qué es un objeto.

883
00:57:07,560 --> 00:57:11,720
Queremos pensar sobre objetos, porque es

884
00:57:11,720 --> 00:57:14,799
ecónomico pensar así.

885
00:57:14,800 --> 00:57:18,670
Es una economía intelectual.

886
00:57:18,670 --> 00:57:21,120
Yo soy un objeto.

887
00:57:21,120 --> 00:57:23,609
Tu eres un objeto.

888
00:57:23,610 --> 00:57:25,300
No somos el mismo objeto.

889
00:57:27,600 --> 00:57:32,315
Puedo dividir el mundo en dos partes,
tú y yo, y

890
00:57:32,315 --> 00:57:36,600
también hay otras cosas, tales que
la mayoría de las cosas que

891
00:57:36,600 --> 00:57:41,410
quisiera discutir sobre cómo funciono
no te involucran y

892
00:57:41,410 --> 00:57:43,790
tales que la mayoría de las cosas que
quisiera discutir sobre cómo funcionas

893
00:57:43,790 --> 00:57:45,750
no me involucran.

894
00:57:45,750 --> 00:57:50,990
Tengo una presión arterial, 
una temperatura, un ritmo

895
00:57:50,990 --> 00:57:56,899
de respiración, una cierta cantidad
de azúcar en mi sangre,

896
00:57:56,900 --> 00:57:59,400
y numerosas, miles, variables de
estado-- millones, de hecho.

897
00:57:59,400 --> 00:58:01,300
o no sé cuántas tengo--

898
00:58:01,300 --> 00:58:03,400
enormes números de variables
de estado en el sentido

899
00:58:03,400 --> 00:58:09,240
físico que representa mi estado
como partícula, y

900
00:58:09,240 --> 00:58:12,770
tú tienes un montón de ellas
también.

901
00:58:12,770 --> 00:58:17,290
Y la mayoría de las mías están
desacopladas de las tuyas.

902
00:58:17,290 --> 00:58:21,000
Así que podemos computar
mis propiedades

903
00:58:21,000 --> 00:58:23,940
sin preocuparnos demasiado
de las tuyas.

904
00:58:23,940 --> 00:58:26,310
Si tuviéramos que trabajar sobre
ambos juntos, entonces el

905
00:58:26,310 --> 00:58:28,460
número de estados que tenemos
que considerar es el producto de

906
00:58:28,460 --> 00:58:29,840
la cantidad de estados que tienes
y la cantidad de estados que

907
00:58:29,840 --> 00:58:32,760
tengo. Pero de esta forma 
es casi una suma.

908
00:58:32,760 --> 00:58:36,110
Ahora bien, en efecto, hay fuerzas que
nos acoplan.

909
00:58:36,110 --> 00:58:38,420
Te hablo y tu estado cambia.

910
00:58:38,420 --> 00:58:41,680
Te miro y mi estado cambia.

911
00:58:41,680 --> 00:58:45,900
Algunas de mis variables de estado,
algunas pocas de ellas, por lo tanto,

912
00:58:45,100 --> 00:58:46,190
están acopladas a las tuyas.

913
00:58:46,190 --> 00:58:48,470
Si de repente me gritaras muy fuerte,
mi presión arterial

914
00:58:48,470 --> 00:58:49,720
subiría.

915
00:58:54,320 --> 00:58:57,590
Quizá no siempre sea apropiado pensar

916
00:58:57,590 --> 00:59:00,360
al mundo como compuesto
por estados independientes y

917
00:59:00,360 --> 00:59:02,260
partículas independientes.

918
00:59:02,260 --> 00:59:05,350
Muchos de los bugs que ocurren
en cosas como mecánica cuántica,

919
00:59:05,350 --> 00:59:07,660
o los bugs en nuestras mentes
que ocurren cuando pensamos

920
00:59:07,660 --> 00:59:09,839
en cosas como mecánica cuántica,
se deben al hecho de que estamos

921
00:59:09,840 --> 00:59:11,910
tratando de pensar sobre cosas
particionándolas en

922
00:59:11,910 --> 00:59:15,879
piezas independientes, cuando
en realidad hay más acoplamiento

923
00:59:15,880 --> 00:59:19,750
del que vemos en la superficie, 
o del que queremos creer,

924
00:59:19,750 --> 00:59:22,300
porque queremos computar
eficiente y efectivamente.

925
00:59:22,300 --> 00:59:23,780
Fuimos entrenados 
para pensar así.

926
00:59:29,336 --> 00:59:31,439
Bueno, veamos.

927
00:59:31,440 --> 00:59:35,140
¿Cómo sabemos si tenemos
objetos?

928
00:59:35,140 --> 00:59:37,690
¿Cómo podemos saber si tenemos objetos?

929
00:59:37,690 --> 00:59:41,770
Consideremos algunas posibles
ilusiones ópticas

930
00:59:41,770 --> 00:59:44,805
con lo que podríamos hacerlo.

931
00:59:44,805 --> 00:59:47,970
Estos pedazos de tiza no son
apropiadamente idénticos, pero

932
00:59:47,970 --> 00:59:49,520
suponiendo que no pudieran
diferenciarlos solo con

933
00:59:49,520 --> 00:59:52,130
mirarlos.

934
00:59:52,130 --> 00:59:54,290
Bueno, existe la posibilidad
de que todo esto sea un juego

935
00:59:54,290 --> 00:59:55,725
con espejos.

936
00:59:55,725 --> 00:59:59,690
Quizá sea la misma pieza de tiza, pero

937
00:59:59,690 --> 01:00:01,660
ustedes están viendo dos.

938
01:00:01,660 --> 01:00:05,160
¿Cómo podrían saber si están viendo
una o dos?

939
01:00:05,160 --> 01:00:07,430
Bueno, sólo hay una forma
que yo conozca.

940
01:00:07,430 --> 01:00:10,109
Agarras una y la cambias 
y te fijas si la otra

941
01:00:10,110 --> 01:00:11,360
también cambió.

942
01:00:13,580 --> 01:00:16,180
Y no lo hizo, así que hay dos de ellas.

943
01:00:19,700 --> 01:00:20,890
Y, por otro lado, hay otras

944
01:00:20,890 --> 01:00:22,580
propiedades de las cosas
como esa.

945
01:00:22,580 --> 01:00:25,400
Como, ¿cómo sabemos si 
algo cambió?

946
01:00:25,400 --> 01:00:28,759
Tenemos que mirarlo antes
y después.

947
01:00:28,760 --> 01:00:32,200
El cambio es una asignación,
es un momento en el tiempo.

948
01:00:32,200 --> 01:00:34,120
Pero eso quiere decir que tenemos
que saber si es el mismo

949
01:00:34,120 --> 01:00:36,540
al que estamos mirando.

950
01:00:36,540 --> 01:00:39,270
Muy extraño e inusual y oscuro y---

951
01:00:39,270 --> 01:00:42,950
No entiendo los problemas
asociados con la

952
01:00:42,950 --> 01:00:47,379
asignación, el cambio y los objetos.

953
01:00:47,380 --> 01:00:51,420
Esto podría ponerse muy mal.

954
01:00:51,420 --> 01:00:56,250
Por ejemplo, aquí estoy, soy una
persona particular, un

955
01:00:56,250 --> 01:00:57,650
objeto particular.

956
01:00:57,650 --> 01:01:02,430
Ahora, puede sacar mi cuchillo,
y cortarme un uña.

957
01:01:02,430 --> 01:01:06,290
Un pedazo de mi uña ha caído
sobre la mesa.

958
01:01:06,300 --> 01:01:11,200
Creo que soy la misma persona que
hace unos segundos, pero no

959
01:01:11,200 --> 01:01:14,490
soy físicamente lo mismo en lo
absoluto.

960
01:01:14,490 --> 01:01:15,620
He cambiado.

961
01:01:15,620 --> 01:01:18,180
¿Por qué soy lo mismo?

962
01:01:18,180 --> 01:01:21,690
¿Cuál es mi identidad?

963
01:01:21,700 --> 01:01:22,320
No lo sé.

964
01:01:25,170 --> 01:01:29,770
Excepto por el hecho
de que tengo una identidad.

965
01:01:29,770 --> 01:01:34,770
Asi que,al introducir
asignaciones y objetos, nos

966
01:01:34,770 --> 01:01:37,670
hemos expuesto a todas
las horribles preguntas

967
01:01:37,670 --> 01:01:40,490
de filosofía que han plagado
a los filósofos por

968
01:01:40,490 --> 01:01:43,509
miles de años sobre estas cuestiones.

969
01:01:43,510 --> 01:01:45,880
Es la razón por la que las matemáticas
son mucho más prolijas.

970
01:01:45,880 --> 01:01:49,590
Veamos las mejores cosas que 
sé decir sobre acciones

971
01:01:49,590 --> 01:01:50,840
e identidad.

972
01:01:52,500 --> 01:01:56,500
Decimos que una accion a tuvo
un efecto en un objeto x,

973
01:01:56,500 --> 01:01:59,340
o equivalentemen que x fue
cambiado por a, si para

974
01:01:59,340 --> 01:02:02,410
alguna propiedad p, que era cierta
para x antes de a, se volvió

975
01:02:02,410 --> 01:02:05,100
falsa luego de a.

976
01:02:05,100 --> 01:02:07,750
Todavía significa que tenemos que tener

977
01:02:07,750 --> 01:02:10,950
el x antes y después.

978
01:02:10,950 --> 01:02:13,810
O la otra forma de decir esto es
decir que dos

979
01:02:13,810 --> 01:02:15,460
objetos x e y son los 
mismo si para cualquier acción

980
01:02:15,460 --> 01:02:19,580
que tiene un efecto en x, 
tiene el mismo efecto en y.

981
01:02:19,580 --> 01:02:22,230
Sin embargo, los objetos son
muy útiles, como dije, por

982
01:02:22,230 --> 01:02:24,650
economía intelectual.

983
01:02:24,650 --> 01:02:28,350
Una de las cosas que es increíblemente
útil sobre ellos,

984
01:02:28,350 --> 01:02:32,980
es que nos gusta pensar que el mundo
está compuesto de

985
01:02:32,980 --> 01:02:35,500
objetos independientes que tienen
estados locales independientes.

986
01:02:35,500 --> 01:02:36,430
Nos gusta pensar así, 
aunque no es

987
01:02:36,430 --> 01:02:39,730
completamente cierto.

988
01:02:39,730 --> 01:02:42,470
Cuando queremos hacer
programas muy complicados

989
01:02:42,470 --> 01:02:45,399
que lidian con ese mundo, si queremos
que esos programas

990
01:02:45,400 --> 01:02:49,700
se puedan entender por nosotros
y que se puedan cambiar, tal que si

991
01:02:49,700 --> 01:02:51,390
cambia el mundo cambiamos el 
programa sólo un poquito,

992
01:02:51,390 --> 01:02:53,810
entonces que haya conexiones, 
isomorfimos,

993
01:02:53,810 --> 01:02:56,130
entre los objetos en el mundo
y los objetos en nuestro

994
01:02:56,130 --> 01:02:58,720
modelo mental.

995
01:02:58,720 --> 01:03:00,959
La modularidad del mundo puede 
darnos la modularidad en

996
01:03:00,960 --> 01:03:02,400
nuestra programación.

997
01:03:02,400 --> 01:03:04,590
Así que creamos cosas llamadas
programación orientada a objetos

998
01:03:04,590 --> 01:03:09,950
y cosas así para que nos provean
ese poder.

999
01:03:09,950 --> 01:03:10,990
Pero es incluso más fácil.

1000
01:03:10,990 --> 01:03:12,310
Juguemos un pequeño juego.

1001
01:03:12,310 --> 01:03:15,110
Quiero jugar un pequeño
juego, mostrarles un ejemplo

1002
01:03:15,110 --> 01:03:19,610
más fácil donde la modularidad
se puede mejorar usando

1003
01:03:19,610 --> 01:03:22,960
la sentencia de asignación,
juiciosamente.

1004
01:03:22,960 --> 01:03:26,280
Una cosa que quiero hacerles
cumplir es que no

1005
01:03:26,280 --> 01:03:28,280
usen la asignación de la misma
manera que lo hacen en FORTRAN o

1006
01:03:28,280 --> 01:03:30,930
Basic o algo o Pascal, &gt;
para hacer las cosas que no

1007
01:03:30,930 --> 01:03:32,180
necesitan hacer con ella.

1008
01:03:34,200 --> 01:03:37,900
No es la manera correcta de pensar
para la mayoría de las cosas.

1009
01:03:37,100 --> 01:03:39,810
A vece es esencial, 
o quizá es esencial.

1010
01:03:39,810 --> 01:03:42,320
Veremos más sobre ello también.

1011
01:03:42,320 --> 01:03:44,330
Déjenme mostrarles un juego
divertido.

1012
01:03:47,270 --> 01:03:51,750
Existía un matemático
llamado Cesaro--

1013
01:03:51,750 --> 01:03:54,760
O Cesaro, Cesaro supongo que es --

1014
01:03:54,760 --> 01:03:58,450
que descubrió una manera inteligente
de computar pi.

1015
01:03:58,450 --> 01:04:06,319
Resulta que si tomo dos
números al azar, dos enteros

1016
01:04:06,320 --> 01:04:11,110
al azar y computo el máximo
común divisor, su

1017
01:04:11,110 --> 01:04:13,920
máximo común divisor o es uno
o no es uno.

1018
01:04:13,920 --> 01:04:15,445
Si es uno, no tiene divisores en
común.

1019
01:04:18,240 --> 01:04:21,600
Si su máximo común divisor
es uno --

1020
01:04:21,600 --> 01:04:23,590
la probabilidad de que dos números
al azar, dos números

1021
01:04:23,590 --> 01:04:26,910
elegidos al azar tengan a uno como
máximo común divisor está

1022
01:04:26,910 --> 01:04:29,580
relacionado con pi.

1023
01:04:29,580 --> 01:04:31,310
De hecho--

1024
01:04:31,310 --> 01:04:33,700
Sí, es muy extraño--

1025
01:04:33,700 --> 01:04:34,980
Por supuesto que hay otras
maneras de computar a pi, como

1026
01:04:34,980 --> 01:04:38,100
soltando alfileres en banderas, o
algo por el estilo, que son

1027
01:04:38,100 --> 01:04:40,110
casi la misma cosa.

1028
01:04:40,110 --> 01:04:48,510
Así que la probabilidad de que el MCD
de dos números,

1029
01:04:48,510 --> 01:04:55,660
dos números elegidos al azar,
es 6 dividido pi al cuadrado.

1030
01:04:55,660 --> 01:04:57,240
No voy a tratar de proba eso.

1031
01:04:57,240 --> 01:05:01,120
De hecho, no es tan difícil
y un poco divertido.

1032
01:05:01,120 --> 01:05:03,589
¿Cómo estimaríamos esa
probabilidad?

1033
01:05:03,590 --> 01:05:07,340
Bueno, la manera de hacerlo, 
la manera de estimar probabilidades,

1034
01:05:07,340 --> 01:05:09,620
es haciendo un montón 
de experimentos y luego

1035
01:05:09,620 --> 01:05:12,259
computar la proporción
de unos que aparecen

1036
01:05:12,260 --> 01:05:13,570
en la cantidad total de experimentos
que hacemos.

1037
01:05:16,320 --> 01:05:19,680
Se llama Monte Carlo, y es útil
en otros contextos

1038
01:05:19,680 --> 01:05:21,279
como calcular integrales donde 
hay muchas

1039
01:05:21,280 --> 01:05:22,960
variables --

1040
01:05:22,960 --> 01:05:24,780
El espacio que limita las dimensiones
donde estás

1041
01:05:24,780 --> 01:05:26,360
integrando.

1042
01:05:26,360 --> 01:05:34,680
Pero volviendo aquí, miremos 
esta diapositiva. Podemos usar

1043
01:05:34,680 --> 01:05:40,520
el método de Cesaro para estimar
pi con n pruebas tomando

1044
01:05:40,520 --> 01:05:45,850
la raíz cuadrada de seis 
sobre un experimento

1045
01:05:45,850 --> 01:05:51,410
Monte Carlo de n pruebas, 
usando el experimento de Cesaro.

1046
01:05:51,410 --> 01:05:56,549
Donde el experimento de Cesaro es probar
si el el MCD de

1047
01:05:56,550 --> 01:05:59,700
dos números al azar--

1048
01:05:59,700 --> 01:06:01,200
Y pueden ver que tengo
algunas asignaciones

1049
01:06:01,200 --> 01:06:03,990
sólo por lo que escribí.

1050
01:06:03,990 --> 01:06:07,930
El hecho de que esta palabra rand
en paréntesis y que, por lo tanto,

1051
01:06:07,930 --> 01:06:11,529
es una llamada a un procedimiento, tiene
un valor diferente que esta otra,

1052
01:06:11,530 --> 01:06:13,330
al menos eso es lo que estoy asumiendo
al escibir esto de esta

1053
01:06:13,330 --> 01:06:18,590
forma, me indica que no es una función,
que hay un

1054
01:06:18,590 --> 01:06:20,400
estado interno que está cambiando.

1055
01:06:25,110 --> 01:06:28,530
Si el MCD entre estos dos números
al azara es igual a uno,

1056
01:06:28,530 --> 01:06:31,530
ese es el experimento.

1057
01:06:31,530 --> 01:06:34,330
Así que aquí tengo un método
experimental para estimar el

1058
01:06:34,330 --> 01:06:36,560
valor de pi.

1059
01:06:36,560 --> 01:06:40,160
Donde puedo dividir este problema
en dos partes.

1060
01:06:40,160 --> 01:06:43,609
Una es el experimento Monte Carlo
de Cesaro específico,

1061
01:06:43,610 --> 01:06:46,700
que recién vieron, y la otra es la técnica
general para

1062
01:06:46,700 --> 01:06:49,319
hacer experimentos Monte Carlo.

1063
01:06:49,320 --> 01:06:51,190
Y esto es lo que es esto.

1064
01:06:51,190 --> 01:06:55,930
Si quiero hacer experimentos
Monte Carlo con n pruebas, una

1065
01:06:55,930 --> 01:06:59,589
cierta cantidad de pruebas, y un
experimento particular,

1066
01:06:59,590 --> 01:07:03,460
la manera de hacerlo es mediante un
procedimiento iterativo

1067
01:07:03,460 --> 01:07:05,960
que tiene como variable la
cantidad de pruebas restantes

1068
01:07:05,960 --> 01:07:10,230
y la cantidad de prueba que se pasaron,
que fueron verdaderas.

1069
01:07:10,230 --> 01:07:13,100
Y si la cantidad restante es cero, 
entonces la respuesta es la cantidad

1070
01:07:13,100 --> 01:07:16,260
de veces que se pasó dividido el
número de pruebas, que

1071
01:07:16,260 --> 01:07:19,150
es la estimación de la 
probabilidad.

1072
01:07:19,150 --> 01:07:22,140
Y si no lo es, entonces tengo
que hacer más pruebas,

1073
01:07:22,140 --> 01:07:22,870
así que hagamos una.

1074
01:07:22,870 --> 01:07:23,859
Hacemos un experimento.

1075
01:07:23,860 --> 01:07:27,350
Llamamos al procedimiento
que es 'experiment' sin argumentos.

1076
01:07:27,350 --> 01:07:30,870
Hacemos el experimento y luego,
si eso fue verdaedero,

1077
01:07:30,870 --> 01:07:33,830
volvemos al ciclo
decrementando el número

1078
01:07:33,830 --> 01:07:36,560
de experimentos que tengo que hacer
e incrementando la

1079
01:07:36,560 --> 01:07:38,650
cantidad de los que lo pasaron.

1080
01:07:38,650 --> 01:07:41,880
Y si el experimento fue falso,
volvemos al ciclo

1081
01:07:41,880 --> 01:07:44,700
decrementando el número
de experimentos restantes y

1082
01:07:44,700 --> 01:07:48,910
dejando el mismo número
de pasados.

1083
01:07:48,910 --> 01:07:51,319
Empezamos esto iterando
sobre el número total

1084
01:07:51,320 --> 01:07:55,840
de prueba con cero experimentos
exitosos. Un pequeño

1085
01:07:55,840 --> 01:07:57,730
y elegante programa.

1086
01:07:57,730 --> 01:08:00,530
No tengo que hacer solo esto
con el experimento de Cesaro,

1087
01:08:00,530 --> 01:08:03,390
podría hacer un montón de experimentos
Monte Carlo.

1088
01:08:03,390 --> 01:08:05,859
Por supuesto, esto depende de 
la existencia de alguna especie

1089
01:08:05,860 --> 01:08:07,440
de generador de número aleatorios.

1090
01:08:07,440 --> 01:08:09,960
Y los generadores de números
aleatorios en general

1091
01:08:09,960 --> 01:08:11,210
se ven así.

1092
01:08:13,570 --> 01:08:17,550
Este es un generador de
números aleatorios--

1093
01:08:17,550 --> 01:08:24,490
es, de hecho, un procedimiento
que va a hacer algo

1094
01:08:24,490 --> 01:08:25,710
como el contador.

1095
01:08:25,710 --> 01:08:30,870
Va a actualizar un x con el
resultado de aplicarle alguna

1096
01:08:30,870 --> 01:08:34,599
función a x, donde esta función
es una que

1097
01:08:34,600 --> 01:08:38,800
podrían hallar en los libros
de Knuth sobre los

1098
01:08:38,800 --> 01:08:41,689
detalles de la programación.

1099
01:08:41,689 --> 01:08:45,200
Él hace estos maravillosos libros
que están llenos de detalles

1100
01:08:45,200 --> 01:08:47,500
de programación, porque no puedo
recordar como hacer un

1101
01:08:47,500 --> 01:08:50,156
generador de números al azar,
pero lo puedo buscar allí

1102
01:08:50,156 --> 01:08:51,720
y averiguarlo.

1103
01:08:51,720 --> 01:08:54,850
Y luego, eventualmente, retorno
el valor de x que es la variable

1104
01:08:54,850 --> 01:08:58,319
de estado interna al generador
de números aleatorios.

1105
01:08:58,319 --> 01:09:00,140
La variable de estado
se inicializa

1106
01:09:00,140 --> 01:09:03,479
de alguna manera y tiene un valor.

1107
01:09:03,479 --> 01:09:06,490
Y el procedimiento se define en 
el contexto donde

1108
01:09:06,490 --> 01:09:10,450
esa variable está ligada.

1109
01:09:10,450 --> 01:09:15,929
Así que esta es una pieza oculta
de estado local que ven aquí.

1110
01:09:15,930 --> 01:09:21,720
Y este procedimiento
está definido en ese contexto.

1111
01:09:21,720 --> 01:09:24,103
Ahora bien, esa es una cosa muy simple
de hacer.

1112
01:09:24,103 --> 01:09:26,200
Y es muy linda.

1113
01:09:26,200 --> 01:09:29,800
Supongan que no quiero
usar asignaciones.

1114
01:09:29,800 --> 01:09:30,818
Supongan que quisiera escribir este
programa sin

1115
01:09:30,819 --> 01:09:32,840
asignaciones.

1116
01:09:32,840 --> 01:09:35,580
¿Qué problemas tendría?

1117
01:09:35,580 --> 01:09:37,890
Bueno, veamos.

1118
01:09:37,890 --> 01:09:44,540
Quisiera usar el 
retroproyector, gracias.

1119
01:09:44,540 --> 01:09:45,870
Primero, veamos todo completo.

1120
01:09:45,870 --> 01:09:48,140
Es una gran historia.

1121
01:09:48,140 --> 01:09:51,720
Desafortunamente te dice que
algo está mal.

1122
01:09:51,720 --> 01:09:54,255
Es tan grande y es monolítico.

1123
01:09:57,200 --> 01:09:59,580
No tiene que entenderlo o mirar
el texto aquí

1124
01:09:59,580 --> 01:10:02,120
para ver que es monolítico.

1125
01:10:02,120 --> 01:10:05,900
No es una cosa que sea el
experimento de Cesaro.

1126
01:10:05,900 --> 01:10:10,500
No se separa del proceso
de Monte Carlo.

1127
01:10:10,500 --> 01:10:10,890
No están separados.

1128
01:10:10,890 --> 01:10:12,140
Veamos porqué.

1129
01:10:14,350 --> 01:10:19,330
Recuerden que la restricción aquí
que cada procedimiento retorna

1130
01:10:19,330 --> 01:10:23,700
el mismo valor para los mismos
argumentos.

1131
01:10:23,700 --> 01:10:26,799
Cada procedimiento representa
una función.

1132
01:10:26,800 --> 01:10:28,275
Esa es otra restricción distinta.

1133
01:10:28,275 --> 01:10:30,250
Porque cuando tengo asignaciones, 
puedo cambiar el

1134
01:10:30,250 --> 01:10:31,840
estado interno de alguna variable.

1135
01:10:31,840 --> 01:10:35,600
Veamos como eso hacer que las
cosas vayan mal.

1136
01:10:35,600 --> 01:10:38,510
Bueno, empecemos por el
principio.

1137
01:10:38,510 --> 01:10:42,950
La estimación de pi se
ve parecida.

1138
01:10:42,950 --> 01:10:47,559
Lo que estoy haciendo es tomar
la raíz cuadrada de seis sobre

1139
01:10:47,560 --> 01:10:52,990
la prueba de MCD aleatoria aplicada a n,
y esto es lo que es.

1140
01:10:52,990 --> 01:10:55,389
Pero aquí, las cosas comienzan
a verse raras.

1141
01:10:55,390 --> 01:10:58,770
La prueba de MCD aleatoria con
una cierta cantida de pruebas

1142
01:10:58,770 --> 01:11:03,400
es como la que teníamos antes,
una iteración en el número de pruebas

1143
01:11:03,400 --> 01:11:06,210
restantes, el número de pruebas
exitosas

1144
01:11:06,210 --> 01:11:10,870
y otra variable x.

1145
01:11:10,870 --> 01:11:12,370
¿Qué es esa x?

1146
01:11:12,370 --> 01:11:14,950
Esa x es el estado del 
generador de números aleatorios.

1147
01:11:18,950 --> 01:11:21,150
Y será usada aquí.

1148
01:11:21,150 --> 01:11:23,889
La función función actualizador
que tengo aquí

1149
01:11:23,890 --> 01:11:25,890
es la misma que usaría en
el generador de números aleatorios

1150
01:11:25,890 --> 01:11:28,510
si lo estuviera construyendo
de la otra manera, el que obtengo

1151
01:11:28,510 --> 01:11:31,710
de los libros de Knuth.

1152
01:11:31,710 --> 01:11:33,380
x será transformado en x1,

1153
01:11:33,380 --> 01:11:34,950
necesito dos números aleatorios,

1154
01:11:34,950 --> 01:11:37,630
y x1 será transformado en x2, y ahora

1155
01:11:37,630 --> 01:11:39,550
tengo dos números aleatorios.

1156
01:11:39,550 --> 01:11:42,620
Luego tengo que hacer exactamente
lo que hice antes.

1157
01:11:42,620 --> 01:11:43,870
Tomo el MCD de x1 y x2.

1158
01:11:43,870 --> 01:11:48,260
Si es uno, vuelvo al ciclo
con x2 como el

1159
01:11:48,260 --> 01:11:49,520
siguiente valor de x.

1160
01:11:54,850 --> 01:11:57,740
Verán que lo que paso aquí
es que el estado del

1161
01:11:57,740 --> 01:12:00,480
generador de números aleatorios
no está confinado al interior

1162
01:12:00,480 --> 01:12:01,495
del generador de números
aleatorios.

1163
01:12:01,495 --> 01:12:03,450
Se filtró.

1164
01:12:03,450 --> 01:12:09,240
Se filtró a mi procedimiento
que hace el experimento

1165
01:12:09,240 --> 01:12:10,719
Monte Carlo.

1166
01:12:10,720 --> 01:12:13,480
Pero lo que es peor que eso, es
que también, como estaba

1167
01:12:13,480 --> 01:12:17,469
contenido dentro del experimento,
Cesaro, también se filtró

1168
01:12:17,470 --> 01:12:18,900
de eso.

1169
01:12:18,900 --> 01:12:21,920
Como Cesaro se llamó dos veces, 
y tiene que tener un valor diferente

1170
01:12:21,920 --> 01:12:24,780
cada vez, si voy a tener un
experimento legítimo.

1171
01:12:24,780 --> 01:12:31,910
Así que Cesaro tampoco puede
ser una función, a menos que le pase

1172
01:12:31,910 --> 01:12:34,730
una semilla para el generador
de números aleatorios, que

1173
01:12:34,730 --> 01:12:36,490
va a estar rondando por allí.

1174
01:12:36,490 --> 01:12:39,740
Así que desafortunadamente, la semilla 
del generador de números aleatorios

1175
01:12:39,740 --> 01:12:42,849
se filtró hacia Cesaro, desde el
generador de números aleatorios y

1176
01:12:42,850 --> 01:12:45,465
eso se filtra hacia el experimento
Monte Carlo.

1177
01:12:45,465 --> 01:12:48,485
Y desafortunadamente, mi experimento
de Monte Carlo de aquí ya no

1178
01:12:48,485 --> 01:12:50,309
es general.

1179
01:12:50,310 --> 01:12:52,990
El experimento de Monte Carlo aquí
conoce cuántos números

1180
01:12:52,990 --> 01:12:54,405
aleatorios necesito para hacer
el experimento.

1181
01:12:58,530 --> 01:13:00,230
Eso es horrible

1182
01:13:00,230 --> 01:13:04,890
Perdí la habilidad de descomponer
el problema en partes, porque

1183
01:13:04,900 --> 01:13:10,720
no estaba dispuesto a aceptar
el pequeño ciclo de información,

1184
01:13:10,720 --> 01:13:14,720
el proceso de retroalimentación
que ocurre dentro del generador

1185
01:13:14,720 --> 01:13:18,000
de números aleatorios de antes,
que estaba hecho teniendo

1186
01:13:18,000 --> 01:13:20,400
una asignación a una variable de
estadoque estaba confinada al

1187
01:13:20,400 --> 01:13:22,769
generador de números aleatorios.

1188
01:13:22,770 --> 01:13:26,700
El hecho de que el generador
de números aleatorios es un objeto,

1189
01:13:26,700 --> 01:13:29,400
con una variable de estado interna,
no está afectado por nada,

1190
01:13:29,400 --> 01:13:30,595
pero te devolverá algo,

1191
01:13:30,595 --> 01:13:34,290
y aplicará su fuerza sobre tí, eso 
es lo que hemos perdido.

1192
01:13:38,140 --> 01:13:42,870
Bueno, creo que vimos
suficientes razones para hacer esto,

1193
01:13:42,870 --> 01:13:45,510
y todo se ve maravilloso.

1194
01:13:45,510 --> 01:13:51,840
¿No sería lindo que la asignación
fuera algo bueno?

1195
01:13:51,840 --> 01:13:55,440
Quizá sea valiosa, pero no estoy seguro.

1196
01:13:55,440 --> 01:13:57,860
Como los señores Gilbert y Sullivan
dijeron, las cosas raramente

1197
01:13:57,860 --> 01:14:01,940
son lo que parecen, leche desnatada
enmascarada como crema.

1198
01:14:01,940 --> 01:14:03,655
¿Alguna pregunta?

1199
01:14:17,100 --> 01:14:20,120
¿Hay algún filósofo aquí?

1200
01:14:20,120 --> 01:14:21,930
¿Alguien quiere discutir sobre objetos?

1201
01:14:24,590 --> 01:14:25,840
Están agotados, ¿verdad?

1202
01:14:29,840 --> 01:14:30,805
Y ni siquiera han hecho su tarea.

1203
01:14:30,805 --> 01:14:32,550
No se les ha ocurrido ninguna
buena pregunta.

1204
01:14:36,790 --> 01:14:38,400
Bien.

1205
01:14:40,110 --> 01:14:41,120
Seguro, gracias.

1206
01:14:41,120 --> 01:14:42,370
Tomemos el descanso largo ahora.
