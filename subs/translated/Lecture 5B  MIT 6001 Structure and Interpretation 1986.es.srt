1
00:00:21,170 --> 00:00:24,550
Bueno, ahora que les hemos dado
algo de poder para

2
00:00:24,550 --> 00:00:28,340
hacer estados locales independientes
y para modelar objetos,

3
00:00:28,340 --> 00:00:31,610
pienso en que hagamos un poco
de programación de un tipo

4
00:00:31,610 --> 00:00:35,380
muy complicado, sólo para
ilustrarles lo que pueden hacer

5
00:00:35,380 --> 00:00:36,630
con este tipo de cosas.

6
00:00:40,430 --> 00:00:44,800
Supongo, como dije antes, que estamos
motivos por sistemas físicos

7
00:00:44,800 --> 00:00:47,199
y la manera en que nos gustan pensar
sobre sistemas físicos es en que

8
00:00:47,200 --> 00:00:52,600
son estas cosas de las que
está compuesto el mundo.

9
00:00:52,600 --> 00:00:55,570
Y cada una de estas cosas tiene
un estado local independiente,

10
00:00:55,570 --> 00:00:58,830
y por lo tanto, es una cosa.

11
00:00:58,830 --> 00:01:01,280
Eso es lo que lo hace una cosa.

12
00:01:01,280 --> 00:01:04,410
Y luego vamos a decir que
en el modelo--

13
00:01:04,410 --> 00:01:07,899
tenemos un mundo y un modelos
en nuestras mentes y en las

14
00:01:07,900 --> 00:01:10,940
computadoras de ese mundo.

15
00:01:10,940 --> 00:01:13,230
Y lo quiero hacer es una correspondencia
entre los

16
00:01:13,230 --> 00:01:15,980
objetos del mundo real y los objetos
de la computadora, la

17
00:01:15,980 --> 00:01:18,140
relación entre los objetos en el mundo
y la

18
00:01:18,140 --> 00:01:21,200
relación entres esos mismos obj--
los objetos del modelo en

19
00:01:21,200 --> 00:01:24,890
la computadora, y las funciones que
relacionan cosas

20
00:01:24,890 --> 00:01:27,320
en el mundo con las funciones
que relacionan

21
00:01:27,320 --> 00:01:28,570
cosas en la computadora.

22
00:01:30,840 --> 00:01:34,740
Esto no provee modularidad.

23
00:01:34,740 --> 00:01:37,786
Si realmente creemos que el mundo
es así, que está compuesto

24
00:01:37,786 --> 00:01:40,120
de pequeñas piezas, y por supuesto,
podemos organizar

25
00:01:40,120 --> 00:01:43,850
nuestro mundo para que así sea,
sólo podríamos modelar las cosas

26
00:01:43,850 --> 00:01:47,290
que sona así, entonces podríamos
heredar la modularidad

27
00:01:47,300 --> 00:01:50,450
del mundo en nuestra programación.

28
00:01:50,450 --> 00:01:53,150
Esa es la razón por la que inventaríamos
algo de esta programación orientada

29
00:01:53,150 --> 00:01:55,420
a objetos.

30
00:01:55,420 --> 00:01:58,890
Bueno, tomemos los mejores
tipos de objetos que conozco.

31
00:01:58,890 --> 00:02:03,160
Son completamente -- son completamente
maravillosos:

32
00:02:03,160 --> 00:02:10,270
los sistemas eléctricos. Los sistemas 
eléctricos realmente son los

33
00:02:10,270 --> 00:02:14,220
mejores objetos del físico.

34
00:02:14,220 --> 00:02:16,760
Pueden ver aquí que tengo una especie
de maquinaria.

35
00:02:16,760 --> 00:02:20,400
Aquí hay una especie de maquinaria.

36
00:02:20,400 --> 00:02:24,269
Y tiene un cable eléctrico
que conecta una parte

37
00:02:24,270 --> 00:02:27,190
de la maquinaria con otra
parte de la maquinaria.

38
00:02:27,190 --> 00:02:30,450
Y una de las propiedades maravillosas
del mundo

39
00:02:30,450 --> 00:02:34,609
eléctrico es que puedo decir
que esto es un objeto y que esto

40
00:02:34,610 --> 00:02:36,400
es un objeto. Y ellos están --

41
00:02:36,400 --> 00:02:38,310
La conexión entre ellos es clara.

42
00:02:38,310 --> 00:02:41,190
No hay ninguna conexión entre ellos

43
00:02:41,190 --> 00:02:44,740
que no describí.

44
00:02:44,740 --> 00:02:48,000
Digamos que si tuviera lamparitas,
una lámpara y un fuente

45
00:02:48,000 --> 00:02:51,370
de corriente que estuviera enchufada
en el enchufe.

46
00:02:51,370 --> 00:02:53,620
Entonces la conexión en perfectamente
clara.

47
00:02:53,620 --> 00:02:56,220
No hay otras conexiones que sepamos.

48
00:02:56,220 --> 00:02:59,250
Si fuera a atar un nudo con el cable
que conecta la

49
00:02:59,250 --> 00:03:04,400
lámpara con la corriente eléctrica, 
la luz seguiría encendida.

50
00:03:04,400 --> 00:03:05,290
No le importa.

51
00:03:08,300 --> 00:03:11,120
La manera en que la física está
organizada es tal que

52
00:03:11,120 --> 00:03:13,790
la conexión puede abstraerse
al menos para frecuencias

53
00:03:13,790 --> 00:03:15,269
bajas y cosas así.

54
00:03:17,840 --> 00:03:20,360
Así que, de hecho, hemos capturado
todas las conexiones que

55
00:03:20,360 --> 00:03:22,350
existen.

56
00:03:22,350 --> 00:03:24,310
Bueno, podemos ir un paso
más allá y hablar

57
00:03:24,310 --> 00:03:27,830
de los los sistemas eléctricos
más abstractos que tenemos,

58
00:03:27,830 --> 00:03:30,951
los circuitos digitales.

59
00:03:30,951 --> 00:03:34,609
Y aquí hay ciertos tipos
de objetos.

60
00:03:34,610 --> 00:03:38,240
Por ejemplo, en circuitos
digitales

61
00:03:38,240 --> 00:03:41,920
tenemos cosas como inversores.

62
00:03:41,920 --> 00:03:43,990
Tenemos cosas como compuertas AND.

63
00:03:43,990 --> 00:03:47,210
Tenemos cosas como compuertas OR.

64
00:03:47,210 --> 00:03:53,980
Las conectamos entre sí por
una especie de cable que representan

65
00:03:53,980 --> 00:03:55,609
señales abstractas.

66
00:03:55,610 --> 00:03:57,390
No nos interesan como variables
físico si

67
00:03:57,390 --> 00:04:00,190
estos son voltajes o corrientes o
alguna combinación

68
00:04:00,190 --> 00:04:05,160
de algo parecido, o agua, 
presión de agua.

69
00:04:05,160 --> 00:04:09,420
Estas variables abstractas
representan ciertas señales.

70
00:04:09,420 --> 00:04:11,950
Y construimos sistemas
cableando estas cosas

71
00:04:11,950 --> 00:04:14,700
juntas con cables.

72
00:04:14,700 --> 00:04:17,730
Así que hoy lo que les voy mostrar,
ahora mismo, es que vamos

73
00:04:17,730 --> 00:04:22,650
a construir a construir un lenguaje
inventado en Lisp, integrado

74
00:04:22,650 --> 00:04:24,590
en el mismo sentido que el 
lenguaje de imágenes de Henderson

75
00:04:24,590 --> 00:04:29,780
lo estaba, que no es de la misma 
manera en que el lenguaje de

76
00:04:29,780 --> 00:04:32,700
pattern match y sustitución 
se hizo ayer.

77
00:04:32,700 --> 00:04:35,724
El lenguaje de pattern 
match y sustitución estaba interpretado

78
00:04:35,725 --> 00:04:38,160
por un programa Lisp.

79
00:04:38,160 --> 00:04:40,920
Para la integración del lenguaje
de Henderson era que

80
00:04:40,920 --> 00:04:43,370
construíamos más y más
procedimientos que encapsulaban

81
00:04:43,370 --> 00:04:45,480
la estructura que queríamos.

82
00:04:45,480 --> 00:04:49,280
Por ejemplo, voy a tener 
varios tipos de objetos

83
00:04:49,280 --> 00:04:53,250
primitivos, como pueden ver,
ese y ese.

84
00:04:53,260 --> 00:04:55,810
Voy a usar cables para combinarlos.

85
00:04:55,810 --> 00:04:58,420
La manera en que represento
la adherencia --

86
00:04:58,420 --> 00:04:59,870
Puedo hacer cables.

87
00:04:59,870 --> 00:05:01,740
Asi que digamos que A es un cable.

88
00:05:01,740 --> 00:05:02,690
Y B es un cable.

89
00:05:02,690 --> 00:05:03,460
Y C es un cable.

90
00:05:03,460 --> 00:05:04,229
Y D es un cable.

91
00:05:04,230 --> 00:05:04,830
Y E es un cable.

92
00:05:04,830 --> 00:05:06,880
Y S es un cablle.

93
00:05:06,880 --> 00:05:12,380
Bueno, una compuerta OR que tiene dos
entradas, siendo A y

94
00:05:12,380 --> 00:05:17,940
B, y una salida Y o D, se nota así.

95
00:05:17,940 --> 00:05:22,390
Una compuerta AND, con entradas
A y B y salida C, se

96
00:05:22,390 --> 00:05:24,820
nota así.

97
00:05:24,820 --> 00:05:29,690
Al hacer una tal secuencia de 
declaraciones, como estas, puedo

98
00:05:29,690 --> 00:05:32,750
cablear un circuito arbitrario.

99
00:05:32,750 --> 00:05:35,940
Así que le di un conjunto
de primitivas y medios

100
00:05:35,940 --> 00:05:40,930
de combinación para cuanconstruir
circuitos digitales. Lo que más

101
00:05:40,930 --> 00:05:43,690
necesito en un lenguaje real
es abstracción.

102
00:05:43,690 --> 00:05:46,766
Así que por ejemplo, aquí tengo--

103
00:05:46,766 --> 00:05:52,240
Tengo medio sumador.

104
00:05:52,240 --> 00:05:54,270
Es algo que todos conocen

105
00:05:54,270 --> 00:05:56,930
si hicieron algún diseño digital.

106
00:05:56,930 --> 00:06:00,830
Se usa para sumar números en A y en B

107
00:06:00,830 --> 00:06:03,955
y retornarn la suma y un carry.

108
00:06:03,956 --> 00:06:05,710
Y de hecho, el diagrama de cableado es

109
00:06:05,710 --> 00:06:07,450
exactamente lo que les dije.

110
00:06:07,450 --> 00:06:11,409
Un medio sumador con cosas
que salen de la caja -- ven

111
00:06:11,410 --> 00:06:14,790
la caja, los límites, la abstracción
es siempre la caja.

112
00:06:14,790 --> 00:06:19,700
Y hay cosas que salen de ellas,
A, B, S y C.

113
00:06:19,700 --> 00:06:24,950
Esas son las variables declaradas--
variables declaradas

114
00:06:24,950 --> 00:06:27,200
de una expresión lambda, que es
la que define

115
00:06:27,200 --> 00:06:28,270
al medio sumador.

116
00:06:31,400 --> 00:06:36,800
E internamente, creo más cables, 
D y E,

117
00:06:36,800 --> 00:06:37,760
que voy a usar para interconectar//

118
00:06:37,760 --> 00:06:41,860
E es este y D es este cable, 
la interconexión

119
00:06:41,860 --> 00:06:45,100
que no sale por las paredes
de la caja --

120
00:06:45,100 --> 00:06:48,790
y cablea cosas juntas como vieron.

121
00:06:48,790 --> 00:06:51,180
Y lo lindo de esto que les he
mostrado es que

122
00:06:51,180 --> 00:06:53,890
este lenguaje es jerárquico
en la manera correcta.

123
00:06:53,890 --> 00:06:55,950
Si un lenguaje no es jerárquico
en la manera correcta,

124
00:06:55,950 --> 00:06:58,849
si resulta que un objeto
compuesto no se ve

125
00:06:58,850 --> 00:07:00,820
como una primitiva, entonces hay algo

126
00:07:00,820 --> 00:07:02,180
mal con el lenguaje --

127
00:07:02,180 --> 00:07:06,300
Por lo menos es la manera 
en que lo siento.

128
00:07:06,300 --> 00:07:09,220
Así que aquí tenemos, en vez de 
comenzar con funciones

129
00:07:09,220 --> 00:07:10,900
matemáticas, o cosas que 
computan funciones

130
00:07:10,900 --> 00:07:13,870
matemáticas, que es lo que
estuvimos haciendo hasta ahora,

131
00:07:13,870 --> 00:07:15,770
en vez de comenzar con coas
que se ven

132
00:07:15,770 --> 00:07:18,800
como funciones matemáticas, o
que computen cosas así,

133
00:07:18,800 --> 00:07:21,330
comenzamos con cosas que son
objetos eléctricos y

134
00:07:21,330 --> 00:07:23,349
construímos más objetos
eléctricos.

135
00:07:23,350 --> 00:07:26,590
Y el pegamento que estamos
usando es básticamente

136
00:07:26,590 --> 00:07:30,500
la estructura Lisp: lambdas.

137
00:07:30,500 --> 00:07:32,930
Es es el pegamento definitivo,
por así decirlo.

138
00:07:32,930 --> 00:07:39,000
Y, por supuesto, el medio sumador
puede ser usado en una

139
00:07:39,000 --> 00:07:42,250
abstracción más complicada
llamada sumador completo, que

140
00:07:42,250 --> 00:07:46,670
de hecho involucra dos medio
sumadores, conectados

141
00:07:46,670 --> 00:07:50,600
entre sí con unos cables extra, 
como ven aquí, S, C1 y C2,

142
00:07:50,600 --> 00:07:57,340
y una compuerta OR, para crear
un sumador completo, que toma

143
00:07:57,340 --> 00:08:01,570
dos números como entrada
un carry de entrada y

144
00:08:01,570 --> 00:08:05,900
produce una salida, una suma
y un carry.

145
00:08:05,900 --> 00:08:09,820
Y a partir de sumadores completos
pueden hacer cadenas de sumadores y

146
00:08:09,820 --> 00:08:12,990
grandes sumadores.

147
00:08:12,990 --> 00:08:18,870
Así que hasta hora tenemos
un lenguaje que tiene primitivas

148
00:08:18,870 --> 00:08:22,270
medios de combinación y medios
de abstracción de un lenguaje real.

149
00:08:22,270 --> 00:08:25,000
¿Cómo vamos a implementar esto?

150
00:08:25,000 --> 00:08:27,700
Bueno, lo vamos a hacer fácilmente.

151
00:08:27,700 --> 00:08:28,610
Miremos las primitivas

152
00:08:28,610 --> 00:08:31,160
El único problema que tenemos
es implementar las primitivas.

153
00:08:31,160 --> 00:08:34,270
Nada más tiene que ser implementado
porque tomamos

154
00:08:34,270 --> 00:08:37,640
los medios de combinación
y abstracción

155
00:08:37,640 --> 00:08:43,417
de Lisp, heredándolos en la integración.

156
00:08:43,417 --> 00:08:45,860
Miremos una primitiva particular.

157
00:08:45,860 --> 00:08:47,400
El inversor es una linda.

158
00:08:51,540 --> 00:08:54,900
El inversor tiene dos cables,
una entrada y un salida.

159
00:08:57,440 --> 00:09:01,570
Y de alguna forma, va a tener
que saber qué hacer cuando

160
00:09:01,570 --> 00:09:04,300
llegue una señal.

161
00:09:04,300 --> 00:09:07,709
De alguna manera le va a tener
que decir a su cable de entrada --

162
00:09:07,710 --> 00:09:10,756
y ahora vamos a hablar sobre
objetos y vamos a

163
00:09:10,756 --> 00:09:13,260
ver esto en más detalle pronto --

164
00:09:13,260 --> 00:09:16,660
pero le va a tener que decir a su 
cable de entrada que cuando

165
00:09:16,660 --> 00:09:20,120
cambie, le avise.

166
00:09:20,120 --> 00:09:22,720
Así que este objeto, el objeto
que es el inversor tiene que

167
00:09:22,720 --> 00:09:25,700
decirle al objeto que es el cable
de entrada,

168
00:09:25,700 --> 00:09:26,870
"Hola, mi nombre es George.

169
00:09:26,870 --> 00:09:30,480
Y mi trabajo es hacer algo con los
resultdo cuando

170
00:09:30,480 --> 00:09:31,720
tú cambies.

171
00:09:31,720 --> 00:09:34,730
Así que cuando cambies, dímelo.

172
00:09:34,730 --> 00:09:37,100
Porque tengo que hacer algo
con eso."

173
00:09:37,100 --> 00:09:42,200
Bueno, eso se hacer aquí agregando
un acción al cable de

174
00:09:42,200 --> 00:09:47,200
entrada llamada 'invert-in' , donde 
invert-in está definida aquí

175
00:09:47,200 --> 00:09:51,660
como un procedimiento sin argumentos,
que obtiene la

176
00:09:51,660 --> 00:09:56,130
negación lógica de la señal
en el cable de entrada.

177
00:09:56,130 --> 00:09:59,720
Y luego de algún retraso, que es
el retraso del inversor, todos

178
00:09:59,720 --> 00:10:04,110
estos objetos eléctricos tienen retrasos,
haremos lo siguiente:

179
00:10:04,110 --> 00:10:07,140
setearemos la señal del 
cable de salida al nuevo valor.

180
00:10:10,160 --> 00:10:12,400
Un programa muy simple.

181
00:10:12,400 --> 00:10:14,819
Ahora bien, tienen que imaginar
que el cable de salida tiene que ser

182
00:10:14,820 --> 00:10:19,650
sensible y saber cuándo
cambia su señal, porque quizá

183
00:10:19,650 --> 00:10:23,840
le tenga que decir a los demás
que se despierten.

184
00:10:23,840 --> 00:10:26,500
Mi valor ha cambiado.

185
00:10:26,500 --> 00:10:29,349
Así que cuando enganchan
un inversor con una compuerta AND

186
00:10:29,350 --> 00:10:31,680
o algo así, tiene que haber mucha
comuniación para

187
00:10:31,680 --> 00:10:34,400
asegurarse de que la

188
00:10:34,400 --> 00:10:36,810
señal se propaga bien.

189
00:10:36,810 --> 00:10:38,619
Y esto de aquí no es tan interesante.

190
00:10:38,620 --> 00:10:41,100
Es solamente la definición del
negador lógico para

191
00:10:41,100 --> 00:10:44,170
alguna representación particular
de los valores lógicos --

192
00:10:44,170 --> 00:10:46,240
1 y 0 en este caso.

193
00:10:46,240 --> 00:10:49,780
Y podemos mirar cosas más complicadas
como compuertas AND.

194
00:10:49,780 --> 00:10:55,000
Las compuertas AND toman dos entradas,
A1 y A2, y

195
00:10:55,000 --> 00:10:56,950
produce una salida.

196
00:10:56,950 --> 00:10:59,840
Pero la estructura de la compuerta
AND es idéntica a la

197
00:10:59,840 --> 00:11:00,860
que vimos recién.

198
00:11:00,860 --> 00:11:03,000
Hay un procedimiento llamado
and-action que está

199
00:11:03,000 --> 00:11:08,570
definido y es la cosa que se llama
cuando la entrada

200
00:11:08,570 --> 00:11:10,910
cambia.

201
00:11:10,910 --> 00:11:13,230
Y lo que hace es, por supuesto,
nada más que computar

202
00:11:13,230 --> 00:11:15,900
el AND lógico de las señales
de las entradas.

203
00:11:15,900 --> 00:11:20,890
Y luego de algún retraso, llamado
el retraso de la compuerta AND,

204
00:11:20,890 --> 00:11:25,470
llama a este procedimiento, que setea
la señal de salida a un nuevo valor.

205
00:11:25,470 --> 00:11:27,320
Ahora, cómo implemento esto
es mediante

206
00:11:27,320 --> 00:11:28,350
pensamiento ilusorio,

207
00:11:28,350 --> 00:11:32,200
Como ven aquí, tengo una operación
de asignación.

208
00:11:32,200 --> 00:11:34,569
Pero no es set!.

209
00:11:34,570 --> 00:11:36,820
Es una operación de asignación
derivada de la misma manera

210
00:11:36,820 --> 00:11:41,140
que tenía funciones derivadas de CAR
y de CRD.

211
00:11:41,140 --> 00:11:46,340
Así que yo, por convención, 
le punto un signo de exclamación.

212
00:11:46,340 --> 00:11:50,730
Y aquí, pueden ver que se agrega
una acción, que es informar

213
00:11:50,730 --> 00:11:57,190
al cable, llamado localmente A1 en
la compuerta, para que llame

214
00:11:57,190 --> 00:12:00,960
al procedimiento and-action cuando
cambie, y al cable A2

215
00:12:00,960 --> 00:12:02,100
que llame al procedimiento and-action

216
00:12:02,100 --> 00:12:03,350
cuando cambie.

217
00:12:06,310 --> 00:12:09,510
Todo muy simple.

218
00:12:09,510 --> 00:12:12,870
Bueno, hablemos un poco sobre
la comunicación que

219
00:12:12,870 --> 00:12:18,310
debe ocurrir entre estas varias
partes.

220
00:12:18,310 --> 00:12:24,560
Supongan, por ejemplo, 
que tengo un circuito muy simple

221
00:12:24,560 --> 00:12:34,229
que contiene un AND con cables
A y B. Y eso se conecta

222
00:12:34,230 --> 00:12:40,580
a través de un cable C a un
inversor que tiene un cable

223
00:12:40,580 --> 00:12:46,310
de salida llamada D. ¿Cuáles 
son los --? Este

224
00:12:46,310 --> 00:12:47,359
es el mundo físico.

225
00:12:47,360 --> 00:12:49,860
Es una abstracción del mundo
físico real.

226
00:12:49,860 --> 00:12:52,100
Puedo comprar esto de 
pequeñas piezas que

227
00:12:52,100 --> 00:12:54,880
puedo obtener en Radio Shack
por unos centavos.

228
00:12:54,880 --> 00:12:57,680
Y hay cajas que actúan así, 
que tiene pequeños

229
00:12:57,680 --> 00:13:01,530
número en ellas como LS04 o algo.

230
00:13:01,530 --> 00:13:06,980
Supongan que intentase decir
cuál es el

231
00:13:06,980 --> 00:13:09,100
modelo computacional.

232
00:13:09,100 --> 00:13:11,610
¿Cuál es la cosas que se 
corresponde con esa

233
00:13:11,610 --> 00:13:15,850
parte de la realidad en nuestra mente
y en la computadora?

234
00:13:15,850 --> 00:13:18,200
Bueno, tengo que asignar para cada
objeto del mundo un

235
00:13:18,200 --> 00:13:22,160
objeto en la computadora, y por
cada relación en el

236
00:13:22,160 --> 00:13:25,750
mundo entre ellos una relación
en la computadora.

237
00:13:25,750 --> 00:13:28,560
Esa es mi meta.

238
00:13:28,560 --> 00:13:30,900
Así que hagamos eso.

239
00:13:30,900 --> 00:13:35,401
Bueno, tengo una cosa llamada
señal, A.

240
00:13:35,401 --> 00:13:37,939
Este es A. Es una señal.

241
00:13:37,940 --> 00:13:39,900
Es algo nebuloso como esto.

242
00:13:39,900 --> 00:13:42,390
Y tengo otro más aquí que llamaré

243
00:13:42,390 --> 00:13:49,140
B. Es otra señal.

244
00:13:49,140 --> 00:13:52,690
Ahora bien, esta señal --
Estas dos señales van a tener

245
00:13:52,700 --> 00:13:56,180
que se enga nchadas de alguna manera
en una caja que

246
00:13:56,180 --> 00:14:00,319
es el procedimiento de acción
de la compuerta AND,

247
00:14:00,320 --> 00:14:02,400
Ese es el procedimiento de acción
de la compuerta AND.

248
00:14:07,660 --> 00:14:09,750
Y va a producir -- bueno, va a

249
00:14:09,750 --> 00:14:18,360
interactuar con un objeto señal
que llamaremos C -- un objeto

250
00:14:18,360 --> 00:14:21,330
cable, disculpen, que llamaremos C.
Y luego --

251
00:14:21,330 --> 00:14:25,630
Esto va se va a conectar a otro
procedimiento

252
00:14:25,630 --> 00:14:28,240
de acción, que es el que está
asociado con el inversor

253
00:14:28,240 --> 00:14:30,195
en el mundo, el negador.

254
00:14:32,860 --> 00:14:39,980
Y voy a tener otro cable, que

255
00:14:39,980 --> 00:14:42,970
llamaremos D.

256
00:14:42,970 --> 00:14:45,770
Así que este es el diseño.

257
00:14:45,770 --> 00:14:47,650
Ahora tenemos que decir qué
hay dentro de ellos y qué

258
00:14:47,650 --> 00:14:51,500
tiene que conocer para computar.

259
00:14:51,500 --> 00:14:53,900
Bueno, cada uno de estos cable
tiene que conocer

260
00:14:53,900 --> 00:14:57,340
el valor de la señal que está
en el cable.

261
00:14:57,340 --> 00:14:59,430
Así que habrá una variable
aquí dentro,

262
00:14:59,430 --> 00:15:00,680
llamémosla signal.

263
00:15:02,670 --> 00:15:05,839
Y tiene un valor.

264
00:15:05,840 --> 00:15:06,870
Así que tiene que haber un entorno

265
00:15:06,870 --> 00:15:08,656
asociado con esto.

266
00:15:08,656 --> 00:15:10,550
Y por cada uno de estos, tiene que
haber un entorno

267
00:15:10,550 --> 00:15:11,800
que liga a signal.

268
00:15:15,400 --> 00:15:16,880
Y tiene que, por lo tanto, haber
un signal aquí.

269
00:15:19,400 --> 00:15:22,920
Y presumiblemente, el valor
de signal es o 1 o 0.

270
00:15:22,920 --> 00:15:24,170
Y signal.

271
00:15:28,000 --> 00:15:33,140
Ahora bien, también tenemos
que tener gente a la que informarle

272
00:15:33,140 --> 00:15:34,390
si la señal cambia.

273
00:15:36,660 --> 00:15:39,300
Vamos a tener que informar esto.

274
00:15:39,300 --> 00:15:41,469
Así que tengo una lista.
La llamaremos

275
00:15:41,470 --> 00:15:44,500
Action Procedures, AP.

276
00:15:44,500 --> 00:15:47,590
Y es presumiblemente una lista.
Pero lo primero que hay en la lista,

277
00:15:47,590 --> 00:15:50,500
en este caso, es este tipo.

278
00:15:50,500 --> 00:15:53,730
Y el Action Procedures de este
resulta que tiene

279
00:15:53,730 --> 00:15:54,810
una lista de cosas.

280
00:15:54,810 --> 00:15:57,510
Quizá haya otras personas
que están compartiendo A,

281
00:15:57,510 --> 00:15:59,200
que lo están mirando.

282
00:15:59,200 --> 00:16:02,600
Así que podría haber otras
personas en esta lista,

283
00:16:02,600 --> 00:16:03,630
como alguien por allí
que no conocemos.

284
00:16:03,630 --> 00:16:07,200
Es el otro tipo
adjunto a A.

285
00:16:07,200 --> 00:16:11,230
Y el Action Procedure aquí
también tiene que apuntar a eso,

286
00:16:11,230 --> 00:16:13,700
la lista de procedimientos de acciones.

287
00:16:13,700 --> 00:16:17,600
Y, por supuesto, eso significa que aquí,
su Action Procedures tiene

288
00:16:17,600 --> 00:16:18,530
que apuntar aquí.

289
00:16:18,530 --> 00:16:18,770
Estas son las cosas --

290
00:16:18,770 --> 00:16:21,770
Las personas a las que tiene que informar.

291
00:16:21,770 --> 00:16:24,280
Y este tipo también
tiene algunas.

292
00:16:24,280 --> 00:16:25,660
Pero no sé cuáles son, porque no lo

293
00:16:25,660 --> 00:16:27,189
dibujé en mi diagrama.

294
00:16:27,190 --> 00:16:30,320
Son las cosas conectadas a D.

295
00:16:30,320 --> 00:16:36,240
Ahora bien, también pasa
que cuando el procedimiento and-action

296
00:16:36,240 --> 00:16:41,951
se despierta, cuando una
de las personas a las que

297
00:16:41,951 --> 00:16:44,100
le dijo -- una de las personas
a las que le dijo que lo despierte

298
00:16:44,100 --> 00:16:48,430
si su señal cambió, tiene que ir
y preguntarles cuál es su

299
00:16:48,430 --> 00:16:51,540
señal para que puedas hacer el AND,
y producir una

300
00:16:51,540 --> 00:16:52,790
señal para este otro.

301
00:16:57,900 --> 00:16:59,760
Así que tiene que haber, por ejemplo,
información aquí

302
00:16:59,760 --> 00:17:06,400
que diga que mi A1 es este tipo,
y mi A2 es este tipo.

303
00:17:08,930 --> 00:17:14,170
Y no sólo eso, cuando hago el AND, 
le voy a tener que decir a

304
00:17:14,170 --> 00:17:16,170
este tipo algo.

305
00:17:16,170 --> 00:17:17,420
Así que necesito una salida--

306
00:17:19,904 --> 00:17:21,160
que es este tipo.

307
00:17:25,800 --> 00:17:29,550
Y similarmente, este tipo
va a tener una cosa

308
00:17:29,550 --> 00:17:37,540
llamada entrada a la que interroga
para averiguar el valor

309
00:17:37,540 --> 00:17:39,430
de la señal de entrada y cuando
la señal despierta y dice

310
00:17:39,430 --> 00:17:42,980
que ha cambiado y le envía
un mensaje diciendo

311
00:17:42,980 --> 00:17:43,520
que ha cambiado.

312
00:17:43,520 --> 00:17:46,900
Este pregunta cuál es su nuevo valor.

313
00:17:46,900 --> 00:17:50,840
Cuando obtiene el valor, 
va a tener que decir que

314
00:17:50,840 --> 00:17:55,860
output cambia a este tipo.

315
00:18:00,600 --> 00:18:02,481
Y así.

316
00:18:02,481 --> 00:18:06,240
Y tengo que tener al menos
tanta conexión.

317
00:18:06,240 --> 00:18:10,260
Ahora volvamos y miremos, 
por ejemplo, a la compuerta AND.

318
00:18:10,260 --> 00:18:13,670
Volvemos a esta diapositiva.

319
00:18:13,670 --> 00:18:16,400
Y podemos ver algunas
de estas partes.

320
00:18:16,400 --> 00:18:18,470
Para cada compuerta AND, hay un A1,

321
00:18:18,470 --> 00:18:21,300
un A2 y un output.

322
00:18:21,300 --> 00:18:21,483
Y esos son un entorno
que fue creado

323
00:18:21,483 --> 00:18:30,720
en el -- esos producen un frame
en el momento en que and-gate

324
00:18:30,720 --> 00:18:37,200
fue llamda, un frame donde A1, A2
y output tienen sus

325
00:18:37,200 --> 00:18:41,940
valores, están ligados a los cables

326
00:18:41,940 --> 00:18:46,240
a los que se pasaron.

327
00:18:46,240 --> 00:18:50,890
En ese entorno, construí
un procedimiento --

328
00:18:50,890 --> 00:18:54,590
Este de aquí.

329
00:18:54,590 --> 00:18:56,810
El procedimiento and-action
fue creado en ese

330
00:18:56,810 --> 00:18:57,780
entorno.

331
00:18:57,780 --> 00:19:00,190
Ese fue el resultado de evaluar
la expresión

332
00:19:00,190 --> 00:19:01,620
lambda.

333
00:19:01,620 --> 00:19:07,620
Así que se agarra al frame
en el que estos fueron definidos.

334
00:19:07,620 --> 00:19:11,699
Su estado local es ese.

335
00:19:11,700 --> 00:19:15,000
El procedimiento and-action, 
por lo tanto, tiene acceso a A1,

336
00:19:15,000 --> 00:19:17,310
A2 y a output, como vemos aquí.

337
00:19:17,310 --> 00:19:19,645
A1, A2 y output.

338
00:19:22,360 --> 00:19:26,300
Ahora bien, hasta ahoar no hemos
mirando dentro de un cable.

339
00:19:26,300 --> 00:19:29,300
Eso es todo lo que falta.

340
00:19:29,300 --> 00:19:30,280
Miremos un cable.

341
00:19:33,520 --> 00:19:36,160
Quisiera el retroproyector. Muy bien.

342
00:19:39,500 --> 00:19:40,940
Bueno, el cable, también es

343
00:19:40,940 --> 00:19:43,900
un lío complicado.

344
00:19:43,900 --> 00:19:46,840
Equivocado.

345
00:19:46,840 --> 00:19:49,780
Es un lío complicado como eso.

346
00:19:49,780 --> 00:19:54,720
Pero mirémoslo en detalle
y veamos qué es lo que está ocurriendo.

347
00:19:54,720 --> 00:19:57,760
Bueno, el cable es uno de estos.

348
00:19:57,760 --> 00:20:02,320
Y tiene dos cosas que son
parte de él,

349
00:20:02,320 --> 00:20:05,100
ese es su estado.

350
00:20:05,100 --> 00:20:07,390
Uno de ellos es la señal
que vemos aquí.

351
00:20:07,390 --> 00:20:10,670
En otras palabras, cuando llamamos
a make-wire para crear un cable,

352
00:20:10,670 --> 00:20:15,300
entonces lo primero que hacemos
es crear algunas variables que

353
00:20:15,300 --> 00:20:19,270
son la señal y el Action Procedures
para este cable.

354
00:20:22,420 --> 00:20:26,540
Y en ese contexto, definimos
varias funciones--

355
00:20:26,540 --> 00:20:27,840
o procedimiento, disculpen,
procedimientos.

356
00:20:27,840 --> 00:20:32,850
Uno de ellos se llama set-my-signal
a un nuevo valor.

357
00:20:32,850 --> 00:20:37,929
Y lo que hace es tomar un nuevo valor.

358
00:20:37,930 --> 00:20:40,360
Si ese es igual al valor de mi señal, listo.

359
00:20:40,360 --> 00:20:43,459
Caso contrario, seteo la señal
al nuevo valor y llamo a cada

360
00:20:43,460 --> 00:20:47,810
uno de los procedimientos de acción
que me --

361
00:20:47,810 --> 00:20:48,331
¿Cuál es la palabra correcta?

362
00:20:51,700 --> 00:20:54,630
que me han presentado

363
00:20:54,630 --> 00:21:01,530
Me los presentaron cuando
me aplicaron la compuerta AND.

364
00:21:04,130 --> 00:21:07,410
Agrego un procedimiento de acción
al final.

365
00:21:07,410 --> 00:21:10,440
También tengo que definir una
manera para aceptar un procedimiento

366
00:21:10,440 --> 00:21:12,780
de acción -- que es lo que ven aquí--

367
00:21:12,780 --> 00:21:18,530
que incremento mi Action
Procedures usando set! del

368
00:21:18,530 --> 00:21:22,600
resultado de CONsear un nuevo
proceso -- un procedimiento

369
00:21:22,600 --> 00:21:25,760
que me pasan, a la lista
de procedimientos de acción.

370
00:21:25,760 --> 00:21:27,780
Y por razones técnicas tengo
que llamar a ese procedimiento una vez.

371
00:21:27,780 --> 00:21:29,660
No les voy a decir nada sobre eso,
tiene que

372
00:21:29,660 --> 00:21:32,610
ver con simulaciones dirigidas
por eventos y ponerlas

373
00:21:32,610 --> 00:21:36,949
en marcha, que toma un tiempo
para pensar.

374
00:21:36,950 --> 00:21:38,690
Y finalmente, voy a definir una cosa
llamada

375
00:21:38,690 --> 00:21:45,390
dispatcher, que es la manera
de pasar un mensaje a un cable

376
00:21:45,390 --> 00:21:48,300
y que se va a usar para extraer

377
00:21:48,300 --> 00:21:53,820
información, como cuál
es el actual valor de signal.

378
00:21:53,820 --> 00:21:57,179
¿Cuál es el método para setear tu señal?

379
00:21:57,180 --> 00:22:00,100
Quiero obtenerlo

380
00:22:00,100 --> 00:22:02,600
¿Cómo añado otro procedimiento
de acción?

381
00:22:05,510 --> 00:22:08,280
Y voy a retornar ese dispatch,

382
00:22:08,280 --> 00:22:09,940
ese procedimiento, como valor.

383
00:22:09,940 --> 00:22:12,610
Así que ese cable que contruí

384
00:22:12,610 --> 00:22:16,709
es un objeto que acepta mensajes como

385
00:22:16,710 --> 00:22:19,790
¿cuál es tu método para añadir
procedimientos de acciones?

386
00:22:19,790 --> 00:22:22,270
De hecho, me retornará un
procedimiento, que el de añadir

387
00:22:22,270 --> 00:22:26,200
acciones, que puedo aplicar
a un procedimiento de

388
00:22:26,200 --> 00:22:29,100
acción para crear un nuevo
procedimiento de acción en el cable.

389
00:22:31,620 --> 00:22:32,820
Es un permiso.

390
00:22:32,820 --> 00:22:37,450
Me da permiso para cambiar
su Action Procedures.

391
00:22:37,450 --> 00:22:41,710
Y, de hecho, lo pueden ver aquí.

392
00:22:41,710 --> 00:22:43,278
Siguiente diapositiva.

393
00:22:47,760 --> 00:22:49,120
No es algo tan interesante.

394
00:22:49,120 --> 00:22:52,400
El call-each de los Action
Procedures es solo CDRear

395
00:22:52,400 --> 00:22:53,500
una lista. Y ya no siquiera voy

396
00:22:53,500 --> 00:22:54,990
a hablar de eso.

397
00:22:54,990 --> 00:22:57,560
Ya estamos muy avanzados para eso.

398
00:22:57,560 --> 00:23:00,280
Sin embargo, si quiero obtener
la señal de un cable

399
00:23:00,280 --> 00:23:02,250
le pregunto al cable--

400
00:23:02,250 --> 00:23:03,900
¿qué es el cable?

401
00:23:03,900 --> 00:23:05,860
El cable es el dispatch
retornado al crear el cable.

402
00:23:05,860 --> 00:23:06,830
Es un procedimiento.

403
00:23:06,830 --> 00:23:12,590
Llamo a ese dispatch con el
mensaje 'get-signal'.

404
00:23:12,590 --> 00:23:14,770
Y lo que debo esperar
es obtener un método

405
00:23:14,770 --> 00:23:16,900
para obtener una señal.

406
00:23:16,900 --> 00:23:19,220
O, en realidad, obtengo la señal.

407
00:23:19,220 --> 00:23:25,800
Si quiero setear la señal, 
quiero cambiar una señal, entonces

408
00:23:25,800 --> 00:23:28,810
lo que tengo que hacer es tomar
un cable como argumento y un nuevo

409
00:23:28,810 --> 00:23:31,120
valor para la señal. Le voy a pedir

410
00:23:31,120 --> 00:23:35,659
permiso al cable para setear su señal
y usasr ese permiso, que es

411
00:23:35,660 --> 00:23:38,700
un procedimiento, en el nuevo valor.

412
00:23:38,700 --> 00:23:44,156
Y si volvemos al retroproyector aquí, 
gracias,

413
00:23:44,156 --> 00:23:46,879
si volvemos al retroproyector, 
vemos que el método --

414
00:23:46,880 --> 00:23:49,720
Si pregunto por el método
para setear la señal, eso

415
00:23:49,720 --> 00:23:54,620
está aquí, es 'set-my-signal',
un procedimiento que está definido

416
00:23:54,620 --> 00:23:59,270
dentro del cable, que si lo miramos
es la cosa

417
00:23:59,270 --> 00:24:02,930
que dice que setee su valor interno
llamado señal, su variable

418
00:24:02,930 --> 00:24:08,640
interna, que es el signal,
al nuevo valor,

419
00:24:08,640 --> 00:24:11,630
que se lo pasan como argumento, 
y luego llama a cada uno

420
00:24:11,630 --> 00:24:13,100
de los procedimiento de acción,
despertándolos.

421
00:24:16,340 --> 00:24:19,399
Muy simple,.

422
00:24:19,400 --> 00:24:24,310
Volviendo a la diapositiva, tenemos
también una última cosa --

423
00:24:24,310 --> 00:24:27,810
que supongo que ahora
pueden entender por su cuenta --

424
00:24:27,810 --> 00:24:30,100
La manera de agregar una acción.

425
00:24:30,100 --> 00:24:36,469
Tomas un cable y un procedimiento
de acción.

426
00:24:36,470 --> 00:24:40,500
Y le pido permiso al cable
para agregar una acción.

427
00:24:40,500 --> 00:24:43,210
Obteniendo el permiso, lo uso para

428
00:24:43,210 --> 00:24:45,200
darle un procedimiento de acción.

429
00:24:45,200 --> 00:24:48,570
Así que es un objeto real.

430
00:24:48,570 --> 00:24:52,460
Hay un par de detalles más
sobre esto.

431
00:24:52,460 --> 00:24:58,390
Por ejemplo, ¿cómo voy
a controlar esta cosa?

432
00:24:58,390 --> 00:25:01,290
¿Cómo hago estos retrasos?

433
00:25:01,290 --> 00:25:02,540
Mirémoslo por un segundo.

434
00:25:05,275 --> 00:25:08,360
La siguiente aquí.

435
00:25:08,360 --> 00:25:09,570
Veamos.

436
00:25:09,570 --> 00:25:15,450
Sabemos de haber mirado la
compuerta AND o la compuerta NOT

437
00:25:15,450 --> 00:25:18,770
que cuando una señal cambiaba en la
entrada, había un retraso.

438
00:25:18,770 --> 00:25:22,600
Y luego iba a llamar al procedimiento,
que iba

439
00:25:22,600 --> 00:25:23,310
a cambiar la salida.

440
00:25:26,400 --> 00:25:28,120
Bueno, ¿Cómo vamos a hacer esto?

441
00:25:28,120 --> 00:25:30,600
Vamos a inventar un mecanismo,

442
00:25:30,600 --> 00:25:32,840
una bastante complicado,
con el que tendremos

443
00:25:32,840 --> 00:25:34,720
que ser muy cuidadosos.

444
00:25:34,720 --> 00:25:37,390
Pero luego del retraso,
vamos a tener que hacer un acción.

445
00:25:37,390 --> 00:25:40,590
Un retraso es un número
y una acción, un procedimiento.

446
00:25:40,590 --> 00:25:41,970
Lo que eso será es que vamos
a tener una

447
00:25:41,970 --> 00:25:47,120
estructura especial llamada agenda,
que la cosa que

448
00:25:47,120 --> 00:25:49,510
organiza el tiempo y las acciones.

449
00:25:49,510 --> 00:25:50,879
Y lo veremos en un momento.

450
00:25:50,880 --> 00:25:53,700
No quiero entrar en ello ahora.

451
00:25:53,700 --> 00:25:55,745
Pero la agenda tiene un momento
en el que

452
00:25:55,745 --> 00:25:59,129
algo pasa.

453
00:25:59,130 --> 00:26:03,120
Nos preparamos para después
en algún momento, que es la suma

454
00:26:03,120 --> 00:26:05,399
del tiempo, que el retraso
más el tiempo actual,

455
00:26:05,400 --> 00:26:08,460
que la agenda piensa que es ahora.

456
00:26:08,460 --> 00:26:11,840
Vamos a prepararnos para hacer
esta acción y agregarla

457
00:26:11,840 --> 00:26:13,900
a la agenda.

458
00:26:15,280 --> 00:26:18,660
Y la manera en que esta máquina
correrá es muy simple.

459
00:26:18,660 --> 00:26:20,800
Tenemos una cosa llamada 'propagate'
que es la manera en que

460
00:26:20,800 --> 00:26:22,710
las cosas corren.

461
00:26:22,710 --> 00:26:25,290
Si la agenda está vacía, terminamos--
Si no hay nada más

462
00:26:25,290 --> 00:26:27,440
por hacer.

463
00:26:27,440 --> 00:26:31,690
Caso contrario, vamos a tomar el 
primer elemento de la agenda,

464
00:26:31,690 --> 00:26:34,200
que es un procedimiento sin argumentos.

465
00:26:34,200 --> 00:26:36,300
Y vamos a ver paréntesis extra aquí.

466
00:26:36,300 --> 00:26:39,190
Lo llamamos sin argumentos.

467
00:26:39,190 --> 00:26:42,200
Eso toma la acción.

468
00:26:42,200 --> 00:26:45,500
Luego removemos el primer
elmento de la agenda

469
00:26:45,500 --> 00:26:48,395
y continuamos con el ciclo
de propagación.

470
00:26:48,395 --> 00:26:50,750
Esa es la estructura general de esta cosa.

471
00:26:53,380 --> 00:26:57,430
Ahora bien, hay otras cosas que
podemos mirar.

472
00:26:57,430 --> 00:26:59,160
Y luego vamos a mirar dentro
de la agenda

473
00:26:59,160 --> 00:27:00,410
en un rato.

474
00:27:00,410 --> 00:27:02,800
Volvemos al retroproyector.

475
00:27:02,800 --> 00:27:04,980
Bueno, para poder hacer andar esto,

476
00:27:04,980 --> 00:27:07,410
quiero mostrarles el comportamiento
de este simulador.

477
00:27:07,410 --> 00:27:10,610
Por cierto, pueden pensar 
que este simulador es muy simple,

478
00:27:10,610 --> 00:27:12,370
y probablemente muy simple
para ser útil.

479
00:27:12,370 --> 00:27:15,729
Pero el hecho es que este simulador
se ha usado

480
00:27:15,730 --> 00:27:18,680
para manufacturar una computadora
bastante grande.

481
00:27:18,680 --> 00:27:22,360
Así que este es un ejemplo real.

482
00:27:22,360 --> 00:27:24,790
En realidad, no exactamente
este simulador, porque les

483
00:27:24,790 --> 00:27:25,560
diré la diferencia.

484
00:27:25,560 --> 00:27:28,179
La diferencia es que había 
muchos más tipos

485
00:27:28,180 --> 00:27:29,820
de primitivas.

486
00:27:29,820 --> 00:27:33,200
No sólo el inversor y la compuerta
AND.

487
00:27:33,200 --> 00:27:37,590
Había cosas como edge triggers, flip-flops,

488
00:27:37,590 --> 00:27:43,780
y cerrojos, cerrojos transparentes
y sumadores y cosas

489
00:27:43,780 --> 00:27:45,170
por el estilo.

490
00:27:45,170 --> 00:27:48,510
Y la dificultad con eso
que hay páginas y páginas

491
00:27:48,510 --> 00:27:51,410
de definiciones de
todas estas primitivas con

492
00:27:51,410 --> 00:27:54,690
números como LS04.

493
00:27:54,690 --> 00:27:56,740
Y hay muchos más parámetros
para ellos.

494
00:27:56,740 --> 00:27:58,480
No hay sólo un delay.

495
00:27:58,480 --> 00:28:00,200
Hay tiempos de inicialización 
y de esperoa

496
00:28:00,200 --> 00:28:01,220
y cosas así.

497
00:28:01,220 --> 00:28:03,990
Pero exceptuando esa parte
de complejidad, la

498
00:28:03,990 --> 00:28:07,580
estructura del simulador que
usamos para construir

499
00:28:07,580 --> 00:28:12,290
una computadora real que
funciona, es exactamente

500
00:28:12,290 --> 00:28:15,110
lo que ven aquí.

501
00:28:15,110 --> 00:28:19,270
Bueno, en cualquier caso, lo que tenemos
aquí son un par de cosas simples.

502
00:28:19,270 --> 00:28:21,580
Hay retrasos de inversores siendo
inicializados y crear

503
00:28:21,580 --> 00:28:23,300
una nueva agenda.

504
00:28:23,300 --> 00:28:26,470
Y luego hay algunas entradas.

505
00:28:26,470 --> 00:28:28,220
Está input-1, input-2, una suma

506
00:28:28,220 --> 00:28:29,460
y un carry, que son cables.

507
00:28:29,460 --> 00:28:32,560
Voy a poner un tipo especial
de objeto llamado sonda

508
00:28:32,560 --> 00:28:37,810
sobre algunos de los cables, sobre
la suma y sobre el carry.

509
00:28:37,810 --> 00:28:41,590
Una sonda es un objeto que
tiene la propiedad de que cuando

510
00:28:41,590 --> 00:28:46,120
cambias un cables al que está adherido,
escribe un mensaje.

511
00:28:46,120 --> 00:28:47,969
Es algo fácil de hacer.

512
00:28:47,970 --> 00:28:50,790
Y una vez que tenemos eso, por supuesto,
al encender

513
00:28:50,790 --> 00:28:53,400
la sonda, lo primero que hace
es decir que el valor

514
00:28:53,400 --> 00:28:59,399
actual de suma en el tiempo cero, 
es cero, porque recién lo noté.

515
00:28:59,400 --> 00:29:02,640
Y el valor de carry al tiempo cero,

516
00:29:02,640 --> 00:29:05,556
este es el tiempo, es cero.

517
00:29:05,556 --> 00:29:09,620
Y luego vamos y construímos
una estructura.

518
00:29:09,620 --> 00:29:14,439
Podemos construir una estructura
que diga que tienen

519
00:29:14,440 --> 00:29:18,420
un medio sumador con input-1,
input-2, suma y carry.

520
00:29:18,420 --> 00:29:20,420
Y vamos a setear la señal 
de input-1 en 1.

521
00:29:20,420 --> 00:29:21,880
Hacemos un poco de propagación.

522
00:29:21,880 --> 00:29:25,380
En el tiempo ocho, que pueden
ver mirando aquí

523
00:29:25,380 --> 00:29:29,520
si quisieran, el nuevo valor
de sum se convirtió en 1.

524
00:29:29,520 --> 00:29:31,150
Y la cosa dice que terminó.

525
00:29:31,150 --> 00:29:32,630
Eso es muy interesante.

526
00:29:32,630 --> 00:29:34,150
Pero le podemos enviar algunas
señales más.

527
00:29:34,150 --> 00:29:36,590
Podemos hacer set-signal
de input-2 en 1.

528
00:29:36,590 --> 00:29:39,429
Y en ese tiempo, si propagamos,

529
00:29:39,430 --> 00:29:43,280
el 11, el carry se convierte en 1.
Y en el 16, el nuevo

530
00:29:43,280 --> 00:29:45,400
valor de la suma es cero.

531
00:29:45,400 --> 00:29:48,600
Y quizá quieran aprender eso
sobre la

532
00:29:48,600 --> 00:29:48,990
circuitería digital.

533
00:29:48,990 --> 00:29:50,620
Es cierto y funciona.

534
00:29:50,620 --> 00:29:51,534
No es muy interesante.

535
00:29:51,535 --> 00:29:53,330
Pero el tipo de comportamiento

536
00:29:53,330 --> 00:29:54,580
que obtenemos de esta cosa.

537
00:30:01,830 --> 00:30:06,550
Así que lo que les mostré
es una imagen a gran escala,

538
00:30:06,550 --> 00:30:10,360
de cómo a gran escala, se implementa

539
00:30:10,360 --> 00:30:12,952
una simulación dirigida por eventos.

540
00:30:12,952 --> 00:30:16,100
Y como podrían organizarla
para tener una linda estructura

541
00:30:16,100 --> 00:30:20,220
jerárquica que les permita
construir cajas abstractas

542
00:30:20,220 --> 00:30:21,225
que pueden instanciar.

543
00:30:21,225 --> 00:30:23,629
Pero no les di ningún detalle
sobre cómo

544
00:30:23,630 --> 00:30:25,780
la agenda y cosas así funcionan.

545
00:30:25,780 --> 00:30:28,629
Eso lo haremos después.

546
00:30:28,630 --> 00:30:32,400
Y va a involucrar cambio
y mutación de datos

547
00:30:32,400 --> 00:30:34,310
y cosas por el estilo.

548
00:30:34,310 --> 00:30:35,860
¿Hay alguna pregunta 
antes de que continúe?

549
00:30:47,160 --> 00:30:47,550
Gracias.

550
00:30:47,550 --> 00:30:48,800
Tomemos un descanso.

551
00:31:28,940 --> 00:31:35,600
Bueno, estuvimos construyendo
un simulación.

552
00:31:35,600 --> 00:31:39,360
Y la simulación es una
dirigida por eventos

553
00:31:39,360 --> 00:31:43,919
donde los objetos en el mundo
son los objetos en la computadora.

554
00:31:43,920 --> 00:31:46,700
Y los cambios de estado que
están ocurriendo en el mundo

555
00:31:46,700 --> 00:31:53,520
en cierto tiempo, se organizan
para que estén en tiempo en la computadora,

556
00:31:53,520 --> 00:31:56,430
de manera tal que algo que pasa 
después de otra cosa en el mundo,

557
00:31:56,430 --> 00:32:00,910
entonces ocurre después
de los eventos correspondientes

558
00:32:00,910 --> 00:32:04,420
en el mismo orden en la computadora.

559
00:32:04,420 --> 00:32:06,700
Ahí es donde tenemos asignaciones,

560
00:32:06,700 --> 00:32:08,220
cuando hacemos esa alineación.

561
00:32:08,220 --> 00:32:11,860
Ahora quiero mostrarles una manera
de organizar el tiempo, que

562
00:32:11,860 --> 00:32:16,400
es una agenda o una cola de prioridad,
como a veces se conoce.

563
00:32:16,400 --> 00:32:17,990
Haremos -- Entenderemos un poco

564
00:32:17,990 --> 00:32:19,980
cuáles son las cosas que tenemos
que ser capaces de hacer para

565
00:32:19,980 --> 00:32:21,230
hacer agendas.

566
00:32:28,330 --> 00:32:30,310
Y vamos a tener -- ahora
aquí arriba

567
00:32:30,310 --> 00:32:31,750
voy a escribir un montón
de operaciones primitivas

568
00:32:31,750 --> 00:32:35,960
para manipular agendas.

569
00:32:35,960 --> 00:32:38,650
No les voy a mostrar su código
porque son todas

570
00:32:38,650 --> 00:32:41,300
muy simple, y además tienen

571
00:32:41,300 --> 00:32:43,680
una lista de ellas de cualquier manera.

572
00:32:43,680 --> 00:32:44,380
¿Qué tenemos?

573
00:32:44,380 --> 00:32:52,880
Tenemos cosas como make-agenda,
que produce una

574
00:32:52,880 --> 00:32:54,130
nueva agenda.

575
00:32:59,860 --> 00:33:10,949
Podemos preguntar-- obtener
el tiempo actual de la agenda,

576
00:33:10,950 --> 00:33:12,625
lo que me devuelve un número,
un tiempo.

577
00:33:16,990 --> 00:33:20,650
Podemos obtener-- podemos
preguntar si una agenda está vacía

578
00:33:20,650 --> 00:33:21,900
con empty-agenda.

579
00:33:30,200 --> 00:33:32,570
Y eso produce o verdadero
o falso.

580
00:33:42,590 --> 00:33:44,720
Podemos agregarle un objeto
a una agenda.

581
00:33:52,710 --> 00:33:55,230
De hecho, lo que le agregamos
a una agenda es una operación --

582
00:33:55,230 --> 00:33:56,910
una acción por hacerse.

583
00:33:56,910 --> 00:34:03,560
Y eso toma un tiempo, la acción
misma y una agenda a la que

584
00:34:03,560 --> 00:34:04,810
lo quiero agregar.

585
00:34:07,850 --> 00:34:09,279
Eso lo inserta en el lugar

586
00:34:09,280 --> 00:34:10,719
apropiado en la agenda.

587
00:34:10,719 --> 00:34:14,850
Puedo obtener el primer
elemento de una agenda, la primer

588
00:34:14,850 --> 00:34:23,259
cosa que tengo que hacer, que me
devolverá una acción.

589
00:34:26,850 --> 00:34:29,540
Y puedo remover el primer
elemento de una agenda.

590
00:34:29,540 --> 00:34:31,409
Eso es lo que tengo que ser capaz
de hacer con agendas.

591
00:34:31,409 --> 00:34:33,199
Es una gran lío complicado.

592
00:34:42,530 --> 00:34:43,780
De una agenda.

593
00:34:45,530 --> 00:34:48,400
Bueno, veamos cómo podemos
organizar esto como una estructura

594
00:34:48,400 --> 00:34:52,527
de datos.

595
00:34:52,527 --> 00:34:58,720
Bueno, una agenda va a ser una
especie de lista. Y va

596
00:34:58,720 --> 00:35:00,189
a ser una lista que voy a tener

597
00:35:00,190 --> 00:35:01,570
que poder modificar.

598
00:35:01,570 --> 00:35:05,820
Así que tenemos que hablar de
modificar lista, porque

599
00:35:05,820 --> 00:35:09,590
voy a añadirle elementos, 
eliminarle elementos

600
00:35:09,590 --> 00:35:11,700
y cosas así.

601
00:35:11,700 --> 00:35:13,820
Está organizado temporalmente.

602
00:35:13,820 --> 00:35:15,570
Es problablemente bueno
mantenerlo ordenado.

603
00:35:18,330 --> 00:35:22,170
Pero a veces hay muchas cosas
que pasan al

604
00:35:22,170 --> 00:35:23,420
mismo tiempo-- aproximadamente
al mismo tiempo.

605
00:35:23,420 --> 00:35:26,440
Lo que tengo que hacer es agrupar
las cosas por el tiempo

606
00:35:26,440 --> 00:35:29,400
en el que se suponen 
que tienen que ocurrir.

607
00:35:29,400 --> 00:35:32,779
Así que voy a hacer una agenda
como una lista de segmentos.

608
00:35:32,780 --> 00:35:36,780
Les voy a dibujar una estructura
de datos para una agenda,

609
00:35:36,780 --> 00:35:39,620
una perfectamente razonable.

610
00:35:39,620 --> 00:35:41,109
Esta es una agenda.

611
00:35:41,110 --> 00:35:42,870
Es una cosa que comienza con un nombre.

612
00:35:47,630 --> 00:35:49,940
Voy a hacerla a partir de una
estructura de lista.

613
00:35:52,620 --> 00:35:53,980
Tiene un encabezado.

614
00:35:53,980 --> 00:35:55,840
Hay una razón para encabezado.

615
00:35:55,840 --> 00:35:57,630
Vamos a ver la razón pronto.

616
00:36:00,680 --> 00:36:03,750
Y tendrá un segmento.

617
00:36:03,750 --> 00:36:05,620
Y tendrá un segmento --
una lista de segmentos.

618
00:36:08,310 --> 00:36:13,580
Suponiendo que esta agenda
tiene dos segmentos, son los CARs,

619
00:36:13,580 --> 00:36:18,259
los sucesivos CARs de la lista.
Cada segmento va

620
00:36:18,260 --> 00:36:20,250
a tener un tiempo --

621
00:36:24,160 --> 00:36:26,899
Digamos, por ejemplo, 10--

622
00:36:26,900 --> 00:36:29,600
que dice que las cosas que pasan
en este

623
00:36:29,600 --> 00:36:33,320
segmentos lo harán en el tiempo 10.

624
00:36:33,320 --> 00:36:36,670
Y lo que voy a tener aquí
es otra estructura de datos

625
00:36:36,670 --> 00:36:39,490
que no voy a describir, que es
una cola

626
00:36:39,490 --> 00:36:42,240
de cosas para hacer en el tiempo 10.

627
00:36:42,240 --> 00:36:43,330
Es una cola.

628
00:36:43,330 --> 00:36:45,130
Y hablaremos de ello
en un segundo.

629
00:36:45,130 --> 00:36:49,530
Pero abstractamente, una cosa
es solo una lista de cosas para hacer

630
00:36:49,530 --> 00:36:50,200
en un tiempo particular.

631
00:36:50,200 --> 00:36:53,100
Y puedo agregarle cosas a la cola.

632
00:36:53,100 --> 00:36:56,140
Esto es una cola.

633
00:36:56,140 --> 00:36:59,115
Hay tiempo, hay un segmento.

634
00:37:02,889 --> 00:37:06,350
Ahora bien, podrría tener otro
segmento en esta agenda.

635
00:37:08,940 --> 00:37:13,410
Supongan que estas son las cosas
que ocurren en el tiempo 30.

636
00:37:13,410 --> 00:37:18,200
Tiene, por supuesto, otra
cola de cosas que

637
00:37:18,200 --> 00:37:23,210
se encolan para hacer en
el tiempo 30.

638
00:37:23,210 --> 00:37:24,705
Bueno, hay varias cosas que
tengo que ser

639
00:37:24,705 --> 00:37:27,900
capaz de hacerle a una agenda.

640
00:37:27,900 --> 00:37:30,410
Supongan que quiero agregarle 
a una agenda una cosa para

641
00:37:30,410 --> 00:37:33,290
hacer en el tiempo 10.

642
00:37:33,300 --> 00:37:34,700
Bueno, eso no es muy difícil.

643
00:37:34,700 --> 00:37:37,480
Voy a venir aquí, buscando

644
00:37:37,480 --> 00:37:39,730
el segmento de tiempo 10.

645
00:37:39,730 --> 00:37:42,930
Es posible que no haya
un segmento de tiempo 10.

646
00:37:42,930 --> 00:37:45,419
Cubriremos ese caso en un segundo.

647
00:37:45,420 --> 00:37:48,590
Pero si encuentro un segmento
de tiempo 10, entonces si quiero agregarle

648
00:37:48,590 --> 00:37:51,700
otra cosa para hacer en el tiempo 10,

649
00:37:51,700 --> 00:37:53,860
tengo que incrementar la cola --

650
00:37:53,860 --> 00:37:56,290
"Incrementar" no es una idea tan obvia.

651
00:37:56,290 --> 00:38:01,430
Pero incremento las
cosas a hacerse a ese tiempo.

652
00:38:01,430 --> 00:38:02,899
Ahora, supongan que quiero
agregar algo a

653
00:38:02,900 --> 00:38:05,140
hacerse en el tiempo 20.

654
00:38:05,140 --> 00:38:08,680
No hay un segmento para el tiempo 20.

655
00:38:08,680 --> 00:38:11,339
Voy a tener que crear un segmento nuevo.

656
00:38:11,340 --> 00:38:13,960
Quiero el segmento de tiempo 20
exista entre

657
00:38:13,960 --> 00:38:17,610
el de tiempo 10 y el de tiempo 30.

658
00:38:17,610 --> 00:38:20,170
Bueno, eso cuesta un poco.

659
00:38:20,170 --> 00:38:21,525
Voy a tener que hacer un CONS.

660
00:38:24,260 --> 00:38:28,690
Voy a tener que hacer un nuevo
elemento en la lista de

661
00:38:28,690 --> 00:38:29,940
la agenda-- la lista de segmentos.

662
00:38:33,600 --> 00:38:35,400
Voy a tener que cambiar.

663
00:38:35,400 --> 00:38:37,540
Aquí cambia.

664
00:38:37,540 --> 00:38:42,290
Voy a tener que cambiar el
CDR del CDR de la

665
00:38:42,290 --> 00:38:50,620
agenda para que apunte a un
nuevo CONS de un nuevo segmento y

666
00:38:50,620 --> 00:38:56,656
el CDR del CDR del CDR de la agenda.

667
00:38:56,657 --> 00:39:02,470
Y esto va a tener un nuevo
segmento de tiempo 20,

668
00:39:02,470 --> 00:39:06,290
con su propia cola, que ahora
tiene un elemento.

669
00:39:10,730 --> 00:39:13,800
Si quisiera agregar algo al final,
voy a tener que

670
00:39:13,800 --> 00:39:20,770
reemplazar el CDR de esta
lista con algo.

671
00:39:20,770 --> 00:39:24,400
Vamos a tener que cambiar
ese pedazo de estructura de datos.

672
00:39:24,400 --> 00:39:27,210
Voy a necesitar nuevas primitivas
para hacer eso.

673
00:39:27,210 --> 00:39:29,550
Pero sólo les estoy mostrando
porqué las necesito.

674
00:39:29,550 --> 00:39:33,390
Y finalmente, si quisiera agregar
una cosa para hacerse en el tiempo

675
00:39:33,390 --> 00:39:41,240
5 voy a tener que cambiar esto, 
porque voy a tener

676
00:39:41,240 --> 00:39:44,770
que agregarla aquí, que es la razón
por la que planeé por adelanteado

677
00:39:44,770 --> 00:39:49,400
y tenía un encabezado,
que tiene un lugar.

678
00:39:49,400 --> 00:39:50,580
Si voy a cambiar cosas,
necesito tener

679
00:39:50,580 --> 00:39:53,420
lugares para el cambio.

680
00:39:53,420 --> 00:39:58,600
Tengo que tener un lugar
para hacer el cambio.

681
00:39:58,600 --> 00:40:02,540
Si remuevo cosas de la agenda
no es tan difícil.

682
00:40:02,540 --> 00:40:04,990
Removerlas del principio
es bastante fácil,

683
00:40:04,990 --> 00:40:07,740
que es el único caso que tengo.
Puedo ir buscando

684
00:40:07,740 --> 00:40:11,220
el primero, el primer segmento.

685
00:40:11,220 --> 00:40:14,509
Y veo si tiene una cola no vacía.

686
00:40:14,510 --> 00:40:17,610
Si tiene una cola no vacía,
voy a borrar un elemento

687
00:40:17,610 --> 00:40:20,100
de esa cola, así.

688
00:40:20,100 --> 00:40:23,460
Si la cola se queda vacía, voy
a tener que borrar

689
00:40:23,460 --> 00:40:24,220
todo el segmento.

690
00:40:24,220 --> 00:40:28,220
Y luego esto cambia para apuntar ahí.

691
00:40:28,220 --> 00:40:30,540
Así que es una manipulación
complicada de la estructura de datos,

692
00:40:30,540 --> 00:40:36,440
cuyos detalles no son interesantes.

693
00:40:36,440 --> 00:40:38,920
Ahora hablemos sobre colas.

694
00:40:38,920 --> 00:40:41,160
Son similares.

695
00:40:41,160 --> 00:40:44,339
Porque cada una de estas agendas
tiene una cola.

696
00:40:44,340 --> 00:40:45,590
¿Qué es una cola?

697
00:40:49,790 --> 00:40:51,110
Una cola tendría las siguientes

698
00:40:51,110 --> 00:40:52,350
operaciones primitivas.

699
00:40:52,350 --> 00:41:02,170
'Make-queue' me devuelve una nueva cola.

700
00:41:07,274 --> 00:41:12,609
Tengo que ser capaz de insertar
en una cola

701
00:41:12,610 --> 00:41:16,850
un nuevo elemento.

702
00:41:24,510 --> 00:41:27,490
Tengo que ser capaz de eliminar
de la cola

703
00:41:27,490 --> 00:41:28,740
el primer elemento.

704
00:41:39,988 --> 00:41:51,319
Y quiero ser capaz de obtener
el primer elemento de la cola,

705
00:41:51,320 --> 00:41:52,890
de alguna cola.

706
00:41:52,890 --> 00:41:55,140
Tengo tengo que poder
sabes si una cola está vacía.

707
00:42:07,110 --> 00:42:09,710
Y cuando inventan cosas así,
quiero que sean

708
00:42:09,710 --> 00:42:13,220
muy cuidados para usar
las convenciones que uso

709
00:42:13,220 --> 00:42:15,120
para nombrar cosas.

710
00:42:15,120 --> 00:42:18,450
Noten que tengo cuidado de decir
que estos cambian algo

711
00:42:18,450 --> 00:42:19,870
y esto lo prueba.

712
00:42:19,870 --> 00:42:24,335
Y presumiblemente, hice lo
mismo allí.

713
00:42:24,335 --> 00:42:29,240
Bien, debería haber una prueba
de vacío aquí.

714
00:42:29,240 --> 00:42:31,720
Bueno, ¿cómo haría una cola?

715
00:42:31,720 --> 00:42:35,209
Una cola quiere ser algo
al que le pueda agregar cosas al final,

716
00:42:35,210 --> 00:42:37,840
y del que puedo obtener las cosas
de su inicio.

717
00:42:37,840 --> 00:42:39,290
Debería ser capaz de borrar
desde el principio

718
00:42:39,290 --> 00:42:41,230
y de agregar al final.

719
00:42:41,230 --> 00:42:42,400
Bueno, voy a mostrarles una
estructura muy

720
00:42:42,400 --> 00:42:43,740
simple para eso.

721
00:42:43,740 --> 00:42:47,800
Podemos hacer esto con CONs también.

722
00:42:47,800 --> 00:42:49,910
Aquí hay una cola.

723
00:42:49,910 --> 00:42:55,310
Tiene un encabezado, que contiene
dos partes--

724
00:42:55,310 --> 00:42:59,610
un puntero al inicio
y un puntero al final.

725
00:43:02,930 --> 00:43:09,000
Y tengo una cola con
dos elementos en ella.

726
00:43:09,000 --> 00:43:12,950
El primer elemento, no lo sé,
es quizá un 1.

727
00:43:12,950 --> 00:43:16,529
Y el segundo elemento, no lo sé,
será un 2.

728
00:43:21,160 --> 00:43:24,549
La razón por la que quiero
tener dos punteros aquí,

729
00:43:24,550 --> 00:43:27,570
uno al inicio y otro al final
es para que no pueda agregar

730
00:43:27,570 --> 00:43:31,850
elementos al final sin
tener que recorrer desde el principio.

731
00:43:31,850 --> 00:43:34,380
Por ejemplo, si quisiera agregarle
un nuevo elemento a esta

732
00:43:34,380 --> 00:43:40,380
cola, quiero agregarle otro
elmento del cual preocuparme

733
00:43:40,380 --> 00:43:44,600
luego, todo lo que tengo que hacer
es un CONS que contiene a ese

734
00:43:44,600 --> 00:43:47,529
elemento, digamos un 3.

735
00:43:47,530 --> 00:43:51,340
Eso para insertar un tres 
en la cola.

736
00:43:51,340 --> 00:44:00,100
Y luego tengo que cambiar
este puntero de aquí hacia aquí.

737
00:44:00,100 --> 00:44:04,319
Y tengo que cambiar este
para que apunte al nuevo final.

738
00:44:09,120 --> 00:44:11,990
Si quisiera tomar el primer
elemento de la cola,

739
00:44:11,990 --> 00:44:15,129
busco el puntero al inicio
hasta que encuentro

740
00:44:15,130 --> 00:44:18,890
el primer elemento y lo agarro.

741
00:44:18,890 --> 00:44:22,560
Si quisiera borrar el primer
elemento de la cola,

742
00:44:22,560 --> 00:44:25,240
tengo que mover
el puntero del inicio

743
00:44:25,240 --> 00:44:27,450
hacia este lugar.

744
00:44:27,450 --> 00:44:31,700
El nuevo inicio de la cola es
este ahora.

745
00:44:31,700 --> 00:44:34,390
Así que las colas son bastante simples
también.

746
00:44:34,390 --> 00:44:39,690
Así que lo que ven ahora
es que necesito una cierta cantidad

747
00:44:39,690 --> 00:44:41,350
de nuevas operaciones primitivas.

748
00:44:41,350 --> 00:44:42,560
Y voy a nombrar algunas.

749
00:44:42,560 --> 00:44:45,310
Y vamos a ver cómo trabajan y cómo

750
00:44:45,310 --> 00:44:47,350
se usan.

751
00:44:47,350 --> 00:44:56,970
Tenemos set-car! de un par
o de una cosa producida

752
00:44:56,970 --> 00:44:58,939
con CONS, a un nuevo valor.

753
00:45:02,370 --> 00:45:09,920
Y set-cdr! de un par a un nuevo valor.

754
00:45:12,680 --> 00:45:16,290
Y luego vamos a ver cómo trabajan.

755
00:45:16,300 --> 00:45:19,720
Necesitaba setear el car
para eliminar el primer

756
00:45:19,720 --> 00:45:20,959
elemento de la cola.

757
00:45:20,960 --> 00:45:23,470
Este es el CAR y tengo que setearlo.

758
00:45:23,470 --> 00:45:26,299
Tengo que ser capaz de setear el CDR
para poder mover el puntero

759
00:45:26,300 --> 00:45:30,160
al final, o para poder incrementar
la cola aquí.

760
00:45:30,160 --> 00:45:33,170
Todas las operaciones que hice
están hechas de esas que les

761
00:45:33,170 --> 00:45:35,515
mostré en el último pizarrón.

762
00:45:38,230 --> 00:45:38,430
Bien.

763
00:45:38,430 --> 00:45:40,357
Pausemos el tiempo y tomemos un
pequeño descanso.

764
00:46:38,346 --> 00:46:42,910
Cuando originalmente introdujimos
pares formados por CONS, hechos

765
00:46:42,910 --> 00:46:48,640
por CONS, solo nombramos
un par de axiomas sobre ello, que eran

766
00:46:48,640 --> 00:46:50,400
de la form --

767
00:46:50,400 --> 00:46:52,900
¿Cómo eran?

768
00:46:52,100 --> 00:47:06,400
Para todo x e y, el CAR del CONS
de x e y es x y el

769
00:47:06,400 --> 00:47:15,650
CDR del CONS de x e y es Y.
Ahora bien, esto no nos dice

770
00:47:15,650 --> 00:47:21,850
si el CONS tiene una identidad
como una persona.

771
00:47:21,850 --> 00:47:25,730
De hecho, todo lo que dice
es algo abstracto,

772
00:47:25,730 --> 00:47:29,740
que CONS es las partes
de las que está compuesto.

773
00:47:29,740 --> 00:47:32,319
Y, por supuesto, si dos cosas
están compuestas por las mismas partes,

774
00:47:32,320 --> 00:47:34,990
entonces son lo mismo, desde
el punto de vista de

775
00:47:34,990 --> 00:47:37,390
estos axiomas.

776
00:47:37,390 --> 00:47:39,920
Pero al introducir la
asignación --

777
00:47:39,920 --> 00:47:43,360
de hecho, los datos mutables
son una especie de asignación, tenemos

778
00:47:43,360 --> 00:47:45,590
un set-car! y un set-cdr! --

779
00:47:45,590 --> 00:47:48,300
Al introducirlo, estos axiomas
ya no nos cuentan toda

780
00:47:48,300 --> 00:47:49,830
la historia.

781
00:47:49,830 --> 00:47:53,250
Y todavía son ciertos
escritos exactamente así.

782
00:47:53,250 --> 00:47:56,700
Pero no nos cuentan toda
la historia.

783
00:47:56,700 --> 00:48:01,150
Porque si voy a setea un CAR
en un CONS particular,

784
00:48:01,150 --> 00:48:05,810
la pregunta es si eso
va a setear los CARs de todos

785
00:48:05,810 --> 00:48:10,900
los CONs de las mismas dos
cosas o no.

786
00:48:10,900 --> 00:48:12,610
Si usamos CONs para crear
cosas como números

787
00:48:12,610 --> 00:48:19,540
racionales o cosas como 3 sobre
4, suponiendo que tengo

788
00:48:19,540 --> 00:48:21,570
tres cuartos.

789
00:48:21,570 --> 00:48:24,110
¿Son lo mismo

790
00:48:24,110 --> 00:48:25,340
o son diferentes?

791
00:48:25,340 --> 00:48:27,860
Bueno, en el caso de los números,
no importa.

792
00:48:27,860 --> 00:48:29,410
Porque no hay significado
en cambiar el

793
00:48:29,410 --> 00:48:33,200
denominador de un número.

794
00:48:33,200 --> 00:48:34,670
Lo que podrías hacer es un número
que tiene un

795
00:48:34,670 --> 00:48:36,840
denominador distinto.

796
00:48:36,840 --> 00:48:38,980
Pero el concepto de cambiar un número
que tiene que tener

797
00:48:38,980 --> 00:48:41,570
un denominador diferente
es muy raro,

798
00:48:41,570 --> 00:48:44,770
y no está soportado por lo
que piensan de las matemáticas.

799
00:48:44,770 --> 00:48:46,570
Sin embargo, cuando estos
CONs representan cosas en

800
00:48:46,570 --> 00:48:50,940
el mundo físico, entonces 
cambiar algo como el CAR es como

801
00:48:50,940 --> 00:48:53,690
cortarse un pedazo de una uña.

802
00:48:53,690 --> 00:48:57,770
Entonces los CONs tienen identidad.

803
00:48:57,770 --> 00:49:01,280
Déjenme mostrarles lo que quiero
decir con identidad, en primer lugar.

804
00:49:01,280 --> 00:49:04,320
Hagamos un pequeño ejemplo aquí.

805
00:49:04,320 --> 00:49:15,200
Supongamos que defino A
como el CONS de 1 y de 2.

806
00:49:18,400 --> 00:49:22,509
Bueno, eso significa, en primer lugar,
que en algún lugar

807
00:49:22,510 --> 00:49:27,590
en algún entorno creé un símbolo
A con el valor que es un

808
00:49:27,590 --> 00:49:33,300
par que consiste de un puntero a 1 
y un puntero

809
00:49:33,300 --> 00:49:38,120
a 2, de esa manera.

810
00:49:38,120 --> 00:49:47,220
Ahora, supongan que también defino
B como el CONS--

811
00:49:53,320 --> 00:49:58,240
No importa, pero lo quiero
mejor, es más lindo--

812
00:49:58,240 --> 00:50:03,970
de A y de A.

813
00:50:03,970 --> 00:50:07,839
Bueno, en primer lugar, 
estoy usando el nombre A dos veces.

814
00:50:07,840 --> 00:50:09,100
En este momento, voy a pensar

815
00:50:09,100 --> 00:50:11,299
a los CONs como si tuviera identidad.

816
00:50:11,300 --> 00:50:13,690
Este es el mismo.

817
00:50:13,690 --> 00:50:19,200
Y eso quiere decir que hago
otro par, que voy

818
00:50:19,200 --> 00:50:29,120
a llamar B. Y que contiene
dos puntero a A.

819
00:50:29,120 --> 00:50:33,259
Tengo tres nombres para este objeto.

820
00:50:33,260 --> 00:50:34,790
A es su nombre.

821
00:50:34,790 --> 00:50:37,230
El CAR de B es su nombre.

822
00:50:37,230 --> 00:50:39,360
Y el CDR de B es su nombre.

823
00:50:39,360 --> 00:50:41,150
Tiene distintos alias, así se llaman.

824
00:50:44,230 --> 00:51:01,860
Ahora, supongan que hago algo como
set-car! del CAR de

825
00:51:01,860 --> 00:51:07,880
B a 3.

826
00:51:12,750 --> 00:51:17,830
Lo que esto quiere decir
es que busco el CAR de B, que es esto.

827
00:51:17,830 --> 00:51:20,935
Y lo seteo su CAR en 3, cambiando esto.

828
00:51:24,760 --> 00:51:29,940
He cambiado A. Si fuera a preguntar

829
00:51:29,940 --> 00:51:35,340
cuál es el CAR de A ahora

830
00:51:35,340 --> 00:51:42,250
obtendría un 3, incluso aunque
aquí vemos que A es el

831
00:51:42,250 --> 00:51:45,290
CONS de 1 y de 2.

832
00:51:45,290 --> 00:51:48,400
Hice que A cambiara al cambiar a B.

833
00:51:48,400 --> 00:51:52,100
Están compartiendo aquí.

834
00:51:52,100 --> 00:51:54,240
Eso es a veces lo que queremos.

835
00:51:54,240 --> 00:51:56,399
Seguramente en las colas y 
en cosas así, eso

836
00:51:56,400 --> 00:51:59,560
es exactamente lo que definimos--
a nuestra organización de la

837
00:51:59,560 --> 00:52:01,790
estructura de datos para facilitar--

838
00:52:01,790 --> 00:52:04,350
el compartir.

839
00:52:04,350 --> 00:52:08,950
Pero compartir sin darse cuenta,
las interaccion no anticipadas

840
00:52:08,950 --> 00:52:12,924
entre objetos, es la mayor
fuente de bugs que ocurren

841
00:52:12,925 --> 00:52:17,820
en programas complicados.
Así que al introducir esta posibilidad

842
00:52:17,820 --> 00:52:22,570
de tener cosas con identidad y compartir
y tener múltiples

843
00:52:22,570 --> 00:52:25,190
nombres para la misma cosa,
obtenemos un montón de poder.

844
00:52:25,190 --> 00:52:27,390
Pero vamos a pagar por ello
con un montón de

845
00:52:27,390 --> 00:52:28,640
complejidad y bugs.

846
00:52:32,190 --> 00:52:35,430
Así que, por ejemplo, miremos

847
00:52:35,430 --> 00:52:43,370
el CADR de B, que no tiene nada que ver

848
00:52:43,370 --> 00:52:46,560
aparentemente con el CAR de B.

849
00:52:46,560 --> 00:52:49,350
El CARD de B. ¿Qué es eso?

850
00:52:49,350 --> 00:52:53,560
Tomo el CDR de B y tomo el CAR de eso.

851
00:52:53,560 --> 00:52:56,480
También es 3.

852
00:52:56,480 --> 00:53:01,120
Así que puedo tener interacciones
no locales al compartir.

853
00:53:01,120 --> 00:53:02,480
Y tengo que ser muy cuidadoso con eso.

854
00:53:06,640 --> 00:53:10,529
Bueno, hasta ahora, por supuesto
parece que introduje varios

855
00:53:10,530 --> 00:53:13,300
diferentes operadores
de asignación --

856
00:53:13,300 --> 00:53:19,480
set!, set-car!, set-crd!. Bueno, quizá
tenga que deshacerme de

857
00:53:19,480 --> 00:53:22,820
set-car y set-cdr. Quizá no
valgan la pena.

858
00:53:22,820 --> 00:53:25,680
Bueno, la respuesta es que una
vez que dejas que la nariz del camello

859
00:53:25,680 --> 00:53:27,169
entre a la tienda, el resto
de él entra también.

860
00:53:30,160 --> 00:53:34,600
Todo lo que tengo que tener es set,
y puedo hacer todas

861
00:53:34,600 --> 00:53:35,850
las cosas malas que pueden pasar.

862
00:53:38,550 --> 00:53:40,690
Juguemos con eso un rato.

863
00:53:40,690 --> 00:53:45,330
Hace un par de días, cuando
les introdujimos los datos compuestos,

864
00:53:45,330 --> 00:53:49,980
vieron a Hal que les mostró
una definición de CONS en términos

865
00:53:49,980 --> 00:53:52,480
de un aceptador de mensajes.

866
00:53:52,480 --> 00:53:57,280
Voy a mostrarles incluso
algo más horrible, una

867
00:53:57,280 --> 00:54:04,440
definición de CONS en términos
de nada más que aire, aire caliente.

868
00:54:04,440 --> 00:54:07,640
¿Cuál es la definición de CONS
de la vieja forma funcional

869
00:54:07,640 --> 00:54:13,330
en términos puramente de
expresiones lambda?

870
00:54:13,330 --> 00:54:14,580
Procedimientos.

871
00:54:17,190 --> 00:54:20,630
Porque luego voy a modificar esta
definición para que

872
00:54:20,630 --> 00:54:25,200
la asignación sea un único
tipo de asignación, para

873
00:54:25,200 --> 00:54:28,580
deshacernos del set-car y del set-cdr
en términos de set.

874
00:54:28,580 --> 00:54:41,200
¿Qué pasa si defino CONS de x e y
como un procedimiento de un

875
00:54:41,200 --> 00:54:44,310
argumento llamado un mensaje M, 
que llama a ese

876
00:54:44,310 --> 00:54:46,320
mensaje con x e y?

877
00:54:51,120 --> 00:54:54,800
Esta idea fue inventada por
Alonzo Church,que fue el

878
00:54:54,800 --> 00:54:56,180
mejor programado del siglo XX, aunque

879
00:54:56,180 --> 00:54:57,870
nunca vio una computadora.

880
00:54:57,870 --> 00:54:59,130
Se hizo en los 1930s.

881
00:54:59,130 --> 00:55:02,220
Era un lógico, supongo que en Princeton
en ese momento.

882
00:55:08,660 --> 00:55:15,690
Defino CAR de X como el resultado
de aplicar X al

883
00:55:15,690 --> 00:55:24,000
procedimiento de dos argumentos
A y D, que selecciona A.

884
00:55:24,000 --> 00:55:36,410
Y voy a definir CDR de x como el
procedimiento, como el resultado

885
00:55:36,410 --> 00:55:46,670
de aplicar x a ese procedimiento
de A y D que selecciona D.

886
00:55:46,670 --> 00:55:50,510
Ahora bien, quizá no reconozcan
esto como CAR, CDR y CONS.

887
00:55:50,510 --> 00:55:52,690
Pero voy a demostrarles que 
satisface los

888
00:55:52,690 --> 00:55:55,210
axiomas originales, sólo una vez.

889
00:55:55,210 --> 00:55:58,290
Y luego vamos a jugar con ellos.

890
00:55:58,290 --> 00:56:09,695
Consideren el problema CAR de CONS
de, digamos, 35 y 47.

891
00:56:09,695 --> 00:56:11,120
Bueno, ¿qué es eso?

892
00:56:11,120 --> 00:56:14,800
Es el resultado de tomar CAR
sobre el resultado de sustituir

893
00:56:14,800 --> 00:56:19,710
35 y 37 por x e y
en el cuerpo de esto.

894
00:56:19,710 --> 00:56:20,690
Bueno, es bastante fácil.

895
00:56:20,690 --> 00:56:27,780
Es el CAR del resultado
de sustituir en el lambda de M,

896
00:56:27,780 --> 00:56:35,750
M de 35 y 47.

897
00:56:35,750 --> 00:56:38,680
Bueno, lo que es esto, es el
resultado de sustituir

898
00:56:38,680 --> 00:56:42,830
este objeto por X en el cuerpo
de esto.

899
00:56:42,830 --> 00:56:48,930
Así que esto es sólo lambda de M--

900
00:56:48,930 --> 00:56:51,890
eso se sustituye, porque este
objeto está siendo

901
00:56:51,900 --> 00:56:54,980
sustituido por X, que es 
el principio de una lista,

902
00:56:54,980 --> 00:56:57,260
lambda de M --

903
00:56:57,260 --> 00:57:07,570
M de 35 y 47, aplicado
al procedimento de A y D

904
00:57:07,570 --> 00:57:12,280
que devuelve A. Bueno, ese es
el resultado de sustituir

905
00:57:12,280 --> 00:57:15,840
esto por M aquí.

906
00:57:15,840 --> 00:57:22,320
Es lo mismo que lambda de A D A

907
00:57:22,320 --> 00:57:26,260
aplicada a 35 y 47.

908
00:57:26,260 --> 00:57:27,560
Bueno, eso es 35.

909
00:57:27,560 --> 00:57:36,000
Eso es sustituir 35 por A y
47 por D en A.

910
00:57:36,000 --> 00:57:40,720
No necesito datos en absoluto,
ni siquiera números.

911
00:57:40,720 --> 00:57:42,640
Ese es el hack de Alonzo Church.

912
00:57:52,420 --> 00:57:56,760
Bueno, le vamos a hacer algo feo.

913
00:57:56,760 --> 00:57:58,860
Siendo un lógico, no le gustaría esto.

914
00:57:58,860 --> 00:58:03,260
Pero como programador,
veamos el retroproyector.

915
00:58:03,260 --> 00:58:05,390
Aquí vamos.

916
00:58:05,390 --> 00:58:09,569
Voy a cambiar la definición de CONS.

917
00:58:09,570 --> 00:58:14,520
Es casi la misma que la de Alonzo
Church, pero no la misma.

918
00:58:14,520 --> 00:58:16,700
¿Qué tenemos aquí?

919
00:58:16,700 --> 00:58:20,880
El CONS de dos argumentos, x e y,
va a ser el procedimiento

920
00:58:20,880 --> 00:58:25,200
de un argumento M, que le aplica
M a x e y como antes,

921
00:58:25,200 --> 00:58:30,900
pero también dos permisos,
el permiso para

922
00:58:30,900 --> 00:58:35,300
setear x en n y el permiso
para setear y en n,

923
00:58:35,300 --> 00:58:40,940
dado un n.

924
00:58:40,940 --> 00:58:44,400
Así que además de las cosas
que tenía en la definición

925
00:58:44,400 --> 00:58:50,990
de Church, lo que tengo es 
que la cosa que retornará CONS

926
00:58:50,990 --> 00:58:55,899
aplicará su argumento no sólo

927
00:58:55,900 --> 00:59:00,210
a los valores de x y de del que
CONS está hecho, sino también

928
00:59:00,210 --> 00:59:03,365
permisos para setear X e Y 
a nuevos valores.

929
00:59:06,540 --> 00:59:09,220
Ahora, por supuesto, 
justo como antes, CAR

930
00:59:09,220 --> 00:59:11,689
es exactamente igual.

931
00:59:11,690 --> 00:59:14,980
El CAR de x no es nada más que
aplicar X, como

932
00:59:14,980 --> 00:59:18,110
en la definición de Church,
a un procedimiento de, en este caso,

933
00:59:18,110 --> 00:59:22,550
cuatro argumentos, que selecciona
el primero.

934
00:59:22,550 --> 00:59:28,750
Y como hicimos antes, ese será
el valor de X

935
00:59:28,750 --> 00:59:33,470
que estaba contenido en el
procedimiento que es el resultado

936
00:59:33,470 --> 00:59:36,259
de evaluar la expresión lambda
en el entorno

937
00:59:36,260 --> 00:59:37,920
donde x e y están definidas aquí.

938
00:59:41,940 --> 00:59:45,640
Ese es el valor de CONS.

939
00:59:45,640 --> 00:59:47,730
Ahora, la parte interesante.

940
00:59:47,730 --> 00:59:48,960
CDR es, por supuesto, lo mismo.

941
00:59:48,960 --> 00:59:54,270
La parte interesante, set-car!
y set-cdr!. Bueno, ya no son

942
00:59:54,270 --> 00:59:55,800
más complicados.

943
00:59:55,800 --> 01:00:02,700
set-car de un CONS X a un nuevo valor 
y no es nada más que

944
01:00:02,700 --> 01:00:06,960
aplicar ese CONS, que es el procedimiento
de cuatro --

945
01:00:06,970 --> 01:00:09,160
el procedimiento de un argumento que
aplica sus argumentos a

946
01:00:09,160 --> 01:00:15,950
cuatro cosas, a un procedimiento
que de cuatro argumentos--

947
01:00:15,950 --> 01:00:19,450
El valor de x, el valor de y, el permiso
para setear x, el

948
01:00:19,450 --> 01:00:21,390
permiso para setear y--

949
01:00:21,390 --> 01:00:23,609
Y usar ese permiso para

950
01:00:23,610 --> 01:00:26,150
setear x al nuevo valor.

951
01:00:31,650 --> 01:00:33,540
Y similarmente, set-cdr!
es lo mismo.

952
01:00:36,120 --> 01:00:38,470
Así que lo que han visto
es que no introduje

953
01:00:38,470 --> 01:00:40,470
niguna primitiva nueva.

954
01:00:40,470 --> 01:00:43,339
Si quiero o no implementar
esto de esta forma es una

955
01:00:43,340 --> 01:00:45,340
cuestión de ingeniería.

956
01:00:45,340 --> 01:00:48,800
Y la respuesta es, por supuesto
que no lo implemento así

957
01:00:48,800 --> 01:00:51,680
por razones que tiene que
ver con ingeniería.

958
01:00:51,680 --> 01:00:55,169
Sin embargo, en principio, lógicamente,
una vez que introduje

959
01:00:55,170 --> 01:00:57,515
un operador de asignación,

960
01:00:57,515 --> 01:00:58,765
los introduje todos.

961
01:01:05,420 --> 01:01:06,670
¿Alguna pregunta?

962
01:01:09,200 --> 01:01:12,400
Sí, David.

963
01:01:12,400 --> 01:01:14,860
Puedo seguirte hasta que llegas--
Puedo seguir

964
01:01:14,860 --> 01:01:15,740
todo eso.

965
01:01:15,740 --> 01:01:19,759
Pero cuanto introducimos
los permisos, definiendo CONS

966
01:01:19,760 --> 01:01:24,210
en términos de lambda n,
no entiendo dónde se pasa n.

967
01:01:24,210 --> 01:01:25,100
Lo siento.

968
01:01:25,100 --> 01:01:26,339
Les mostraré.

969
01:01:26,340 --> 01:01:27,360
Sigámoslo.

970
01:01:27,360 --> 01:01:29,180
Por supuesto, tenemos
que hacer en el pizarrón.

971
01:01:29,180 --> 01:01:30,169
No es tan difícil.

972
01:01:30,170 --> 01:01:32,450
Pero también es fácil aquí.

973
01:01:32,450 --> 01:01:38,520
Suponga que quiero hacer set-cdr
de x a y. Eso de aquí.

974
01:01:38,520 --> 01:01:43,680
set-cdr de x a y.
X es presumiblemente un CONS,

975
01:01:43,680 --> 01:01:46,890
una cosa resultante de evaluar
un CONS.

976
01:01:46,890 --> 01:01:54,290
Por lo tanto, x viene de un lugar 
aquí, donde ese x

977
01:01:54,300 --> 01:01:58,110
es el resultado de evaluar
esta expresión lambda.

978
01:01:58,110 --> 01:01:59,380
¿Correcto?

979
01:01:59,380 --> 01:02:04,475
Cuando evalué esa expresión
lambda, lo hice

980
01:02:04,475 --> 01:02:07,700
en un entorno donde se definieron

981
01:02:07,700 --> 01:02:08,950
los argumentos del CONS.

982
01:02:11,750 --> 01:02:14,530
Eso quiere decir que como variables
libres de esta expresión

983
01:02:14,530 --> 01:02:18,670
lambda, están en un frame,

984
01:02:18,670 --> 01:02:23,860
que es el frame padre de esta
expresión lambda, el

985
01:02:23,860 --> 01:02:27,470
procedimiento resultante
de esta expresión lambda. x e y

986
01:02:27,470 --> 01:02:29,250
tienen lugares.

987
01:02:29,250 --> 01:02:31,910
Y es posible setearlos.

988
01:02:31,910 --> 01:02:35,379
Lo seteo con N, que es el argumento

989
01:02:35,380 --> 01:02:37,100
del permiso.

990
01:02:37,100 --> 01:02:43,650
El permiso es un procedimiento
que se le pasa a M, que es el

991
01:02:43,650 --> 01:02:47,940
argumento que el objeto
CONS recibe.

992
01:02:47,940 --> 01:02:54,200
Ahora bien, volvamos aquí
En el set-cdr, el objeto CONS

993
01:02:54,200 --> 01:02:56,230
que es el primer argumento
del set-cdr,

994
01:02:56,230 --> 01:02:57,480
se pasa como argumento.

995
01:03:00,260 --> 01:03:02,910
Hay un procedimiento
de cuatro cosas, ciertamente, porque

996
01:03:02,910 --> 01:03:05,779
es la misma cosa que este M
de aquí, que está

997
01:03:05,780 --> 01:03:07,920
aplicado a cuatro objetos.

998
01:03:07,920 --> 01:03:12,970
El objeto de aquí, SD, es,
de hecho, este permiso.

999
01:03:15,470 --> 01:03:19,930
Cuando uso SD, se lo aplico
a y, aquí.

1000
01:03:22,910 --> 01:03:25,740
Así que eso viene de esto.

1001
01:03:25,740 --> 01:03:27,410
¿Pero qué es--?

1002
01:03:27,410 --> 01:03:31,420
Para terminar esto,
el n que estaba allá es el y

1003
01:03:31,420 --> 01:03:34,160
de acá.

1004
01:03:34,160 --> 01:03:34,810
¿Qué les parece?

1005
01:03:34,810 --> 01:03:35,750
Correcto, bien.

1006
01:03:35,750 --> 01:03:40,240
Ahora bien, cuando haces un 
set-cdr , x es el valor

1007
01:03:40,240 --> 01:03:41,970
en el que el CDR se va a convertir.

1008
01:03:41,970 --> 01:03:44,741
El x de aquí.

1009
01:03:44,742 --> 01:03:46,200
Lo siento, eso no es cierto.

1010
01:03:46,200 --> 01:03:48,720
El x es --set-cdr tiene dos argumetnos--

1011
01:03:48,720 --> 01:03:56,149
El CONS que estoy cambiando y
el valor al que lo estoy cambiando.

1012
01:03:56,150 --> 01:03:58,320
Los tienes al revés, eso es todo.

1013
01:04:01,750 --> 01:04:03,000
¿Alguna otra pregunta?

1014
01:04:07,880 --> 01:04:08,640
Bueno, gracias.

1015
01:04:08,640 --> 01:04:09,890
Es hora de almorzar.
